// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * Account object.
 */
export const accountSchema = z.object({
    active_promotions: z.array(z.object({
        credit_monthly_cap: z.string(),
        credit_remaining: z.string(),
        description: z.string(),
        expire_dt: z.string(),
        image_url: z.string(),
        service_type: z.enum([
            'all',
            'backup',
            'blockstorage',
            'db_mysql',
            'ip_v4',
            'linode',
            'linode_disk',
            'linode_memory',
            'longview',
            'managed',
            'nodebalancer',
            'objectstorage',
            'placement_group',
            'transfer_tx'
        ]),
        summary: z.string(),
        this_month_credit_remaining: z.string()
    }).readonly()).readonly(),
    active_since: z.iso.datetime().readonly(),
    address_1: z.string().max(64),
    address_2: z.string().max(64),
    balance: z.number().readonly(),
    balance_uninvoiced: z.number().readonly(),
    billing_source: z.enum(['akamai', 'linode']),
    capabilities: z.array(z.string()).readonly(),
    city: z.string().max(24),
    company: z.string().max(128),
    country: z.string(),
    credit_card: z.object({
        expiry: z.string(),
        last_four: z.string()
    }).readonly(),
    email: z.string().max(128),
    euuid: z.uuid().readonly(),
    first_name: z.string().max(50),
    last_name: z.string().max(50),
    phone: z.string().max(32),
    state: z.string().max(24),
    tax_id: z.string().max(25),
    zip: z.string()
});

/**
 * Account Service Availability object.
 */
export const accountAvailabilitySchema = z.object({
    available: z.array(z.string()).readonly(),
    region: z.string().readonly(),
    unavailable: z.array(z.string()).readonly()
});

/**
 * Account Settings object.
 */
export const accountSettingsSchema = z.object({
    backups_enabled: z.boolean(),
    interfaces_for_new_linodes: z.enum([
        'legacy_config_only',
        'legacy_config_default_but_linode_allowed',
        'linode_default_but_legacy_config_allowed',
        'linode_only'
    ]),
    longview_subscription: z.string().readonly(),
    maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
    managed: z.boolean().readonly(),
    network_helper: z.boolean(),
    object_storage: z.enum([
        'disabled',
        'suspended',
        'active'
    ])
});

/**
 * The API responds with an empty object.
 */
export const addedEmptyObjSchema = z.record(z.string(), z.unknown());

export const addedGetAccountLogins200Schema = z.object({
    data: z.array(z.object({
        datetime: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        ip: z.string().readonly(),
        restricted: z.boolean().readonly(),
        status: z.enum(['successful', 'failed']),
        username: z.string().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const addedGetAvailability200Schema = z.object({
    data: z.array(z.object({
        available: z.array(z.string()).readonly(),
        region: z.string().readonly(),
        unavailable: z.array(z.string()).readonly()
    }))
}).and(z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}));

export const addedGetChildAccounts200Schema = z.object({
    data: z.array(z.object({
        active_since: z.iso.datetime().readonly(),
        address_1: z.string().max(64),
        address_2: z.string().max(64),
        balance: z.number().readonly(),
        balance_uninvoiced: z.number().readonly(),
        billing_source: z.enum(['external']),
        capabilities: z.array(z.string()).readonly(),
        city: z.string().max(24),
        company: z.string().max(128),
        country: z.string(),
        credit_card: z.object({
            expiry: z.string(),
            last_four: z.string()
        }).readonly(),
        email: z.string().max(128),
        euuid: z.uuid().readonly(),
        first_name: z.string().max(50),
        last_name: z.string().max(50),
        phone: z.string().max(32),
        state: z.string().max(24),
        tax_id: z.string().max(25),
        zip: z.string()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const addedGetClients200Schema = z.object({
    data: z.array(z.object({
        id: z.string().readonly(),
        label: z.string().min(1).max(512),
        public: z.boolean().default(false),
        redirect_uri: z.string(),
        secret: z.string().readonly(),
        status: z.enum([
            'active',
            'disabled',
            'suspended'
        ]),
        thumbnail_url: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const addedGetEnrolledBetaPrograms200Schema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.array(z.object({
        description: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        ended: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        enrolled: z.iso.datetime().readonly(),
        id: z.string(),
        label: z.string().readonly(),
        started: z.iso.datetime().readonly()
    }))
}));

export const addedGetEntityTransfers200Schema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.optional(z.array(z.object({
        created: z.iso.datetime(),
        entities: z.object({
            linodes: z.array(z.int())
        }),
        expiry: z.iso.datetime(),
        is_sender: z.boolean(),
        status: z.enum([
            'accepted',
            'canceled',
            'completed',
            'failed',
            'pending',
            'stale'
        ]),
        token: z.uuid(),
        updated: z.iso.datetime()
    })))
}));

export const addedGetInvoiceItems200Schema = z.object({
    data: z.array(z.object({
        amount: z.number().readonly(),
        from: z.iso.datetime().readonly(),
        label: z.string().readonly(),
        quantity: z.int().readonly(),
        region: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        tax: z.number().readonly(),
        to: z.iso.datetime().readonly(),
        total: z.number().readonly(),
        type: z.enum(['hourly', 'misc']),
        unit_price: z.string().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const addedGetInvoices200Schema = z.object({
    data: z.array(z.object({
        billing_source: z.enum(['akamai', 'linode']),
        date: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        label: z.string().readonly(),
        subtotal: z.number().readonly(),
        tax: z.number().readonly(),
        tax_summary: z.array(z.object({
            name: z.string(),
            tax: z.number()
        })).readonly(),
        total: z.number().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const addedGetNotifications200Schema = z.object({
    data: z.array(z.object({
        body: z.union([
            z.string(),
            z.null()
        ]),
        entity: z.union([
            z.object({
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                label: z.union([
                    z.string(),
                    z.null()
                ]),
                type: z.enum([
                    'account',
                    'entity_transfer',
                    'linode',
                    'loadbalancers',
                    'nodebalancer',
                    'promotion',
                    'region',
                    'ticket',
                    'volume'
                ]),
                url: z.union([
                    z.string(),
                    z.null()
                ])
            }),
            z.null()
        ]),
        label: z.string(),
        message: z.string(),
        severity: z.enum([
            'minor',
            'major',
            'critical'
        ]),
        type: z.enum([
            'migration_scheduled',
            'migration_imminent',
            'migration_pending',
            'reboot_scheduled',
            'outage',
            'payment_due',
            'ticket_important',
            'ticket_abuse',
            'notice',
            'maintenance',
            'maintenance_scheduled',
            'promotion',
            'security_reboot_maintenance_scheduled',
            'tax_id_verifying'
        ]),
        until: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        when: z.union([
            z.iso.datetime(),
            z.null()
        ])
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const addedGetPaymentMethods200Schema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        data: z.union([
            z.object({
                card_type: z.string().readonly(),
                expiry: z.string().readonly(),
                last_four: z.string().readonly()
            }),
            z.object({
                card_type: z.string().readonly(),
                expiry: z.string().readonly(),
                last_four: z.string().readonly()
            }),
            z.object({
                email: z.string().readonly(),
                paypal_id: z.string().readonly()
            })
        ]),
        id: z.int(),
        is_default: z.boolean(),
        type: z.enum([
            'credit_card',
            'google_pay',
            'paypal'
        ])
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const addedGetPayments200Schema = z.object({
    data: z.array(z.object({
        date: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        usd: z.int().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const addedGetServiceTransfers200Schema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime(),
        entities: z.object({
            linodes: z.array(z.int())
        }),
        expiry: z.iso.datetime(),
        is_sender: z.boolean(),
        status: z.enum([
            'accepted',
            'canceled',
            'completed',
            'failed',
            'pending',
            'stale'
        ]),
        token: z.uuid(),
        updated: z.iso.datetime()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const addedGetUser200Schema = z.object({
    email: z.email(),
    last_login: z.union([
        z.object({
            login_datetime: z.iso.datetime().readonly(),
            status: z.enum(['successful', 'failed'])
        }).readonly(),
        z.null()
    ]).readonly(),
    password_created: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    restricted: z.boolean(),
    ssh_keys: z.array(z.string()).readonly(),
    tfa_enabled: z.boolean().readonly(),
    username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/),
    verified_phone_number: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
}).and(z.object({
    user_type: z.enum([
        'parent',
        'child',
        'proxy',
        'default'
    ])
}));

export const addedGetUsers200Schema = z.object({
    data: z.array(z.object({
        email: z.email(),
        last_login: z.union([
            z.object({
                login_datetime: z.iso.datetime().readonly(),
                status: z.enum(['successful', 'failed'])
            }).readonly(),
            z.null()
        ]).readonly(),
        password_created: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        restricted: z.boolean(),
        ssh_keys: z.array(z.string()).readonly(),
        tfa_enabled: z.boolean().readonly(),
        username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/),
        verified_phone_number: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    }).and(z.object({
        user_type: z.enum([
            'parent',
            'child',
            'proxy',
            'default'
        ])
    }))),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

/**
 * The Beta Program ID to enroll in for your Account.
 */
export const addedPostBetaProgramSchema = z.object({
    id: z.string()
});

export const addedPostCancelAccountSchema = z.object({
    comments: z.string()
});

export const addedPostCancelAccount200Schema = z.object({
    survey_link: z.string()
});

export const addedPostCancelAccount409Schema = z.object({
    errors: z.array(z.object({
        reason: z.string()
    }))
});

export const addedPostCancelAccount504Schema = z.object({
    errors: z.array(z.object({
        reason: z.string()
    }))
});

/**
 * A third-party application registered to Linode that users may log into with their Linode account through our authentication server at [login.linode.com](https://login.linode.com).  Using an OAuth Client, a third-party developer may be given access to some, or all, of a User's account for the purposes of their application.
 */
export const addedPostClientSchema = z.object({
    id: z.string().readonly(),
    label: z.string().min(1).max(512),
    public: z.boolean().default(false),
    redirect_uri: z.string(),
    secret: z.string().readonly(),
    status: z.enum([
        'active',
        'disabled',
        'suspended'
    ]),
    thumbnail_url: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const addedPostEntityTransferSchema = z.object({
    entities: z.object({
        linodes: z.array(z.int())
    })
});

export const addedPostPayPalPayment200Schema = z.object({
    checkout_token: z.string().readonly(),
    payment_id: z.string()
});

export const addedPostPaymentSchema = z.object({
    payment_method_id: z.int(),
    usd: z.string().regex(/^\$?\d+\.\d{2}$/)
});

/**
 * Payment Method Request Object.
 */
export const addedPostPaymentMethodSchema = z.object({
    data: z.object({
        card_number: z.string().min(14).max(24),
        cvv: z.string().min(3).max(4),
        expiry_month: z.int().gte(1).lte(12),
        expiry_year: z.int()
    }),
    is_default: z.boolean(),
    type: z.enum(['credit_card'])
});

export const addedPostPromoCreditSchema = z.object({
    promo_code: z.string().min(1).max(32)
});

export const addedPostServiceTransferSchema = z.object({
    entities: z.object({
        linodes: z.array(z.int())
    })
});

/**
 * A user on your account. Unrestricted users can log in and access information about your account, while restricted users may only access entities or perform actions they've been granted access to.
 */
export const addedPostUserSchema = z.object({
    email: z.email(),
    last_login: z.union([
        z.object({
            login_datetime: z.iso.datetime().readonly(),
            status: z.enum(['successful', 'failed'])
        }).readonly(),
        z.null()
    ]).readonly(),
    password_created: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    restricted: z.boolean(),
    ssh_keys: z.array(z.string()).readonly(),
    tfa_enabled: z.boolean().readonly(),
    username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/),
    verified_phone_number: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const addedPutUser200Schema = z.object({
    email: z.email(),
    last_login: z.union([
        z.object({
            login_datetime: z.iso.datetime().readonly(),
            status: z.enum(['successful', 'failed'])
        }).readonly(),
        z.null()
    ]).readonly(),
    password_created: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    restricted: z.boolean(),
    ssh_keys: z.array(z.string()).readonly(),
    tfa_enabled: z.boolean().readonly(),
    username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/),
    verified_phone_number: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
}).and(z.object({
    user_type: z.enum([
        'parent',
        'child',
        'proxy',
        'default'
    ])
}));

/**
 * Acknowledgment status for agreements on your account. When acknowledging any agreements, set them to `true` and omit any remainders.
 */
export const agreementsSchema = z.object({
    billing_agreement: z.boolean(),
    eu_model: z.boolean(),
    master_service_agreement: z.boolean(),
    privacy_policy: z.boolean()
});

/**
 * An object representing an enrolled Beta Program for the Account.
 */
export const betaProgramEnrolledSchema = z.object({
    description: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    ended: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    enrolled: z.iso.datetime().readonly(),
    id: z.string(),
    label: z.string().readonly(),
    started: z.iso.datetime().readonly()
});

/**
 * Child account object.
 */
export const childAccountSchema = z.object({
    active_since: z.iso.datetime().readonly(),
    address_1: z.string().max(64),
    address_2: z.string().max(64),
    balance: z.number().readonly(),
    balance_uninvoiced: z.number().readonly(),
    billing_source: z.enum(['external']),
    capabilities: z.array(z.string()).readonly(),
    city: z.string().max(24),
    company: z.string().max(128),
    country: z.string(),
    credit_card: z.object({
        expiry: z.string(),
        last_four: z.string()
    }).readonly(),
    email: z.string().max(128),
    euuid: z.uuid().readonly(),
    first_name: z.string().max(50),
    last_name: z.string().max(50),
    phone: z.string().max(32),
    state: z.string().max(24),
    tax_id: z.string().max(25),
    zip: z.string()
});

/**
 * An object representing the credit card information you have on file with Linode to make Payments against your Account.
 */
export const creditCardSchema = z.object({
    card_number: z.string().min(14).max(24),
    cvv: z.string().min(3).max(4),
    expiry_month: z.int().gte(1).lte(12),
    expiry_year: z.int()
});

/**
 * Credit card
 *
 * Credit card information.
 */
export const creditCardDataSchema = z.object({
    card_type: z.string().readonly(),
    expiry: z.string().readonly(),
    last_four: z.string().readonly()
});

/**
 * __Read-only__ Additional details regarding the Beta Program.
 */
export const descriptionSchema = z.union([
    z.string().readonly(),
    z.null()
]).readonly();

/**
 * __Filterable__, __Read-only__ The date-time that the Beta Program ended.
 *
 * `null` indicates that the Beta Program is ongoing.
 */
export const endedSchema = z.union([
    z.iso.datetime().readonly(),
    z.null()
]).readonly();

/**
 * A collection of the entities to include in this transfer request, separated by type.
 */
export const entitiesSchema = z.object({
    linodes: z.array(z.int())
});

/**
 * An object representing an Entity Transfer.
 */
export const entityTransferSchema = z.object({
    created: z.iso.datetime(),
    entities: z.object({
        linodes: z.array(z.int())
    }),
    expiry: z.iso.datetime(),
    is_sender: z.boolean(),
    status: z.enum([
        'accepted',
        'canceled',
        'completed',
        'failed',
        'pending',
        'stale'
    ]),
    token: z.uuid(),
    updated: z.iso.datetime()
});

/**
 * An object for describing a single error that occurred during the processing of a request.
 */
export const errorObjectSchema = z.object({
    field: z.string(),
    reason: z.string()
});

/**
 * A specific event object. An event is an action taken against an entity related to your account. For example, if you boot a Linode, the system creates an event. The events returned depend on your user grants.
 */
export const eventSchema = z.object({
    action: z.enum([
        'account_agreement_eu_model',
        'account_promo_apply',
        'account_update',
        'account_settings_update',
        'backups_enable',
        'backups_cancel',
        'backups_restore',
        'community_question_reply',
        'community_like',
        'community_mention',
        'credit_card_updated',
        'database_create',
        'database_delete',
        'database_update',
        'database_failed',
        'database_degraded',
        'database_create_failed',
        'database_update_failed',
        'database_backup_create',
        'database_backup_restore',
        'database_backup_delete',
        'database_credentials_reset',
        'database_low_disk_space',
        'database_scale',
        'database_resize',
        'database_resize_create',
        'database_migrate',
        'database_upgrade',
        'database_suspend',
        'database_resume',
        'disk_create',
        'disk_delete',
        'disk_update',
        'disk_duplicate',
        'disk_imagize',
        'disk_resize',
        'dns_record_create',
        'dns_record_delete',
        'dns_record_update',
        'dns_zone_create',
        'dns_zone_delete',
        'dns_zone_import',
        'dns_zone_update',
        'entity_transfer_accept',
        'entity_transfer_accept_recipient',
        'entity_transfer_cancel',
        'entity_transfer_create',
        'entity_transfer_fail',
        'entity_transfer_stale',
        'firewall_apply',
        'firewall_create',
        'firewall_delete',
        'firewall_disable',
        'firewall_enable',
        'firewall_update',
        'firewall_device_add',
        'firewall_device_remove',
        'firewall_rules_update',
        'host_reboot',
        'image_delete',
        'image_update',
        'image_upload',
        'interface_create',
        'interface_delete',
        'interface_update',
        'ipaddress_update',
        'ipv6pool_add',
        'ipv6pool_delete',
        'lassie_reboot',
        'lish_boot',
        'linode_addip',
        'linode_boot',
        'linode_clone',
        'linode_create',
        'linode_delete',
        'linode_update',
        'linode_deleteip',
        'linode_kvmify',
        'linode_migrate',
        'linode_migrate_datacenter',
        'linode_migrate_datacenter_create',
        'linode_mutate',
        'linode_mutate_create',
        'linode_poweroff_on',
        'linode_reboot',
        'linode_rebuild',
        'linode_resize',
        'linode_resize_create',
        'linode_resize_warm_create',
        'linode_shutdown',
        'linode_snapshot',
        'linode_config_create',
        'linode_config_delete',
        'linode_config_update',
        'lke_control_plane_acl_create',
        'lke_control_plane_acl_update',
        'lke_control_plane_acl_delete',
        'lke_cluster_create',
        'lke_cluster_update',
        'lke_cluster_delete',
        'lke_cluster_recycle',
        'lke_cluster_regenerate',
        'lke_node_create',
        'lke_node_delete',
        'lke_node_recycle',
        'lke_pool_create',
        'lke_pool_delete',
        'lke_pool_recycle',
        'lke_kubeconfig_regenerate',
        'lke_token_rotate',
        'longviewclient_create',
        'longviewclient_delete',
        'longviewclient_update',
        'managed_disabled',
        'managed_enabled',
        'managed_service_create',
        'managed_service_delete',
        'nodebalancer_create',
        'nodebalancer_delete',
        'nodebalancer_update',
        'nodebalancer_config_create',
        'nodebalancer_config_delete',
        'nodebalancer_config_update',
        'nodebalancer_node_create',
        'nodebalancer_node_delete',
        'nodebalancer_node_update',
        'oauth_client_create',
        'oauth_client_delete',
        'oauth_client_secret_reset',
        'oauth_client_update',
        'obj_access_key_create',
        'obj_access_key_delete',
        'obj_access_key_update',
        'password_reset',
        'payment_method_add',
        'payment_submitted',
        'placement_group_assign',
        'placement_group_became_compliant',
        'placement_group_became_non_compliant',
        'placement_group_create',
        'placement_group_delete',
        'placement_group_unassign',
        'placement_group_update',
        'profile_update',
        'stackscript_create',
        'stackscript_delete',
        'stackscript_update',
        'stackscript_publicize',
        'stackscript_revise',
        'subnet_create',
        'subnet_delete',
        'subnet_update',
        'tag_create',
        'tag_delete',
        'tag_update',
        'tax_id_valid',
        'tax_id_invalid',
        'tfa_disabled',
        'tfa_enabled',
        'ticket_attachment_upload',
        'ticket_create',
        'ticket_update',
        'token_create',
        'token_delete',
        'token_update',
        'user_create',
        'user_update',
        'user_delete',
        'user_ssh_key_add',
        'user_ssh_key_delete',
        'user_ssh_key_update',
        'vlan_attach',
        'vlan_detach',
        'volume_attach',
        'volume_clone',
        'volume_create',
        'volume_delete',
        'volume_update',
        'volume_detach',
        'volume_resize',
        'volume_migrate',
        'volume_migrate_scheduled',
        'vpc_create',
        'vpc_delete',
        'vpc_update'
    ]),
    created: z.iso.datetime().readonly(),
    details: z.object({
        complete_time: z.iso.datetime(),
        description: z.enum(['Scheduled Maintenance', 'Emergency Maintenance']),
        maintenance_policy_set: z.string(),
        not_before: z.iso.datetime(),
        source: z.enum(['platform', 'user']),
        start_time: z.iso.datetime()
    }).readonly(),
    duration: z.number().readonly(),
    entity: z.object({
        id: z.int(),
        label: z.string(),
        type: z.enum([
            'account',
            'backups',
            'community',
            'disks',
            'domain',
            'entity_transfer',
            'firewall',
            'image',
            'ipaddress',
            'linode',
            'longview',
            'loadbalancer',
            'managed_service',
            'nodebalancer',
            'oauth_client',
            'profile',
            'stackscript',
            'tag',
            'ticket',
            'token',
            'user',
            'user_ssh_key',
            'volume'
        ]),
        url: z.string()
    }).readonly(),
    id: z.int().readonly(),
    message: z.union([
        z.string(),
        z.null()
    ]),
    percent_complete: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    rate: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    secondary_entity: z.object({
        id: z.string(),
        label: z.string(),
        type: z.string().readonly(),
        url: z.string()
    }).readonly(),
    seen: z.boolean().readonly(),
    status: z.enum([
        'failed',
        'finished',
        'notification',
        'scheduled',
        'started'
    ]),
    time_remaining: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    username: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const eventsSchema = z.object({
    data: z.array(z.object({
        action: z.enum([
            'account_agreement_eu_model',
            'account_promo_apply',
            'account_update',
            'account_settings_update',
            'backups_enable',
            'backups_cancel',
            'backups_restore',
            'community_question_reply',
            'community_like',
            'community_mention',
            'credit_card_updated',
            'database_create',
            'database_delete',
            'database_update',
            'database_failed',
            'database_degraded',
            'database_create_failed',
            'database_update_failed',
            'database_backup_create',
            'database_backup_restore',
            'database_backup_delete',
            'database_credentials_reset',
            'database_low_disk_space',
            'database_scale',
            'database_resize',
            'database_resize_create',
            'database_migrate',
            'database_upgrade',
            'database_suspend',
            'database_resume',
            'disk_create',
            'disk_delete',
            'disk_update',
            'disk_duplicate',
            'disk_imagize',
            'disk_resize',
            'dns_record_create',
            'dns_record_delete',
            'dns_record_update',
            'dns_zone_create',
            'dns_zone_delete',
            'dns_zone_import',
            'dns_zone_update',
            'entity_transfer_accept',
            'entity_transfer_accept_recipient',
            'entity_transfer_cancel',
            'entity_transfer_create',
            'entity_transfer_fail',
            'entity_transfer_stale',
            'firewall_apply',
            'firewall_create',
            'firewall_delete',
            'firewall_disable',
            'firewall_enable',
            'firewall_update',
            'firewall_device_add',
            'firewall_device_remove',
            'firewall_rules_update',
            'host_reboot',
            'image_delete',
            'image_update',
            'image_upload',
            'interface_create',
            'interface_delete',
            'interface_update',
            'ipaddress_update',
            'ipv6pool_add',
            'ipv6pool_delete',
            'lassie_reboot',
            'lish_boot',
            'linode_addip',
            'linode_boot',
            'linode_clone',
            'linode_create',
            'linode_delete',
            'linode_update',
            'linode_deleteip',
            'linode_kvmify',
            'linode_migrate',
            'linode_migrate_datacenter',
            'linode_migrate_datacenter_create',
            'linode_mutate',
            'linode_mutate_create',
            'linode_poweroff_on',
            'linode_reboot',
            'linode_rebuild',
            'linode_resize',
            'linode_resize_create',
            'linode_resize_warm_create',
            'linode_shutdown',
            'linode_snapshot',
            'linode_config_create',
            'linode_config_delete',
            'linode_config_update',
            'lke_cluster_create',
            'lke_cluster_update',
            'lke_cluster_delete',
            'lke_cluster_recycle',
            'lke_cluster_regenerate',
            'lke_control_plane_acl_create',
            'lke_control_plane_acl_update',
            'lke_control_plane_acl_delete',
            'lke_node_create',
            'lke_node_delete',
            'lke_node_recycle',
            'lke_pool_create',
            'lke_pool_delete',
            'lke_pool_recycle',
            'lke_kubeconfig_regenerate',
            'lke_token_rotate',
            'longviewclient_create',
            'longviewclient_delete',
            'longviewclient_update',
            'managed_disabled',
            'managed_enabled',
            'managed_service_create',
            'managed_service_delete',
            'nodebalancer_create',
            'nodebalancer_delete',
            'nodebalancer_update',
            'nodebalancer_config_create',
            'nodebalancer_config_delete',
            'nodebalancer_config_update',
            'nodebalancer_node_create',
            'nodebalancer_node_delete',
            'nodebalancer_node_update',
            'oauth_client_create',
            'oauth_client_delete',
            'oauth_client_secret_reset',
            'oauth_client_update',
            'obj_access_key_create',
            'obj_access_key_delete',
            'obj_access_key_update',
            'password_reset',
            'payment_method_add',
            'payment_submitted',
            'placement_group_assign',
            'placement_group_became_compliant',
            'placement_group_became_non_compliant',
            'placement_group_create',
            'placement_group_delete',
            'placement_group_unassign',
            'placement_group_update',
            'profile_update',
            'stackscript_create',
            'stackscript_delete',
            'stackscript_update',
            'stackscript_publicize',
            'stackscript_revise',
            'subnet_create',
            'subnet_delete',
            'subnet_update',
            'tag_create',
            'tag_delete',
            'tag_update',
            'tax_id_valid',
            'tax_id_invalid',
            'tfa_disabled',
            'tfa_enabled',
            'ticket_attachment_upload',
            'ticket_create',
            'ticket_update',
            'token_create',
            'token_delete',
            'token_update',
            'user_create',
            'user_update',
            'user_delete',
            'user_ssh_key_add',
            'user_ssh_key_delete',
            'user_ssh_key_update',
            'vlan_attach',
            'vlan_detach',
            'volume_attach',
            'volume_clone',
            'volume_create',
            'volume_delete',
            'volume_update',
            'volume_detach',
            'volume_resize',
            'volume_migrate',
            'volume_migrate_scheduled',
            'vpc_create',
            'vpc_delete',
            'vpc_update'
        ]),
        created: z.iso.datetime(),
        details: z.object({
            complete_time: z.iso.datetime(),
            description: z.enum(['Scheduled Maintenance', 'Emergency Maintenance']),
            maintenance_policy_set: z.string(),
            not_before: z.iso.datetime(),
            source: z.enum(['platform', 'user']),
            start_time: z.iso.datetime()
        }),
        duration: z.number(),
        entity: z.object({
            id: z.int(),
            label: z.string(),
            type: z.enum([
                'account',
                'backups',
                'community',
                'disks',
                'domain',
                'entity_transfer',
                'firewall',
                'image',
                'ipaddress',
                'linode',
                'longview',
                'loadbalancer',
                'managed_service',
                'nodebalancer',
                'oauth_client',
                'profile',
                'stackscript',
                'tag',
                'ticket',
                'token',
                'user',
                'user_ssh_key',
                'volume'
            ]),
            url: z.string()
        }),
        id: z.int(),
        message: z.union([
            z.string(),
            z.null()
        ]),
        percent_complete: z.union([
            z.int(),
            z.null()
        ]),
        rate: z.union([
            z.string(),
            z.null()
        ]),
        secondary_entity: z.object({
            id: z.string(),
            label: z.string(),
            type: z.string(),
            url: z.string()
        }),
        seen: z.boolean(),
        status: z.enum([
            'completed',
            'failed',
            'finished',
            'in_progress',
            'notification',
            'scheduled',
            'started'
        ]),
        time_remaining: z.union([
            z.string(),
            z.null()
        ]),
        username: z.union([
            z.string(),
            z.null()
        ])
    })),
    page: z.int(),
    pages: z.int(),
    results: z.int()
});

export const getMaintenance200Schema = z.object({
    data: z.array(z.object({
        complete_time: z.iso.datetime(),
        description: z.enum(['Scheduled Maintenance', 'Emergency Maintenance']),
        entity: z.object({
            id: z.number(),
            label: z.string(),
            type: z.string(),
            url: z.string()
        }),
        maintenance_policy_set: z.string(),
        not_before: z.iso.datetime(),
        reason: z.string(),
        source: z.enum(['platform', 'user']),
        start_time: z.iso.datetime(),
        status: z.enum([
            'pending',
            'scheduled',
            'started',
            'in-progress',
            'completed',
            'canceled'
        ]),
        type: z.enum([
            'reboot',
            'cold_migration',
            'live_migration',
            'migrate',
            'power_off_on'
        ]),
        when: z.iso.datetime()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

/**
 * Google Pay
 *
 * Google Pay information.
 */
export const googlePayDataSchema = z.object({
    card_type: z.string().readonly(),
    expiry: z.string().readonly(),
    last_four: z.string().readonly()
});

/**
 * Represents the level of access a restricted user has to a specific resource on the account.
 */
export const grantSchema = z.object({
    id: z.int(),
    label: z.string().readonly(),
    permissions: z.enum(['read_only', 'read_write'])
});

export const grantsResponseSchema = z.object({
    database: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    domain: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    firewall: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    global: z.object({
        account_access: z.enum(['read_only', 'read_write']),
        add_databases: z.boolean(),
        add_domains: z.boolean(),
        add_firewalls: z.boolean(),
        add_images: z.boolean(),
        add_linodes: z.boolean(),
        add_longview: z.boolean(),
        add_nodebalancers: z.boolean(),
        add_stackscripts: z.boolean(),
        add_volumes: z.boolean(),
        add_vpcs: z.boolean(),
        cancel_account: z.boolean(),
        child_account_access: z.union([
            z.boolean(),
            z.null()
        ]),
        longview_subscription: z.boolean()
    }),
    image: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    linode: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    longview: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    nodebalancer: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    stackscript: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    volume: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    vpc: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    }))
});

/**
 * The unique identifier of the Beta Program.
 */
export const idSchema = z.string();

/**
 * Account Invoice object.
 */
export const invoiceSchema = z.object({
    billing_source: z.enum(['akamai', 'linode']),
    date: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    label: z.string().readonly(),
    subtotal: z.number().readonly(),
    tax: z.number().readonly(),
    tax_summary: z.array(z.object({
        name: z.string(),
        tax: z.number()
    })).readonly(),
    total: z.number().readonly()
});

/**
 * An InvoiceItem object.
 */
export const invoiceItemSchema = z.object({
    amount: z.number().readonly(),
    from: z.iso.datetime().readonly(),
    label: z.string().readonly(),
    quantity: z.int().readonly(),
    region: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    tax: z.number().readonly(),
    to: z.iso.datetime().readonly(),
    total: z.number().readonly(),
    type: z.enum(['hourly', 'misc']),
    unit_price: z.string().readonly()
});

/**
 * Whether this Payment Method is the default method for automatically processing service charges.
 */
export const isDefaultSchema = z.boolean();

/**
 * __Filterable__, __Read-only__ The name of the Beta Program.
 */
export const labelSchema = z.string().readonly();

/**
 * An object representing a previous successful login for a User.
 */
export const loginSchema = z.object({
    datetime: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    ip: z.string().readonly(),
    restricted: z.boolean().readonly(),
    status: z.enum(['successful', 'failed']),
    username: z.string().readonly()
});

/**
 * Information about maintenance affecting an entity.
 */
export const maintenanceSchema = z.object({
    complete_time: z.iso.datetime(),
    description: z.enum(['Scheduled Maintenance', 'Emergency Maintenance']),
    entity: z.object({
        id: z.number(),
        label: z.string(),
        type: z.string(),
        url: z.string()
    }),
    maintenance_policy_set: z.string(),
    not_before: z.iso.datetime(),
    reason: z.string(),
    source: z.enum(['platform', 'user']),
    start_time: z.iso.datetime(),
    status: z.enum([
        'pending',
        'scheduled',
        'started',
        'in-progress',
        'completed',
        'canceled'
    ]),
    type: z.enum([
        'reboot',
        'cold_migration',
        'live_migration',
        'migrate',
        'power_off_on'
    ]),
    when: z.iso.datetime()
});

/**
 * An important, often time-sensitive item related to your account.
 */
export const notificationSchema = z.object({
    body: z.union([
        z.string(),
        z.null()
    ]),
    entity: z.union([
        z.object({
            id: z.union([
                z.int(),
                z.null()
            ]),
            label: z.union([
                z.string(),
                z.null()
            ]),
            type: z.enum([
                'account',
                'entity_transfer',
                'linode',
                'loadbalancers',
                'nodebalancer',
                'promotion',
                'region',
                'ticket',
                'volume'
            ]),
            url: z.union([
                z.string(),
                z.null()
            ])
        }),
        z.null()
    ]),
    label: z.string(),
    message: z.string(),
    severity: z.enum([
        'minor',
        'major',
        'critical'
    ]),
    type: z.enum([
        'migration_scheduled',
        'migration_imminent',
        'migration_pending',
        'reboot_scheduled',
        'outage',
        'payment_due',
        'ticket_important',
        'ticket_abuse',
        'notice',
        'maintenance',
        'maintenance_scheduled',
        'promotion',
        'security_reboot_maintenance_scheduled',
        'tax_id_verifying'
    ]),
    until: z.union([
        z.iso.datetime(),
        z.null()
    ]),
    when: z.union([
        z.iso.datetime(),
        z.null()
    ])
});

/**
 * A third-party application registered to Linode that users may log into with their Linode account through our authentication server at [login.linode.com](https://login.linode.com).  Using an OAuth Client, a third-party developer may be given access to some, or all, of a User's account for the purposes of their application.
 */
export const oauthClientSchema = z.object({
    id: z.string().readonly(),
    label: z.string().min(1).max(512),
    public: z.boolean().default(false),
    redirect_uri: z.string(),
    secret: z.string().readonly(),
    status: z.enum([
        'active',
        'disabled',
        'suspended'
    ]),
    thumbnail_url: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

/**
 * __Read-only__ The current [page](https://techdocs.akamai.com/linode-api/reference/pagination).
 */
export const pageSchema = z.int().readonly();

/**
 * __Read-only__ The total number of [pages](https://techdocs.akamai.com/linode-api/reference/pagination).
 */
export const pagesSchema = z.int().readonly();

/**
 * An envelope for paginated response. When accessing a collection through a GET endpoint, the results are wrapped in this envelope which includes metadata about those results. Results are presented within a `data` array. See [Pagination](https://techdocs.akamai.com/linode-api/reference/pagination) for more information.
 */
export const paginationEnvelopeSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

/**
 * Payment object response.
 */
export const paymentSchema = z.object({
    date: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    usd: z.int().readonly()
});

/**
 * Payment Method Response Object.
 */
export const paymentMethodSchema = z.object({
    created: z.iso.datetime().readonly(),
    data: z.union([
        z.object({
            card_type: z.string().readonly(),
            expiry: z.string().readonly(),
            last_four: z.string().readonly()
        }),
        z.object({
            card_type: z.string().readonly(),
            expiry: z.string().readonly(),
            last_four: z.string().readonly()
        }),
        z.object({
            email: z.string().readonly(),
            paypal_id: z.string().readonly()
        })
    ]),
    id: z.int(),
    is_default: z.boolean(),
    type: z.enum([
        'credit_card',
        'google_pay',
        'paypal'
    ])
});

/**
 * An object representing the staging of a Payment via PayPal.
 */
export const paypalSchema = z.object({
    cancel_url: z.string(),
    redirect_url: z.string(),
    usd: z.string()
});

/**
 * Paypal
 *
 * PayPal information.
 */
export const paypalDataSchema = z.object({
    email: z.string().readonly(),
    paypal_id: z.string().readonly()
});

/**
 * An object representing an execution of Payment to PayPal to capture the funds and credit your Linode Account.
 */
export const paypalExecuteSchema = z.object({
    payer_id: z.string(),
    payment_id: z.string()
});

/**
 * __Read-only__ Promotions generally offer a set amount of credit that can be used toward your Linode services, and the promotion expires after a specified date. As well, a monthly cap on the promotional offer is set.
 *
 * Simply put, a promotion offers a certain amount of credit  month, until either the expiration date is passed, or until the total promotional credit is used, whichever comes first.
 */
export const promotionSchema = z.object({
    credit_monthly_cap: z.string(),
    credit_remaining: z.string(),
    description: z.string(),
    expire_dt: z.string(),
    image_url: z.string(),
    service_type: z.enum([
        'all',
        'backup',
        'blockstorage',
        'db_mysql',
        'ip_v4',
        'linode',
        'linode_disk',
        'linode_memory',
        'longview',
        'managed',
        'nodebalancer',
        'objectstorage',
        'placement_group',
        'transfer_tx'
    ]),
    summary: z.string(),
    this_month_credit_remaining: z.string()
}).readonly();

/**
 * A collection of the services to include in this transfer request, separated by type.
 */
export const propertiesEntitiesSchema = z.object({
    linodes: z.array(z.int())
});

/**
 * The token generated manually for a child account so its proxy user can access the API and CLI without going through an OAuth login.
 */
export const proxyUserTokenSchema = z.object({
    created: z.iso.datetime().readonly(),
    expiry: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    label: z.string().min(1).max(100),
    scopes: z.string().readonly(),
    token: z.string().readonly()
});

/**
 * __Read-only__ The total number of results.
 */
export const resultsSchema = z.int().readonly();

/**
 * An object representing a Service Transfer.
 */
export const serviceTransferSchema = z.object({
    created: z.iso.datetime(),
    entities: z.object({
        linodes: z.array(z.int())
    }),
    expiry: z.iso.datetime(),
    is_sender: z.boolean(),
    status: z.enum([
        'accepted',
        'canceled',
        'completed',
        'failed',
        'pending',
        'stale'
    ]),
    token: z.uuid(),
    updated: z.iso.datetime()
});

/**
 * __Filterable__, __Read-only__ The start date-time of the Beta Program.
 */
export const startedSchema = z.iso.datetime().readonly();

/**
 * An object representing your network utilization for the current month, in Gigabytes.
 *
 * Certain Regions have separate utilization quotas and rates. For Region-specific network utilization data, see `region_transfers`.
 */
export const transferSchema = z.object({
    billable: z.int().readonly(),
    quota: z.int().readonly(),
    region_transfers: z.array(z.object({
        billable: z.int().readonly(),
        id: z.string(),
        quota: z.int().readonly(),
        used: z.int().readonly()
    })),
    used: z.int().readonly()
});

/**
 * A user on your account. Unrestricted users can log in and access information about your account, while restricted users may only access entities or perform actions they've been granted access to.
 */
export const userSchema = z.object({
    email: z.email(),
    last_login: z.union([
        z.object({
            login_datetime: z.iso.datetime().readonly(),
            status: z.enum(['successful', 'failed'])
        }).readonly(),
        z.null()
    ]).readonly(),
    password_created: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    restricted: z.boolean(),
    ssh_keys: z.array(z.string()).readonly(),
    tfa_enabled: z.boolean().readonly(),
    username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/),
    verified_phone_number: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

/**
 * The type of user on an account. Mostly applies to the use of the parent and child accounts for Akamai partners functionality.
 */
export const userTypeSchema = z.object({
    user_type: z.enum([
        'parent',
        'child',
        'proxy',
        'default'
    ])
});

/**
 * An object for describing a single warning associated with a response.
 */
export const warningObjectSchema = z.object({
    details: z.string(),
    title: z.string()
});

/**
 * Specifies the `X-Filter` header JSON object's filtering and sort criteria.
 */
export const xFilterSchema = z.union([
    z.record(z.string(), z.unknown()),
    z.object({
        '+and': z.array(z.record(z.string(), z.unknown())),
        '+contains': z.string(),
        '+gt': z.number(),
        '+gte': z.number(),
        '+lt': z.number(),
        '+lte': z.number(),
        '+neq': z.string(),
        '+or': z.array(z.record(z.string(), z.unknown())),
        '+order': z.enum(['asc', 'desc']),
        '+order_by': z.string()
    })
]);

/**
 * Simple filter
 *
 * Specify the name of the data field and the accompanying value.
 */
export const xFilterCriteriaSchema = z.record(z.string(), z.unknown());

/**
 * Account object.
 */
export const accountWritableSchema = z.object({
    address_1: z.string().max(64),
    address_2: z.string().max(64),
    city: z.string().max(24),
    company: z.string().max(128),
    country: z.string(),
    email: z.string().max(128),
    first_name: z.string().max(50),
    last_name: z.string().max(50),
    phone: z.string().max(32),
    state: z.string().max(24),
    tax_id: z.string().max(25),
    zip: z.string()
});

/**
 * Account Settings object.
 */
export const accountSettingsWritableSchema = z.object({
    backups_enabled: z.boolean(),
    interfaces_for_new_linodes: z.enum([
        'legacy_config_only',
        'legacy_config_default_but_linode_allowed',
        'linode_default_but_legacy_config_allowed',
        'linode_only'
    ]),
    maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
    network_helper: z.boolean()
});

export const addedGetAccountLogins200WritableSchema = z.object({
    data: z.array(z.record(z.string(), z.never()))
});

export const addedGetAvailability200WritableSchema = z.object({
    data: z.array(z.object({}))
}).and(z.object({}));

export const addedGetChildAccounts200WritableSchema = z.object({
    data: z.array(z.object({
        address_1: z.string().max(64),
        address_2: z.string().max(64),
        city: z.string().max(24),
        company: z.string().max(128),
        country: z.string(),
        email: z.string().max(128),
        first_name: z.string().max(50),
        last_name: z.string().max(50),
        phone: z.string().max(32),
        state: z.string().max(24),
        tax_id: z.string().max(25),
        zip: z.string()
    }))
});

export const addedGetClients200WritableSchema = z.object({
    data: z.array(z.object({
        label: z.string().min(1).max(512),
        public: z.boolean().default(false),
        redirect_uri: z.string()
    }))
});

export const addedGetEnrolledBetaPrograms200WritableSchema = z.object({}).and(z.object({
    data: z.array(z.object({
        id: z.string()
    }))
}));

export const addedGetEntityTransfers200WritableSchema = z.object({}).and(z.object({
    data: z.optional(z.array(z.object({
        created: z.iso.datetime(),
        entities: z.object({
            linodes: z.array(z.int())
        }),
        expiry: z.iso.datetime(),
        is_sender: z.boolean(),
        status: z.enum([
            'accepted',
            'canceled',
            'completed',
            'failed',
            'pending',
            'stale'
        ]),
        token: z.uuid(),
        updated: z.iso.datetime()
    })))
}));

export const addedGetInvoiceItems200WritableSchema = z.object({
    data: z.array(z.record(z.string(), z.never()))
});

export const addedGetInvoices200WritableSchema = z.object({
    data: z.array(z.record(z.string(), z.never()))
});

export const addedGetNotifications200WritableSchema = z.object({
    data: z.array(z.object({
        body: z.union([
            z.string(),
            z.null()
        ]),
        entity: z.union([
            z.object({
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                label: z.union([
                    z.string(),
                    z.null()
                ]),
                type: z.enum([
                    'account',
                    'entity_transfer',
                    'linode',
                    'loadbalancers',
                    'nodebalancer',
                    'promotion',
                    'region',
                    'ticket',
                    'volume'
                ]),
                url: z.union([
                    z.string(),
                    z.null()
                ])
            }),
            z.null()
        ]),
        label: z.string(),
        message: z.string(),
        severity: z.enum([
            'minor',
            'major',
            'critical'
        ]),
        type: z.enum([
            'migration_scheduled',
            'migration_imminent',
            'migration_pending',
            'reboot_scheduled',
            'outage',
            'payment_due',
            'ticket_important',
            'ticket_abuse',
            'notice',
            'maintenance',
            'maintenance_scheduled',
            'promotion',
            'security_reboot_maintenance_scheduled',
            'tax_id_verifying'
        ]),
        until: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        when: z.union([
            z.iso.datetime(),
            z.null()
        ])
    }))
});

export const addedGetPaymentMethods200WritableSchema = z.object({
    data: z.array(z.object({
        data: z.union([
            z.record(z.string(), z.never()),
            z.record(z.string(), z.never()),
            z.record(z.string(), z.never())
        ]),
        id: z.int(),
        is_default: z.boolean(),
        type: z.enum([
            'credit_card',
            'google_pay',
            'paypal'
        ])
    }))
});

export const addedGetPayments200WritableSchema = z.object({
    data: z.array(z.record(z.string(), z.never()))
});

export const addedGetServiceTransfers200WritableSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime(),
        entities: z.object({
            linodes: z.array(z.int())
        }),
        expiry: z.iso.datetime(),
        is_sender: z.boolean(),
        status: z.enum([
            'accepted',
            'canceled',
            'completed',
            'failed',
            'pending',
            'stale'
        ]),
        token: z.uuid(),
        updated: z.iso.datetime()
    }))
});

export const addedGetUser200WritableSchema = z.object({
    email: z.email(),
    restricted: z.boolean(),
    username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/)
}).and(z.object({}));

export const addedGetUsers200WritableSchema = z.object({
    data: z.array(z.object({
        email: z.email(),
        restricted: z.boolean(),
        username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/)
    }).and(z.object({})))
});

/**
 * A third-party application registered to Linode that users may log into with their Linode account through our authentication server at [login.linode.com](https://login.linode.com).  Using an OAuth Client, a third-party developer may be given access to some, or all, of a User's account for the purposes of their application.
 */
export const addedPostClientWritableSchema = z.object({
    label: z.string().min(1).max(512),
    public: z.boolean().default(false),
    redirect_uri: z.string()
});

export const addedPostPayPalPayment200WritableSchema = z.object({
    payment_id: z.string()
});

/**
 * A user on your account. Unrestricted users can log in and access information about your account, while restricted users may only access entities or perform actions they've been granted access to.
 */
export const addedPostUserWritableSchema = z.object({
    email: z.email(),
    restricted: z.boolean(),
    username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/)
});

export const addedPutUser200WritableSchema = z.object({
    email: z.email(),
    restricted: z.boolean(),
    username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/)
}).and(z.object({}));

/**
 * An object representing an enrolled Beta Program for the Account.
 */
export const betaProgramEnrolledWritableSchema = z.object({
    id: z.string()
});

/**
 * Child account object.
 */
export const childAccountWritableSchema = z.object({
    address_1: z.string().max(64),
    address_2: z.string().max(64),
    city: z.string().max(24),
    company: z.string().max(128),
    country: z.string(),
    email: z.string().max(128),
    first_name: z.string().max(50),
    last_name: z.string().max(50),
    phone: z.string().max(32),
    state: z.string().max(24),
    tax_id: z.string().max(25),
    zip: z.string()
});

/**
 * A specific event object. An event is an action taken against an entity related to your account. For example, if you boot a Linode, the system creates an event. The events returned depend on your user grants.
 */
export const eventWritableSchema = z.object({
    message: z.union([
        z.string(),
        z.null()
    ])
});

export const getMaintenance200WritableSchema = z.object({
    data: z.array(z.object({
        complete_time: z.iso.datetime(),
        description: z.enum(['Scheduled Maintenance', 'Emergency Maintenance']),
        entity: z.object({
            id: z.number(),
            label: z.string(),
            type: z.string(),
            url: z.string()
        }),
        maintenance_policy_set: z.string(),
        not_before: z.iso.datetime(),
        reason: z.string(),
        source: z.enum(['platform', 'user']),
        start_time: z.iso.datetime(),
        status: z.enum([
            'pending',
            'scheduled',
            'started',
            'in-progress',
            'completed',
            'canceled'
        ]),
        type: z.enum([
            'reboot',
            'cold_migration',
            'live_migration',
            'migrate',
            'power_off_on'
        ]),
        when: z.iso.datetime()
    }))
});

/**
 * Represents the level of access a restricted user has to a specific resource on the account.
 */
export const grantWritableSchema = z.object({
    id: z.int(),
    permissions: z.enum(['read_only', 'read_write'])
});

export const grantsResponseWritableSchema = z.object({
    database: z.array(z.object({
        id: z.int(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    domain: z.array(z.object({
        id: z.int(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    firewall: z.array(z.object({
        id: z.int(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    global: z.object({
        account_access: z.enum(['read_only', 'read_write']),
        add_databases: z.boolean(),
        add_domains: z.boolean(),
        add_firewalls: z.boolean(),
        add_images: z.boolean(),
        add_linodes: z.boolean(),
        add_longview: z.boolean(),
        add_nodebalancers: z.boolean(),
        add_stackscripts: z.boolean(),
        add_volumes: z.boolean(),
        add_vpcs: z.boolean(),
        cancel_account: z.boolean(),
        child_account_access: z.union([
            z.boolean(),
            z.null()
        ]),
        longview_subscription: z.boolean()
    }),
    image: z.array(z.object({
        id: z.int(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    linode: z.array(z.object({
        id: z.int(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    longview: z.array(z.object({
        id: z.int(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    nodebalancer: z.array(z.object({
        id: z.int(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    stackscript: z.array(z.object({
        id: z.int(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    volume: z.array(z.object({
        id: z.int(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    vpc: z.array(z.object({
        id: z.int(),
        permissions: z.enum(['read_only', 'read_write'])
    }))
});

/**
 * Account Invoice object.
 */
export const invoiceWritableSchema = z.record(z.string(), z.never());

/**
 * A third-party application registered to Linode that users may log into with their Linode account through our authentication server at [login.linode.com](https://login.linode.com).  Using an OAuth Client, a third-party developer may be given access to some, or all, of a User's account for the purposes of their application.
 */
export const oauthClientWritableSchema = z.object({
    label: z.string().min(1).max(512),
    public: z.boolean().default(false),
    redirect_uri: z.string()
});

/**
 * Payment Method Response Object.
 */
export const paymentMethodWritableSchema = z.object({
    data: z.union([
        z.record(z.string(), z.never()),
        z.record(z.string(), z.never()),
        z.record(z.string(), z.never())
    ]),
    id: z.int(),
    is_default: z.boolean(),
    type: z.enum([
        'credit_card',
        'google_pay',
        'paypal'
    ])
});

/**
 * The token generated manually for a child account so its proxy user can access the API and CLI without going through an OAuth login.
 */
export const proxyUserTokenWritableSchema = z.object({
    label: z.string().min(1).max(100)
});

/**
 * An object representing your network utilization for the current month, in Gigabytes.
 *
 * Certain Regions have separate utilization quotas and rates. For Region-specific network utilization data, see `region_transfers`.
 */
export const transferWritableSchema = z.object({
    region_transfers: z.array(z.object({
        id: z.string()
    }))
});

/**
 * A user on your account. Unrestricted users can log in and access information about your account, while restricted users may only access entities or perform actions they've been granted access to.
 */
export const userWritableSchema = z.object({
    email: z.email(),
    restricted: z.boolean(),
    username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/)
});

/**
 * Call either the `v4` URL, or `v4beta` for operations still in Beta.
 */
export const apiVersionPathSchema = z.enum(['v4', 'v4beta']);

/**
 * The ID of the Beta Program.
 */
export const betaIdSchema = z.string();

/**
 * The OAuth Client ID to look up.
 */
export const clientIdPathSchema = z.string();

/**
 * The OAuth Client ID to look up.
 */
export const clientIdPathEcf807FbSchema = z.string();

/**
 * The child account to look up. You can run the [List child accounts](https://techdocs.akamai.com/linode-api/reference/get-child-accounts) operation to find the applicable account and store its `euuid` as your `euuId`.
 */
export const eeuidSchema = z.string();

/**
 * The ID of the Event to designate as seen.
 */
export const eventIdPath214Cd042Schema = z.int();

/**
 * The ID of the Event.
 */
export const eventIdPath39255FcfSchema = z.int();

/**
 * The ID of the Invoice.
 */
export const invoiceIdPathSchema = z.int();

/**
 * The ID of the login object to access.
 */
export const loginIdPathSchema = z.int();

/**
 * The page of a collection to return.
 */
export const pageOffsetSchema = z.int().gte(1).default(1);

/**
 * The number of items to return per page.
 */
export const pageSizeSchema = z.int().gte(25).lte(500).default(100);

/**
 * The ID of the Payment to look up.
 */
export const paymentIdPathSchema = z.int();

/**
 * The ID of the Payment Method to look up.
 */
export const paymentMethodIdPath6078Bc7bSchema = z.int();

/**
 * The ID of the Payment Method to make default.
 */
export const paymentMethodIdPathFb39A844Schema = z.int();

/**
 * The abbreviated value ("slug") for the applicable data center. Run the [List regions](https://techdocs.akamai.com/linode-api/reference/get-regions) operation to view the slug for each data center.
 */
export const regionIdPathSchema = z.string();

/**
 * The UUID of the Service Transfer.
 */
export const tokenPathF857F5A2Schema = z.uuid();

/**
 * The UUID of the Entity Transfer.
 */
export const tokenPathFaf66B58Schema = z.uuid();

/**
 * The username to look up.
 */
export const usernamePathSchema = z.string();

/**
 * Specifies the `X-Filter` header JSON object's filtering and sort criteria.
 */
export const xFilterHeaderSchema = z.union([
    z.record(z.string(), z.unknown()),
    z.object({
        '+and': z.array(z.record(z.string(), z.unknown())),
        '+contains': z.string(),
        '+gt': z.number(),
        '+gte': z.number(),
        '+lt': z.number(),
        '+lte': z.number(),
        '+neq': z.string(),
        '+or': z.array(z.record(z.string(), z.unknown())),
        '+order': z.enum(['asc', 'desc']),
        '+order_by': z.string()
    })
]);

export const getAccountRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Account object.
 */
export const getAccountResponseSchema = z.object({
    active_promotions: z.array(z.object({
        credit_monthly_cap: z.string(),
        credit_remaining: z.string(),
        description: z.string(),
        expire_dt: z.string(),
        image_url: z.string(),
        service_type: z.enum([
            'all',
            'backup',
            'blockstorage',
            'db_mysql',
            'ip_v4',
            'linode',
            'linode_disk',
            'linode_memory',
            'longview',
            'managed',
            'nodebalancer',
            'objectstorage',
            'placement_group',
            'transfer_tx'
        ]),
        summary: z.string(),
        this_month_credit_remaining: z.string()
    }).readonly()).readonly(),
    active_since: z.iso.datetime().readonly(),
    address_1: z.string().max(64),
    address_2: z.string().max(64),
    balance: z.number().readonly(),
    balance_uninvoiced: z.number().readonly(),
    billing_source: z.enum(['akamai', 'linode']),
    capabilities: z.array(z.string()).readonly(),
    city: z.string().max(24),
    company: z.string().max(128),
    country: z.string(),
    credit_card: z.object({
        expiry: z.string(),
        last_four: z.string()
    }).readonly(),
    email: z.string().max(128),
    euuid: z.uuid().readonly(),
    first_name: z.string().max(50),
    last_name: z.string().max(50),
    phone: z.string().max(32),
    state: z.string().max(24),
    tax_id: z.string().max(25),
    zip: z.string()
});

export const putAccountRequestSchema = z.object({
    body: z.object({
        active_promotions: z.array(z.object({
            credit_monthly_cap: z.string(),
            credit_remaining: z.string(),
            description: z.string(),
            expire_dt: z.string(),
            image_url: z.string(),
            service_type: z.enum([
                'all',
                'backup',
                'blockstorage',
                'db_mysql',
                'ip_v4',
                'linode',
                'linode_disk',
                'linode_memory',
                'longview',
                'managed',
                'nodebalancer',
                'objectstorage',
                'placement_group',
                'transfer_tx'
            ]),
            summary: z.string(),
            this_month_credit_remaining: z.string()
        }).readonly()).readonly(),
        active_since: z.iso.datetime().readonly(),
        address_1: z.string().max(64),
        address_2: z.string().max(64),
        balance: z.number().readonly(),
        balance_uninvoiced: z.number().readonly(),
        billing_source: z.enum(['akamai', 'linode']),
        capabilities: z.array(z.string()).readonly(),
        city: z.string().max(24),
        company: z.string().max(128),
        country: z.string(),
        credit_card: z.object({
            expiry: z.string(),
            last_four: z.string()
        }).readonly(),
        email: z.string().max(128),
        euuid: z.uuid().readonly(),
        first_name: z.string().max(50),
        last_name: z.string().max(50),
        phone: z.string().max(32),
        state: z.string().max(24),
        tax_id: z.string().max(25),
        zip: z.string()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Account object.
 */
export const putAccountResponseSchema = z.object({
    active_promotions: z.array(z.object({
        credit_monthly_cap: z.string(),
        credit_remaining: z.string(),
        description: z.string(),
        expire_dt: z.string(),
        image_url: z.string(),
        service_type: z.enum([
            'all',
            'backup',
            'blockstorage',
            'db_mysql',
            'ip_v4',
            'linode',
            'linode_disk',
            'linode_memory',
            'longview',
            'managed',
            'nodebalancer',
            'objectstorage',
            'placement_group',
            'transfer_tx'
        ]),
        summary: z.string(),
        this_month_credit_remaining: z.string()
    }).readonly()).readonly(),
    active_since: z.iso.datetime().readonly(),
    address_1: z.string().max(64),
    address_2: z.string().max(64),
    balance: z.number().readonly(),
    balance_uninvoiced: z.number().readonly(),
    billing_source: z.enum(['akamai', 'linode']),
    capabilities: z.array(z.string()).readonly(),
    city: z.string().max(24),
    company: z.string().max(128),
    country: z.string(),
    credit_card: z.object({
        expiry: z.string(),
        last_four: z.string()
    }).readonly(),
    email: z.string().max(128),
    euuid: z.uuid().readonly(),
    first_name: z.string().max(50),
    last_name: z.string().max(50),
    phone: z.string().max(32),
    state: z.string().max(24),
    tax_id: z.string().max(25),
    zip: z.string()
});

export const getAccountAgreementsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Acknowledgment status for agreements on your account. When acknowledging any agreements, set them to `true` and omit any remainders.
 */
export const getAccountAgreementsResponseSchema = z.object({
    billing_agreement: z.boolean(),
    eu_model: z.boolean(),
    master_service_agreement: z.boolean(),
    privacy_policy: z.boolean()
});

export const postAccountAgreementsRequestSchema = z.object({
    body: z.object({
        billing_agreement: z.boolean(),
        eu_model: z.boolean(),
        master_service_agreement: z.boolean(),
        privacy_policy: z.boolean()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postAccountAgreementsResponseSchema = z.record(z.string(), z.unknown());

export const getAvailabilityRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * List of regions and the services available in each.
 */
export const getAvailabilityResponseSchema = z.object({
    data: z.array(z.object({
        available: z.array(z.string()).readonly(),
        region: z.string().readonly(),
        unavailable: z.array(z.string()).readonly()
    }))
}).and(z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}));

export const getAccountAvailabilityRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        regionId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Account Service Availability object.
 */
export const getAccountAvailabilityResponseSchema = z.object({
    available: z.array(z.string()).readonly(),
    region: z.string().readonly(),
    unavailable: z.array(z.string()).readonly()
});

export const getEnrolledBetaProgramsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of all enrolled Beta Program objects for the Account.
 */
export const getEnrolledBetaProgramsResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.array(z.object({
        description: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        ended: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        enrolled: z.iso.datetime().readonly(),
        id: z.string(),
        label: z.string().readonly(),
        started: z.iso.datetime().readonly()
    }))
}));

export const postBetaProgramRequestSchema = z.object({
    body: z.object({
        id: z.string()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postBetaProgramResponseSchema = z.record(z.string(), z.unknown());

export const getEnrolledBetaProgramRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        betaId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * An object representing an enrolled Beta Program for the Account.
 */
export const getEnrolledBetaProgramResponseSchema = z.object({
    description: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    ended: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    enrolled: z.iso.datetime().readonly(),
    id: z.string(),
    label: z.string().readonly(),
    started: z.iso.datetime().readonly()
});

export const postCancelAccountRequestSchema = z.object({
    body: z.object({
        comments: z.string()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Account canceled.
 */
export const postCancelAccountResponseSchema = z.object({
    survey_link: z.string()
});

export const getChildAccountsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns child-level accounts.
 */
export const getChildAccountsResponseSchema = z.object({
    data: z.array(z.object({
        active_since: z.iso.datetime().readonly(),
        address_1: z.string().max(64),
        address_2: z.string().max(64),
        balance: z.number().readonly(),
        balance_uninvoiced: z.number().readonly(),
        billing_source: z.enum(['external']),
        capabilities: z.array(z.string()).readonly(),
        city: z.string().max(24),
        company: z.string().max(128),
        country: z.string(),
        credit_card: z.object({
            expiry: z.string(),
            last_four: z.string()
        }).readonly(),
        email: z.string().max(128),
        euuid: z.uuid().readonly(),
        first_name: z.string().max(50),
        last_name: z.string().max(50),
        phone: z.string().max(32),
        state: z.string().max(24),
        tax_id: z.string().max(25),
        zip: z.string()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getChildAccountRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        euuId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Child account object.
 */
export const getChildAccountResponseSchema = z.object({
    active_since: z.iso.datetime().readonly(),
    address_1: z.string().max(64),
    address_2: z.string().max(64),
    balance: z.number().readonly(),
    balance_uninvoiced: z.number().readonly(),
    billing_source: z.enum(['external']),
    capabilities: z.array(z.string()).readonly(),
    city: z.string().max(24),
    company: z.string().max(128),
    country: z.string(),
    credit_card: z.object({
        expiry: z.string(),
        last_four: z.string()
    }).readonly(),
    email: z.string().max(128),
    euuid: z.uuid().readonly(),
    first_name: z.string().max(50),
    last_name: z.string().max(50),
    phone: z.string().max(32),
    state: z.string().max(24),
    tax_id: z.string().max(25),
    zip: z.string()
});

export const postChildAccountTokenRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        euuId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The token generated manually for a child account so its proxy user can access the API and CLI without going through an OAuth login.
 */
export const postChildAccountTokenResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    expiry: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    label: z.string().min(1).max(100),
    scopes: z.string().readonly(),
    token: z.string().readonly()
});

export const postCreditCardRequestSchema = z.object({
    body: z.object({
        card_number: z.string().min(14).max(24),
        cvv: z.string().min(3).max(4),
        expiry_month: z.int().gte(1).lte(12),
        expiry_year: z.int()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postCreditCardResponseSchema = z.record(z.string(), z.unknown());

export const getEntityTransfersRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of Entity Transfer objects containing the details of all transfers that have been created and accepted by this account.
 */
export const getEntityTransfersResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.optional(z.array(z.object({
        created: z.iso.datetime(),
        entities: z.object({
            linodes: z.array(z.int())
        }),
        expiry: z.iso.datetime(),
        is_sender: z.boolean(),
        status: z.enum([
            'accepted',
            'canceled',
            'completed',
            'failed',
            'pending',
            'stale'
        ]),
        token: z.uuid(),
        updated: z.iso.datetime()
    })))
}));

export const postEntityTransferRequestSchema = z.object({
    body: z.optional(z.object({
        entities: z.object({
            linodes: z.array(z.int())
        })
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * An object representing an Entity Transfer.
 */
export const postEntityTransferResponseSchema = z.object({
    created: z.iso.datetime(),
    entities: z.object({
        linodes: z.array(z.int())
    }),
    expiry: z.iso.datetime(),
    is_sender: z.boolean(),
    status: z.enum([
        'accepted',
        'canceled',
        'completed',
        'failed',
        'pending',
        'stale'
    ]),
    token: z.uuid(),
    updated: z.iso.datetime()
});

export const deleteEntityTransferRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        token: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteEntityTransferResponseSchema = z.record(z.string(), z.unknown());

export const getEntityTransferRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        token: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * An object representing an Entity Transfer.
 */
export const getEntityTransferResponseSchema = z.object({
    created: z.iso.datetime(),
    entities: z.object({
        linodes: z.array(z.int())
    }),
    expiry: z.iso.datetime(),
    is_sender: z.boolean(),
    status: z.enum([
        'accepted',
        'canceled',
        'completed',
        'failed',
        'pending',
        'stale'
    ]),
    token: z.uuid(),
    updated: z.iso.datetime()
});

export const postAcceptEntityTransferRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        token: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postAcceptEntityTransferResponseSchema = z.record(z.string(), z.unknown());

export const getEventsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    })),
    headers: z.optional(z.object({
        'X-Filter': z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.object({
                '+and': z.array(z.record(z.string(), z.unknown())),
                '+contains': z.string(),
                '+gt': z.number(),
                '+gte': z.number(),
                '+lt': z.number(),
                '+lte': z.number(),
                '+neq': z.string(),
                '+or': z.array(z.record(z.string(), z.unknown())),
                '+order': z.enum(['asc', 'desc']),
                '+order_by': z.string()
            })
        ]))
    }))
});

/**
 * Returns a paginated list of Event objects from the last 90 days.
 */
export const getEventsResponseSchema = z.object({
    data: z.array(z.object({
        action: z.enum([
            'account_agreement_eu_model',
            'account_promo_apply',
            'account_update',
            'account_settings_update',
            'backups_enable',
            'backups_cancel',
            'backups_restore',
            'community_question_reply',
            'community_like',
            'community_mention',
            'credit_card_updated',
            'database_create',
            'database_delete',
            'database_update',
            'database_failed',
            'database_degraded',
            'database_create_failed',
            'database_update_failed',
            'database_backup_create',
            'database_backup_restore',
            'database_backup_delete',
            'database_credentials_reset',
            'database_low_disk_space',
            'database_scale',
            'database_resize',
            'database_resize_create',
            'database_migrate',
            'database_upgrade',
            'database_suspend',
            'database_resume',
            'disk_create',
            'disk_delete',
            'disk_update',
            'disk_duplicate',
            'disk_imagize',
            'disk_resize',
            'dns_record_create',
            'dns_record_delete',
            'dns_record_update',
            'dns_zone_create',
            'dns_zone_delete',
            'dns_zone_import',
            'dns_zone_update',
            'entity_transfer_accept',
            'entity_transfer_accept_recipient',
            'entity_transfer_cancel',
            'entity_transfer_create',
            'entity_transfer_fail',
            'entity_transfer_stale',
            'firewall_apply',
            'firewall_create',
            'firewall_delete',
            'firewall_disable',
            'firewall_enable',
            'firewall_update',
            'firewall_device_add',
            'firewall_device_remove',
            'firewall_rules_update',
            'host_reboot',
            'image_delete',
            'image_update',
            'image_upload',
            'interface_create',
            'interface_delete',
            'interface_update',
            'ipaddress_update',
            'ipv6pool_add',
            'ipv6pool_delete',
            'lassie_reboot',
            'lish_boot',
            'linode_addip',
            'linode_boot',
            'linode_clone',
            'linode_create',
            'linode_delete',
            'linode_update',
            'linode_deleteip',
            'linode_kvmify',
            'linode_migrate',
            'linode_migrate_datacenter',
            'linode_migrate_datacenter_create',
            'linode_mutate',
            'linode_mutate_create',
            'linode_poweroff_on',
            'linode_reboot',
            'linode_rebuild',
            'linode_resize',
            'linode_resize_create',
            'linode_resize_warm_create',
            'linode_shutdown',
            'linode_snapshot',
            'linode_config_create',
            'linode_config_delete',
            'linode_config_update',
            'lke_cluster_create',
            'lke_cluster_update',
            'lke_cluster_delete',
            'lke_cluster_recycle',
            'lke_cluster_regenerate',
            'lke_control_plane_acl_create',
            'lke_control_plane_acl_update',
            'lke_control_plane_acl_delete',
            'lke_node_create',
            'lke_node_delete',
            'lke_node_recycle',
            'lke_pool_create',
            'lke_pool_delete',
            'lke_pool_recycle',
            'lke_kubeconfig_regenerate',
            'lke_token_rotate',
            'longviewclient_create',
            'longviewclient_delete',
            'longviewclient_update',
            'managed_disabled',
            'managed_enabled',
            'managed_service_create',
            'managed_service_delete',
            'nodebalancer_create',
            'nodebalancer_delete',
            'nodebalancer_update',
            'nodebalancer_config_create',
            'nodebalancer_config_delete',
            'nodebalancer_config_update',
            'nodebalancer_node_create',
            'nodebalancer_node_delete',
            'nodebalancer_node_update',
            'oauth_client_create',
            'oauth_client_delete',
            'oauth_client_secret_reset',
            'oauth_client_update',
            'obj_access_key_create',
            'obj_access_key_delete',
            'obj_access_key_update',
            'password_reset',
            'payment_method_add',
            'payment_submitted',
            'placement_group_assign',
            'placement_group_became_compliant',
            'placement_group_became_non_compliant',
            'placement_group_create',
            'placement_group_delete',
            'placement_group_unassign',
            'placement_group_update',
            'profile_update',
            'stackscript_create',
            'stackscript_delete',
            'stackscript_update',
            'stackscript_publicize',
            'stackscript_revise',
            'subnet_create',
            'subnet_delete',
            'subnet_update',
            'tag_create',
            'tag_delete',
            'tag_update',
            'tax_id_valid',
            'tax_id_invalid',
            'tfa_disabled',
            'tfa_enabled',
            'ticket_attachment_upload',
            'ticket_create',
            'ticket_update',
            'token_create',
            'token_delete',
            'token_update',
            'user_create',
            'user_update',
            'user_delete',
            'user_ssh_key_add',
            'user_ssh_key_delete',
            'user_ssh_key_update',
            'vlan_attach',
            'vlan_detach',
            'volume_attach',
            'volume_clone',
            'volume_create',
            'volume_delete',
            'volume_update',
            'volume_detach',
            'volume_resize',
            'volume_migrate',
            'volume_migrate_scheduled',
            'vpc_create',
            'vpc_delete',
            'vpc_update'
        ]),
        created: z.iso.datetime(),
        details: z.object({
            complete_time: z.iso.datetime(),
            description: z.enum(['Scheduled Maintenance', 'Emergency Maintenance']),
            maintenance_policy_set: z.string(),
            not_before: z.iso.datetime(),
            source: z.enum(['platform', 'user']),
            start_time: z.iso.datetime()
        }),
        duration: z.number(),
        entity: z.object({
            id: z.int(),
            label: z.string(),
            type: z.enum([
                'account',
                'backups',
                'community',
                'disks',
                'domain',
                'entity_transfer',
                'firewall',
                'image',
                'ipaddress',
                'linode',
                'longview',
                'loadbalancer',
                'managed_service',
                'nodebalancer',
                'oauth_client',
                'profile',
                'stackscript',
                'tag',
                'ticket',
                'token',
                'user',
                'user_ssh_key',
                'volume'
            ]),
            url: z.string()
        }),
        id: z.int(),
        message: z.union([
            z.string(),
            z.null()
        ]),
        percent_complete: z.union([
            z.int(),
            z.null()
        ]),
        rate: z.union([
            z.string(),
            z.null()
        ]),
        secondary_entity: z.object({
            id: z.string(),
            label: z.string(),
            type: z.string(),
            url: z.string()
        }),
        seen: z.boolean(),
        status: z.enum([
            'completed',
            'failed',
            'finished',
            'in_progress',
            'notification',
            'scheduled',
            'started'
        ]),
        time_remaining: z.union([
            z.string(),
            z.null()
        ]),
        username: z.union([
            z.string(),
            z.null()
        ])
    })),
    page: z.int(),
    pages: z.int(),
    results: z.int()
});

export const getEventRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        eventId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A specific event object. An event is an action taken against an entity related to your account. For example, if you boot a Linode, the system creates an event. The events returned depend on your user grants.
 */
export const getEventResponseSchema = z.object({
    action: z.enum([
        'account_agreement_eu_model',
        'account_promo_apply',
        'account_update',
        'account_settings_update',
        'backups_enable',
        'backups_cancel',
        'backups_restore',
        'community_question_reply',
        'community_like',
        'community_mention',
        'credit_card_updated',
        'database_create',
        'database_delete',
        'database_update',
        'database_failed',
        'database_degraded',
        'database_create_failed',
        'database_update_failed',
        'database_backup_create',
        'database_backup_restore',
        'database_backup_delete',
        'database_credentials_reset',
        'database_low_disk_space',
        'database_scale',
        'database_resize',
        'database_resize_create',
        'database_migrate',
        'database_upgrade',
        'database_suspend',
        'database_resume',
        'disk_create',
        'disk_delete',
        'disk_update',
        'disk_duplicate',
        'disk_imagize',
        'disk_resize',
        'dns_record_create',
        'dns_record_delete',
        'dns_record_update',
        'dns_zone_create',
        'dns_zone_delete',
        'dns_zone_import',
        'dns_zone_update',
        'entity_transfer_accept',
        'entity_transfer_accept_recipient',
        'entity_transfer_cancel',
        'entity_transfer_create',
        'entity_transfer_fail',
        'entity_transfer_stale',
        'firewall_apply',
        'firewall_create',
        'firewall_delete',
        'firewall_disable',
        'firewall_enable',
        'firewall_update',
        'firewall_device_add',
        'firewall_device_remove',
        'firewall_rules_update',
        'host_reboot',
        'image_delete',
        'image_update',
        'image_upload',
        'interface_create',
        'interface_delete',
        'interface_update',
        'ipaddress_update',
        'ipv6pool_add',
        'ipv6pool_delete',
        'lassie_reboot',
        'lish_boot',
        'linode_addip',
        'linode_boot',
        'linode_clone',
        'linode_create',
        'linode_delete',
        'linode_update',
        'linode_deleteip',
        'linode_kvmify',
        'linode_migrate',
        'linode_migrate_datacenter',
        'linode_migrate_datacenter_create',
        'linode_mutate',
        'linode_mutate_create',
        'linode_poweroff_on',
        'linode_reboot',
        'linode_rebuild',
        'linode_resize',
        'linode_resize_create',
        'linode_resize_warm_create',
        'linode_shutdown',
        'linode_snapshot',
        'linode_config_create',
        'linode_config_delete',
        'linode_config_update',
        'lke_control_plane_acl_create',
        'lke_control_plane_acl_update',
        'lke_control_plane_acl_delete',
        'lke_cluster_create',
        'lke_cluster_update',
        'lke_cluster_delete',
        'lke_cluster_recycle',
        'lke_cluster_regenerate',
        'lke_node_create',
        'lke_node_delete',
        'lke_node_recycle',
        'lke_pool_create',
        'lke_pool_delete',
        'lke_pool_recycle',
        'lke_kubeconfig_regenerate',
        'lke_token_rotate',
        'longviewclient_create',
        'longviewclient_delete',
        'longviewclient_update',
        'managed_disabled',
        'managed_enabled',
        'managed_service_create',
        'managed_service_delete',
        'nodebalancer_create',
        'nodebalancer_delete',
        'nodebalancer_update',
        'nodebalancer_config_create',
        'nodebalancer_config_delete',
        'nodebalancer_config_update',
        'nodebalancer_node_create',
        'nodebalancer_node_delete',
        'nodebalancer_node_update',
        'oauth_client_create',
        'oauth_client_delete',
        'oauth_client_secret_reset',
        'oauth_client_update',
        'obj_access_key_create',
        'obj_access_key_delete',
        'obj_access_key_update',
        'password_reset',
        'payment_method_add',
        'payment_submitted',
        'placement_group_assign',
        'placement_group_became_compliant',
        'placement_group_became_non_compliant',
        'placement_group_create',
        'placement_group_delete',
        'placement_group_unassign',
        'placement_group_update',
        'profile_update',
        'stackscript_create',
        'stackscript_delete',
        'stackscript_update',
        'stackscript_publicize',
        'stackscript_revise',
        'subnet_create',
        'subnet_delete',
        'subnet_update',
        'tag_create',
        'tag_delete',
        'tag_update',
        'tax_id_valid',
        'tax_id_invalid',
        'tfa_disabled',
        'tfa_enabled',
        'ticket_attachment_upload',
        'ticket_create',
        'ticket_update',
        'token_create',
        'token_delete',
        'token_update',
        'user_create',
        'user_update',
        'user_delete',
        'user_ssh_key_add',
        'user_ssh_key_delete',
        'user_ssh_key_update',
        'vlan_attach',
        'vlan_detach',
        'volume_attach',
        'volume_clone',
        'volume_create',
        'volume_delete',
        'volume_update',
        'volume_detach',
        'volume_resize',
        'volume_migrate',
        'volume_migrate_scheduled',
        'vpc_create',
        'vpc_delete',
        'vpc_update'
    ]),
    created: z.iso.datetime().readonly(),
    details: z.object({
        complete_time: z.iso.datetime(),
        description: z.enum(['Scheduled Maintenance', 'Emergency Maintenance']),
        maintenance_policy_set: z.string(),
        not_before: z.iso.datetime(),
        source: z.enum(['platform', 'user']),
        start_time: z.iso.datetime()
    }).readonly(),
    duration: z.number().readonly(),
    entity: z.object({
        id: z.int(),
        label: z.string(),
        type: z.enum([
            'account',
            'backups',
            'community',
            'disks',
            'domain',
            'entity_transfer',
            'firewall',
            'image',
            'ipaddress',
            'linode',
            'longview',
            'loadbalancer',
            'managed_service',
            'nodebalancer',
            'oauth_client',
            'profile',
            'stackscript',
            'tag',
            'ticket',
            'token',
            'user',
            'user_ssh_key',
            'volume'
        ]),
        url: z.string()
    }).readonly(),
    id: z.int().readonly(),
    message: z.union([
        z.string(),
        z.null()
    ]),
    percent_complete: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    rate: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    secondary_entity: z.object({
        id: z.string(),
        label: z.string(),
        type: z.string().readonly(),
        url: z.string()
    }).readonly(),
    seen: z.boolean().readonly(),
    status: z.enum([
        'failed',
        'finished',
        'notification',
        'scheduled',
        'started'
    ]),
    time_remaining: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    username: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const postEventSeenRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        eventId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postEventSeenResponseSchema = z.record(z.string(), z.unknown());

export const getInvoicesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    })),
    headers: z.optional(z.object({
        'X-Filter': z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.object({
                '+and': z.array(z.record(z.string(), z.unknown())),
                '+contains': z.string(),
                '+gt': z.number(),
                '+gte': z.number(),
                '+lt': z.number(),
                '+lte': z.number(),
                '+neq': z.string(),
                '+or': z.array(z.record(z.string(), z.unknown())),
                '+order': z.enum(['asc', 'desc']),
                '+order_by': z.string()
            })
        ]))
    }))
});

/**
 * Returns a paginated list of Invoice objects.
 */
export const getInvoicesResponseSchema = z.object({
    data: z.array(z.object({
        billing_source: z.enum(['akamai', 'linode']),
        date: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        label: z.string().readonly(),
        subtotal: z.number().readonly(),
        tax: z.number().readonly(),
        tax_summary: z.array(z.object({
            name: z.string(),
            tax: z.number()
        })).readonly(),
        total: z.number().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getInvoiceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        invoiceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Account Invoice object.
 */
export const getInvoiceResponseSchema = z.object({
    billing_source: z.enum(['akamai', 'linode']),
    date: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    label: z.string().readonly(),
    subtotal: z.number().readonly(),
    tax: z.number().readonly(),
    tax_summary: z.array(z.object({
        name: z.string(),
        tax: z.number()
    })).readonly(),
    total: z.number().readonly()
});

export const getInvoiceItemsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        invoiceId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of InvoiceItem objects.
 */
export const getInvoiceItemsResponseSchema = z.object({
    data: z.array(z.object({
        amount: z.number().readonly(),
        from: z.iso.datetime().readonly(),
        label: z.string().readonly(),
        quantity: z.int().readonly(),
        region: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        tax: z.number().readonly(),
        to: z.iso.datetime().readonly(),
        total: z.number().readonly(),
        type: z.enum(['hourly', 'misc']),
        unit_price: z.string().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getAccountLoginsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A collection of successful logins for all users on the account during the last 90 days.
 */
export const getAccountLoginsResponseSchema = z.object({
    data: z.array(z.object({
        datetime: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        ip: z.string().readonly(),
        restricted: z.boolean().readonly(),
        status: z.enum(['successful', 'failed']),
        username: z.string().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getAccountLoginRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        loginId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * An object representing a previous successful login for a User.
 */
export const getAccountLoginResponseSchema = z.object({
    datetime: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    ip: z.string().readonly(),
    restricted: z.boolean().readonly(),
    status: z.enum(['successful', 'failed']),
    username: z.string().readonly()
});

export const getMaintenanceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of Maintenance objects.
 */
export const getMaintenanceResponseSchema = z.object({
    data: z.array(z.object({
        complete_time: z.iso.datetime(),
        description: z.enum(['Scheduled Maintenance', 'Emergency Maintenance']),
        entity: z.object({
            id: z.number(),
            label: z.string(),
            type: z.string(),
            url: z.string()
        }),
        maintenance_policy_set: z.string(),
        not_before: z.iso.datetime(),
        reason: z.string(),
        source: z.enum(['platform', 'user']),
        start_time: z.iso.datetime(),
        status: z.enum([
            'pending',
            'scheduled',
            'started',
            'in-progress',
            'completed',
            'canceled'
        ]),
        type: z.enum([
            'reboot',
            'cold_migration',
            'live_migration',
            'migrate',
            'power_off_on'
        ]),
        when: z.iso.datetime()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getNotificationsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of notification objects.
 */
export const getNotificationsResponseSchema = z.object({
    data: z.array(z.object({
        body: z.union([
            z.string(),
            z.null()
        ]),
        entity: z.union([
            z.object({
                id: z.union([
                    z.int(),
                    z.null()
                ]),
                label: z.union([
                    z.string(),
                    z.null()
                ]),
                type: z.enum([
                    'account',
                    'entity_transfer',
                    'linode',
                    'loadbalancers',
                    'nodebalancer',
                    'promotion',
                    'region',
                    'ticket',
                    'volume'
                ]),
                url: z.union([
                    z.string(),
                    z.null()
                ])
            }),
            z.null()
        ]),
        label: z.string(),
        message: z.string(),
        severity: z.enum([
            'minor',
            'major',
            'critical'
        ]),
        type: z.enum([
            'migration_scheduled',
            'migration_imminent',
            'migration_pending',
            'reboot_scheduled',
            'outage',
            'payment_due',
            'ticket_important',
            'ticket_abuse',
            'notice',
            'maintenance',
            'maintenance_scheduled',
            'promotion',
            'security_reboot_maintenance_scheduled',
            'tax_id_verifying'
        ]),
        until: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        when: z.union([
            z.iso.datetime(),
            z.null()
        ])
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getClientsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of OAuth Clients.
 */
export const getClientsResponseSchema = z.object({
    data: z.array(z.object({
        id: z.string().readonly(),
        label: z.string().min(1).max(512),
        public: z.boolean().default(false),
        redirect_uri: z.string(),
        secret: z.string().readonly(),
        status: z.enum([
            'active',
            'disabled',
            'suspended'
        ]),
        thumbnail_url: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postClientRequestSchema = z.object({
    body: z.optional(z.object({
        id: z.string().readonly(),
        label: z.string().min(1).max(512),
        public: z.boolean().default(false),
        redirect_uri: z.string(),
        secret: z.string().readonly(),
        status: z.enum([
            'active',
            'disabled',
            'suspended'
        ]),
        thumbnail_url: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A third-party application registered to Linode that users may log into with their Linode account through our authentication server at [login.linode.com](https://login.linode.com).  Using an OAuth Client, a third-party developer may be given access to some, or all, of a User's account for the purposes of their application.
 */
export const postClientResponseSchema = z.object({
    id: z.string().readonly(),
    label: z.string().min(1).max(512),
    public: z.boolean().default(false),
    redirect_uri: z.string(),
    secret: z.string().readonly(),
    status: z.enum([
        'active',
        'disabled',
        'suspended'
    ]),
    thumbnail_url: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const deleteClientRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clientId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteClientResponseSchema = z.record(z.string(), z.unknown());

export const getClientRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clientId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A third-party application registered to Linode that users may log into with their Linode account through our authentication server at [login.linode.com](https://login.linode.com).  Using an OAuth Client, a third-party developer may be given access to some, or all, of a User's account for the purposes of their application.
 */
export const getClientResponseSchema = z.object({
    id: z.string().readonly(),
    label: z.string().min(1).max(512),
    public: z.boolean().default(false),
    redirect_uri: z.string(),
    secret: z.string().readonly(),
    status: z.enum([
        'active',
        'disabled',
        'suspended'
    ]),
    thumbnail_url: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const putClientRequestSchema = z.object({
    body: z.optional(z.object({
        id: z.string().readonly(),
        label: z.string().min(1).max(512),
        public: z.boolean().default(false),
        redirect_uri: z.string(),
        secret: z.string().readonly(),
        status: z.enum([
            'active',
            'disabled',
            'suspended'
        ]),
        thumbnail_url: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    })),
    path: z.object({
        clientId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A third-party application registered to Linode that users may log into with their Linode account through our authentication server at [login.linode.com](https://login.linode.com).  Using an OAuth Client, a third-party developer may be given access to some, or all, of a User's account for the purposes of their application.
 */
export const putClientResponseSchema = z.object({
    id: z.string().readonly(),
    label: z.string().min(1).max(512),
    public: z.boolean().default(false),
    redirect_uri: z.string(),
    secret: z.string().readonly(),
    status: z.enum([
        'active',
        'disabled',
        'suspended'
    ]),
    thumbnail_url: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const postResetClientSecretRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clientId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A third-party application registered to Linode that users may log into with their Linode account through our authentication server at [login.linode.com](https://login.linode.com).  Using an OAuth Client, a third-party developer may be given access to some, or all, of a User's account for the purposes of their application.
 */
export const postResetClientSecretResponseSchema = z.object({
    id: z.string().readonly(),
    label: z.string().min(1).max(512),
    public: z.boolean().default(false),
    redirect_uri: z.string(),
    secret: z.string().readonly(),
    status: z.enum([
        'active',
        'disabled',
        'suspended'
    ]),
    thumbnail_url: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const getClientThumbnailRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clientId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The client's thumbnail.
 */
export const getClientThumbnailResponseSchema = z.string();

export const putClientThumbnailRequestSchema = z.object({
    body: z.string(),
    path: z.object({
        clientId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const putClientThumbnailResponseSchema = z.record(z.string(), z.unknown());

export const getPaymentMethodsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of Payment Method objects.
 */
export const getPaymentMethodsResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        data: z.union([
            z.object({
                card_type: z.string().readonly(),
                expiry: z.string().readonly(),
                last_four: z.string().readonly()
            }),
            z.object({
                card_type: z.string().readonly(),
                expiry: z.string().readonly(),
                last_four: z.string().readonly()
            }),
            z.object({
                email: z.string().readonly(),
                paypal_id: z.string().readonly()
            })
        ]),
        id: z.int(),
        is_default: z.boolean(),
        type: z.enum([
            'credit_card',
            'google_pay',
            'paypal'
        ])
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postPaymentMethodRequestSchema = z.object({
    body: z.object({
        data: z.object({
            card_number: z.string().min(14).max(24),
            cvv: z.string().min(3).max(4),
            expiry_month: z.int().gte(1).lte(12),
            expiry_year: z.int()
        }),
        is_default: z.boolean(),
        type: z.enum(['credit_card'])
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postPaymentMethodResponseSchema = z.record(z.string(), z.unknown());

export const deletePaymentMethodRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        paymentMethodId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deletePaymentMethodResponseSchema = z.record(z.string(), z.unknown());

export const getPaymentMethodRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        paymentMethodId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Payment Method Response Object.
 */
export const getPaymentMethodResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    data: z.union([
        z.object({
            card_type: z.string().readonly(),
            expiry: z.string().readonly(),
            last_four: z.string().readonly()
        }),
        z.object({
            card_type: z.string().readonly(),
            expiry: z.string().readonly(),
            last_four: z.string().readonly()
        }),
        z.object({
            email: z.string().readonly(),
            paypal_id: z.string().readonly()
        })
    ]),
    id: z.int(),
    is_default: z.boolean(),
    type: z.enum([
        'credit_card',
        'google_pay',
        'paypal'
    ])
});

export const postMakePaymentMethodDefaultRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        paymentMethodId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postMakePaymentMethodDefaultResponseSchema = z.record(z.string(), z.unknown());

export const getPaymentsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    })),
    headers: z.optional(z.object({
        'X-Filter': z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.object({
                '+and': z.array(z.record(z.string(), z.unknown())),
                '+contains': z.string(),
                '+gt': z.number(),
                '+gte': z.number(),
                '+lt': z.number(),
                '+lte': z.number(),
                '+neq': z.string(),
                '+or': z.array(z.record(z.string(), z.unknown())),
                '+order': z.enum(['asc', 'desc']),
                '+order_by': z.string()
            })
        ]))
    }))
});

/**
 * Returns a paginated list of payment objects.
 */
export const getPaymentsResponseSchema = z.object({
    data: z.array(z.object({
        date: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        usd: z.int().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postPaymentRequestSchema = z.object({
    body: z.object({
        payment_method_id: z.int(),
        usd: z.string().regex(/^\$?\d+\.\d{2}$/)
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const postPaymentResponseSchema = z.union([
    z.object({
        date: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        usd: z.int().readonly()
    }),
    z.object({
        warnings: z.array(z.object({
            details: z.string(),
            title: z.string()
        }))
    })
]);

export const postPayPalPaymentRequestSchema = z.object({
    body: z.object({
        cancel_url: z.string(),
        redirect_url: z.string(),
        usd: z.string()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const postPayPalPaymentResponseSchema = z.union([
    z.object({
        checkout_token: z.string().readonly(),
        payment_id: z.string()
    }),
    z.object({
        warnings: z.array(z.object({
            details: z.string(),
            title: z.string()
        }))
    })
]);

export const postExecutePayPalPaymentRequestSchema = z.object({
    body: z.object({
        payer_id: z.string(),
        payment_id: z.string()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const postExecutePayPalPaymentResponseSchema = z.union([
    z.record(z.string(), z.unknown()),
    z.object({
        warnings: z.array(z.object({
            details: z.string(),
            title: z.string()
        }))
    }),
    z.object({
        warnings: z.array(z.object({
            details: z.string(),
            title: z.string()
        }))
    })
]);

export const getPaymentRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        paymentId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Payment object response.
 */
export const getPaymentResponseSchema = z.object({
    date: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    usd: z.int().readonly()
});

export const postPromoCreditRequestSchema = z.object({
    body: z.optional(z.object({
        promo_code: z.string().min(1).max(32)
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * __Read-only__ Promotions generally offer a set amount of credit that can be used toward your Linode services, and the promotion expires after a specified date. As well, a monthly cap on the promotional offer is set.
 *
 * Simply put, a promotion offers a certain amount of credit  month, until either the expiration date is passed, or until the total promotional credit is used, whichever comes first.
 */
export const postPromoCreditResponseSchema = z.object({
    credit_monthly_cap: z.string(),
    credit_remaining: z.string(),
    description: z.string(),
    expire_dt: z.string(),
    image_url: z.string(),
    service_type: z.enum([
        'all',
        'backup',
        'blockstorage',
        'db_mysql',
        'ip_v4',
        'linode',
        'linode_disk',
        'linode_memory',
        'longview',
        'managed',
        'nodebalancer',
        'objectstorage',
        'placement_group',
        'transfer_tx'
    ]),
    summary: z.string(),
    this_month_credit_remaining: z.string()
}).readonly();

export const getServiceTransfersRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of Service Transfer objects containing the details of all transfers that have been created and accepted by this account.
 */
export const getServiceTransfersResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime(),
        entities: z.object({
            linodes: z.array(z.int())
        }),
        expiry: z.iso.datetime(),
        is_sender: z.boolean(),
        status: z.enum([
            'accepted',
            'canceled',
            'completed',
            'failed',
            'pending',
            'stale'
        ]),
        token: z.uuid(),
        updated: z.iso.datetime()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postServiceTransferRequestSchema = z.object({
    body: z.optional(z.object({
        entities: z.object({
            linodes: z.array(z.int())
        })
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * An object representing a Service Transfer.
 */
export const postServiceTransferResponseSchema = z.object({
    created: z.iso.datetime(),
    entities: z.object({
        linodes: z.array(z.int())
    }),
    expiry: z.iso.datetime(),
    is_sender: z.boolean(),
    status: z.enum([
        'accepted',
        'canceled',
        'completed',
        'failed',
        'pending',
        'stale'
    ]),
    token: z.uuid(),
    updated: z.iso.datetime()
});

export const deleteServiceTransferRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        token: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteServiceTransferResponseSchema = z.record(z.string(), z.unknown());

export const getServiceTransferRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        token: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * An object representing a Service Transfer.
 */
export const getServiceTransferResponseSchema = z.object({
    created: z.iso.datetime(),
    entities: z.object({
        linodes: z.array(z.int())
    }),
    expiry: z.iso.datetime(),
    is_sender: z.boolean(),
    status: z.enum([
        'accepted',
        'canceled',
        'completed',
        'failed',
        'pending',
        'stale'
    ]),
    token: z.uuid(),
    updated: z.iso.datetime()
});

export const postAcceptServiceTransferRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        token: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postAcceptServiceTransferResponseSchema = z.record(z.string(), z.unknown());

export const getAccountSettingsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Account Settings object.
 */
export const getAccountSettingsResponseSchema = z.object({
    backups_enabled: z.boolean(),
    interfaces_for_new_linodes: z.enum([
        'legacy_config_only',
        'legacy_config_default_but_linode_allowed',
        'linode_default_but_legacy_config_allowed',
        'linode_only'
    ]),
    longview_subscription: z.string().readonly(),
    maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
    managed: z.boolean().readonly(),
    network_helper: z.boolean(),
    object_storage: z.enum([
        'disabled',
        'suspended',
        'active'
    ])
});

export const putAccountSettingsRequestSchema = z.object({
    body: z.object({
        backups_enabled: z.boolean(),
        interfaces_for_new_linodes: z.enum([
            'legacy_config_only',
            'legacy_config_default_but_linode_allowed',
            'linode_default_but_legacy_config_allowed',
            'linode_only'
        ]),
        longview_subscription: z.string().readonly(),
        maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
        managed: z.boolean().readonly(),
        network_helper: z.boolean(),
        object_storage: z.enum([
            'disabled',
            'suspended',
            'active'
        ])
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Account Settings object.
 */
export const putAccountSettingsResponseSchema = z.object({
    backups_enabled: z.boolean(),
    interfaces_for_new_linodes: z.enum([
        'legacy_config_only',
        'legacy_config_default_but_linode_allowed',
        'linode_default_but_legacy_config_allowed',
        'linode_only'
    ]),
    longview_subscription: z.string().readonly(),
    maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
    managed: z.boolean().readonly(),
    network_helper: z.boolean(),
    object_storage: z.enum([
        'disabled',
        'suspended',
        'active'
    ])
});

export const postEnableAccountManagedRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postEnableAccountManagedResponseSchema = z.record(z.string(), z.unknown());

export const getTransferRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * An object representing your network utilization for the current month, in Gigabytes.
 *
 * Certain Regions have separate utilization quotas and rates. For Region-specific network utilization data, see `region_transfers`.
 */
export const getTransferResponseSchema = z.object({
    billable: z.int().readonly(),
    quota: z.int().readonly(),
    region_transfers: z.array(z.object({
        billable: z.int().readonly(),
        id: z.string(),
        quota: z.int().readonly(),
        used: z.int().readonly()
    })),
    used: z.int().readonly()
});

export const getUsersRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of users.
 */
export const getUsersResponseSchema = z.object({
    data: z.array(z.object({
        email: z.email(),
        last_login: z.union([
            z.object({
                login_datetime: z.iso.datetime().readonly(),
                status: z.enum(['successful', 'failed'])
            }).readonly(),
            z.null()
        ]).readonly(),
        password_created: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        restricted: z.boolean(),
        ssh_keys: z.array(z.string()).readonly(),
        tfa_enabled: z.boolean().readonly(),
        username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/),
        verified_phone_number: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    }).and(z.object({
        user_type: z.enum([
            'parent',
            'child',
            'proxy',
            'default'
        ])
    }))),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postUserRequestSchema = z.object({
    body: z.optional(z.object({
        email: z.email(),
        last_login: z.union([
            z.object({
                login_datetime: z.iso.datetime().readonly(),
                status: z.enum(['successful', 'failed'])
            }).readonly(),
            z.null()
        ]).readonly(),
        password_created: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        restricted: z.boolean(),
        ssh_keys: z.array(z.string()).readonly(),
        tfa_enabled: z.boolean().readonly(),
        username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/),
        verified_phone_number: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A user on your account. Unrestricted users can log in and access information about your account, while restricted users may only access entities or perform actions they've been granted access to.
 */
export const postUserResponseSchema = z.object({
    email: z.email(),
    last_login: z.union([
        z.object({
            login_datetime: z.iso.datetime().readonly(),
            status: z.enum(['successful', 'failed'])
        }).readonly(),
        z.null()
    ]).readonly(),
    password_created: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    restricted: z.boolean(),
    ssh_keys: z.array(z.string()).readonly(),
    tfa_enabled: z.boolean().readonly(),
    username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/),
    verified_phone_number: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const deleteUserRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteUserResponseSchema = z.record(z.string(), z.unknown());

export const getUserRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The requested User object.
 */
export const getUserResponseSchema = z.object({
    email: z.email(),
    last_login: z.union([
        z.object({
            login_datetime: z.iso.datetime().readonly(),
            status: z.enum(['successful', 'failed'])
        }).readonly(),
        z.null()
    ]).readonly(),
    password_created: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    restricted: z.boolean(),
    ssh_keys: z.array(z.string()).readonly(),
    tfa_enabled: z.boolean().readonly(),
    username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/),
    verified_phone_number: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
}).and(z.object({
    user_type: z.enum([
        'parent',
        'child',
        'proxy',
        'default'
    ])
}));

export const putUserRequestSchema = z.object({
    body: z.optional(z.object({
        email: z.email(),
        last_login: z.union([
            z.object({
                login_datetime: z.iso.datetime().readonly(),
                status: z.enum(['successful', 'failed'])
            }).readonly(),
            z.null()
        ]).readonly(),
        password_created: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        restricted: z.boolean(),
        ssh_keys: z.array(z.string()).readonly(),
        tfa_enabled: z.boolean().readonly(),
        username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/),
        verified_phone_number: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    })),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * User updated successfully.
 */
export const putUserResponseSchema = z.object({
    email: z.email(),
    last_login: z.union([
        z.object({
            login_datetime: z.iso.datetime().readonly(),
            status: z.enum(['successful', 'failed'])
        }).readonly(),
        z.null()
    ]).readonly(),
    password_created: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    restricted: z.boolean(),
    ssh_keys: z.array(z.string()).readonly(),
    tfa_enabled: z.boolean().readonly(),
    username: z.string().min(3).max(32).regex(/^[a-zA-Z0-9]((?![_-]{2,})[a-zA-Z0-9-_])+[a-zA-Z0-9]$/),
    verified_phone_number: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
}).and(z.object({
    user_type: z.enum([
        'parent',
        'child',
        'proxy',
        'default'
    ])
}));

export const getUserGrantsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

export const getUserGrantsResponseSchema = z.union([
    z.object({
        database: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        domain: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        firewall: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        global: z.object({
            account_access: z.enum(['read_only', 'read_write']),
            add_databases: z.boolean(),
            add_domains: z.boolean(),
            add_firewalls: z.boolean(),
            add_images: z.boolean(),
            add_linodes: z.boolean(),
            add_longview: z.boolean(),
            add_nodebalancers: z.boolean(),
            add_stackscripts: z.boolean(),
            add_volumes: z.boolean(),
            add_vpcs: z.boolean(),
            cancel_account: z.boolean(),
            child_account_access: z.union([
                z.boolean(),
                z.null()
            ]),
            longview_subscription: z.boolean()
        }),
        image: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        linode: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        longview: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        nodebalancer: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        stackscript: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        volume: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        vpc: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        }))
    }),
    z.void()
]);

export const putUserGrantsRequestSchema = z.object({
    body: z.object({
        database: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        domain: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        firewall: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        global: z.object({
            account_access: z.enum(['read_only', 'read_write']),
            add_databases: z.boolean(),
            add_domains: z.boolean(),
            add_firewalls: z.boolean(),
            add_images: z.boolean(),
            add_linodes: z.boolean(),
            add_longview: z.boolean(),
            add_nodebalancers: z.boolean(),
            add_stackscripts: z.boolean(),
            add_volumes: z.boolean(),
            add_vpcs: z.boolean(),
            cancel_account: z.boolean(),
            child_account_access: z.union([
                z.boolean(),
                z.null()
            ]),
            longview_subscription: z.boolean()
        }),
        image: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        linode: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        longview: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        nodebalancer: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        stackscript: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        volume: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        vpc: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        }))
    }),
    path: z.object({
        username: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Grants updated successfully.
 */
export const putUserGrantsResponseSchema = z.object({
    database: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    domain: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    firewall: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    global: z.object({
        account_access: z.enum(['read_only', 'read_write']),
        add_databases: z.boolean(),
        add_domains: z.boolean(),
        add_firewalls: z.boolean(),
        add_images: z.boolean(),
        add_linodes: z.boolean(),
        add_longview: z.boolean(),
        add_nodebalancers: z.boolean(),
        add_stackscripts: z.boolean(),
        add_volumes: z.boolean(),
        add_vpcs: z.boolean(),
        cancel_account: z.boolean(),
        child_account_access: z.union([
            z.boolean(),
            z.null()
        ]),
        longview_subscription: z.boolean()
    }),
    image: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    linode: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    longview: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    nodebalancer: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    stackscript: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    volume: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    })),
    vpc: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        permissions: z.enum(['read_only', 'read_write'])
    }))
});

export const getBetaProgramsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of all available Beta Program objects.
 */
export const getBetaProgramsResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.array(z.object({
        description: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        ended: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        greenlight_only: z.boolean().readonly(),
        id: z.string(),
        label: z.string().readonly(),
        more_info: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        started: z.iso.datetime().readonly()
    }))
}));

export const getBetaProgramRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        betaId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * An object representing Beta Program information.
 */
export const getBetaProgramResponseSchema = z.object({
    description: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    ended: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    greenlight_only: z.boolean().readonly(),
    id: z.string(),
    label: z.string().readonly(),
    more_info: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    started: z.iso.datetime().readonly()
});

export const getDatabasesEnginesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of all available Managed Databases engines and versions.
 */
export const getDatabasesEnginesResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.array(z.object({
        engine: z.string(),
        id: z.string(),
        version: z.string()
    }))
}));

export const getDatabasesEngineRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        engineId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Managed Database engine object.
 */
export const getDatabasesEngineResponseSchema = z.object({
    engine: z.string(),
    id: z.string(),
    version: z.string()
});

export const getDatabasesInstancesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of all accessible Managed Databases on your account.
 */
export const getDatabasesInstancesResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.array(z.object({
        allow_list: z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0),
        cluster_size: z.union([
            z.literal(1),
            z.literal(2),
            z.literal(3)
        ]),
        created: z.iso.datetime().readonly(),
        encrypted: z.boolean().readonly().default(true),
        engine: z.enum(['mysql', 'postgresql']),
        fork: z.object({
            restore_time: z.iso.datetime(),
            source: z.int()
        }),
        hosts: z.object({
            primary: z.union([
                z.string(),
                z.null()
            ]),
            secondary: z.union([
                z.string(),
                z.null()
            ])
        }).readonly(),
        id: z.int().readonly(),
        instance_uri: z.string().readonly(),
        label: z.string().min(3).max(32),
        members: z.record(z.string(), z.unknown()).readonly(),
        oldest_restore_time: z.iso.datetime().readonly(),
        platform: z.enum(['rdbms-legacy', 'rdbms-default']),
        port: z.int().readonly(),
        region: z.string(),
        status: z.enum([
            'provisioning',
            'active',
            'suspending',
            'suspended',
            'resuming',
            'failed',
            'degraded',
            'updating',
            'resizing'
        ]),
        total_disk_size_gb: z.int().readonly(),
        type: z.string(),
        updated: z.iso.datetime().readonly(),
        updates: z.object({
            day_of_week: z.int().gte(1).lte(7),
            duration: z.int().gte(1).lte(3),
            frequency: z.enum(['weekly']),
            hour_of_day: z.int().gte(0).lte(23),
            pending: z.array(z.object({
                deadline: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.string(),
                planned_for: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            })).min(0).readonly()
        }),
        used_disk_size_gb: z.int().readonly(),
        version: z.string()
    }))
}));

export const getDatabasesMysqlConfigRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Available [advanced parameters](https://aiven.io/docs/products/mysql/reference/advanced-params) for a MySQL Managed Database.
 */
export const getDatabasesMysqlConfigResponseSchema = z.object({
    binlog_retention_period: z.int(),
    mysql: z.object({
        connect_timeout: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        default_time_zone: z.object({
            description: z.string(),
            example: z.string(),
            maxLength: z.int(),
            minLength: z.int(),
            pattern: z.string(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        group_concat_max_len: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        information_schema_stats_expiry: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        innodb_change_buffer_max_size: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        innodb_flush_neighbors: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        innodb_ft_min_token_size: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        innodb_ft_server_stopword_table: z.union([
            z.object({
                description: z.string(),
                example: z.string(),
                maxLength: z.int(),
                pattern: z.string(),
                requires_restart: z.boolean(),
                type: z.string()
            }),
            z.null()
        ]),
        innodb_lock_wait_timeout: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        innodb_log_buffer_size: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        innodb_online_alter_log_max_size: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        innodb_read_io_threads: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        innodb_rollback_on_timeout: z.object({
            description: z.string(),
            example: z.string(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        innodb_thread_concurrency: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        innodb_write_io_threads: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        interactive_timeout: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        internal_tmp_mem_storage_engine: z.object({
            description: z.string(),
            enum: z.string(),
            example: z.string(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_allowed_packet: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_heap_table_size: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        net_buffer_length: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        net_read_timeout: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        net_write_timeout: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        sql_mode: z.object({
            description: z.string(),
            example: z.string(),
            maxLength: z.int(),
            pattern: z.string(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        sql_require_primary_key: z.object({
            description: z.string(),
            example: z.string(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        tmp_table_size: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        wait_timeout: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        })
    })
});

export const getDatabasesMysqlInstancesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of all accessible MySQL Managed Databases on your account.
 */
export const getDatabasesMysqlInstancesResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.array(z.object({
        allow_list: z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0),
        cluster_size: z.union([
            z.literal(1),
            z.literal(2),
            z.literal(3)
        ]),
        created: z.iso.datetime().readonly(),
        encrypted: z.boolean().readonly().default(true),
        engine: z.string().readonly(),
        engine_config: z.object({
            binlog_retention_period: z.int().gte(600).lte(86400),
            mysql: z.object({
                connect_timeout: z.int().gte(2).lte(3600),
                default_time_zone: z.string().min(2).max(100).regex(/^([-+][\\d:]*|[\\w\/]*)$/),
                group_concat_max_len: z.int().gte(4).lte(18446744073709552000),
                information_schema_stats_expiry: z.int().gte(900).lte(31536000),
                innodb_change_buffer_max_size: z.int().gte(0).lte(50).default(25),
                innodb_flush_neighbors: z.int().gte(0).lte(2).default(1),
                innodb_ft_min_token_size: z.int().gte(0).lte(16),
                innodb_ft_server_stopword_table: z.union([
                    z.string().max(1024).regex(/^.+\/.+$/),
                    z.null()
                ]),
                innodb_lock_wait_timeout: z.int().gte(1).lte(3600).default(120),
                innodb_log_buffer_size: z.int().gte(1048576).lte(4294967295),
                innodb_online_alter_log_max_size: z.int().gte(65536).lte(1099511627776),
                innodb_read_io_threads: z.int().gte(1).lte(64).default(4),
                innodb_rollback_on_timeout: z.boolean(),
                innodb_thread_concurrency: z.int().gte(0).lte(1000).default(0),
                innodb_write_io_threads: z.int().gte(1).lte(64).default(4),
                interactive_timeout: z.int().gte(30).lte(604800),
                internal_tmp_mem_storage_engine: z.enum(['TempTable', 'MEMORY']),
                max_allowed_packet: z.int().gte(102400).lte(1073741824).default(7108864),
                max_heap_table_size: z.int().gte(1048576).lte(1073741824).default(16777216),
                net_buffer_length: z.int().gte(1024).lte(1048576).default(16384),
                net_read_timeout: z.int().gte(1).lte(3600),
                net_write_timeout: z.int().gte(1).lte(3600),
                sql_mode: z.string().max(1024).regex(/^[A-Z_]*(,[A-Z_]+)*$/),
                sql_require_primary_key: z.boolean(),
                tmp_table_size: z.int().gte(1048576).lte(1073741824).default(16777216),
                wait_timeout: z.int().gte(1).lte(2147483)
            })
        }),
        fork: z.object({
            restore_time: z.iso.datetime(),
            source: z.int()
        }),
        hosts: z.object({
            primary: z.union([
                z.string(),
                z.null()
            ]),
            secondary: z.union([
                z.string(),
                z.null()
            ])
        }).readonly(),
        id: z.int().readonly(),
        label: z.string().min(3).max(32),
        members: z.record(z.string(), z.unknown()).readonly(),
        oldest_restore_time: z.iso.datetime().readonly(),
        platform: z.enum(['rdbms-legacy', 'rdbms-default']),
        port: z.int().readonly(),
        private_network: z.union([
            z.object({
                public_access: z.boolean().default(false),
                subnet_id: z.int(),
                vpc_id: z.int()
            }),
            z.null()
        ]),
        region: z.string(),
        ssl_connection: z.boolean().default(true),
        status: z.enum([
            'provisioning',
            'active',
            'suspending',
            'suspended',
            'resuming',
            'failed',
            'degraded',
            'updating',
            'resizing'
        ]),
        total_disk_size_gb: z.int().readonly(),
        type: z.string(),
        updated: z.iso.datetime().readonly(),
        updates: z.object({
            day_of_week: z.int().gte(1).lte(7),
            duration: z.int().gte(1).lte(3),
            frequency: z.enum(['weekly']),
            hour_of_day: z.int().gte(0).lte(23),
            pending: z.array(z.object({
                deadline: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.string(),
                planned_for: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            })).min(0).readonly()
        }),
        used_disk_size_gb: z.int().readonly(),
        version: z.string()
    }))
}));

export const postDatabasesMysqlInstancesRequestSchema = z.object({
    body: z.object({
        allow_list: z.optional(z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0)),
        cluster_size: z.optional(z.union([
            z.literal(1),
            z.literal(2),
            z.literal(3)
        ])),
        engine: z.string(),
        engine_config: z.optional(z.object({
            binlog_retention_period: z.int().gte(600).lte(86400),
            mysql: z.object({
                connect_timeout: z.int().gte(2).lte(3600),
                default_time_zone: z.string().min(2).max(100).regex(/^([-+][\\d:]*|[\\w\/]*)$/),
                group_concat_max_len: z.int().gte(4).lte(18446744073709552000),
                information_schema_stats_expiry: z.int().gte(900).lte(31536000),
                innodb_change_buffer_max_size: z.int().gte(0).lte(50).default(25),
                innodb_flush_neighbors: z.int().gte(0).lte(2).default(1),
                innodb_ft_min_token_size: z.int().gte(0).lte(16),
                innodb_ft_server_stopword_table: z.union([
                    z.string().max(1024).regex(/^.+\/.+$/),
                    z.null()
                ]),
                innodb_lock_wait_timeout: z.int().gte(1).lte(3600).default(120),
                innodb_log_buffer_size: z.int().gte(1048576).lte(4294967295),
                innodb_online_alter_log_max_size: z.int().gte(65536).lte(1099511627776),
                innodb_read_io_threads: z.int().gte(1).lte(64).default(4),
                innodb_rollback_on_timeout: z.boolean(),
                innodb_thread_concurrency: z.int().gte(0).lte(1000).default(0),
                innodb_write_io_threads: z.int().gte(1).lte(64).default(4),
                interactive_timeout: z.int().gte(30).lte(604800),
                internal_tmp_mem_storage_engine: z.enum(['TempTable', 'MEMORY']),
                max_allowed_packet: z.int().gte(102400).lte(1073741824).default(7108864),
                max_heap_table_size: z.int().gte(1048576).lte(1073741824).default(16777216),
                net_buffer_length: z.int().gte(1024).lte(1048576).default(16384),
                net_read_timeout: z.int().gte(1).lte(3600),
                net_write_timeout: z.int().gte(1).lte(3600),
                sql_mode: z.string().max(1024).regex(/^[A-Z_]*(,[A-Z_]+)*$/),
                sql_require_primary_key: z.boolean(),
                tmp_table_size: z.int().gte(1048576).lte(1073741824).default(16777216),
                wait_timeout: z.int().gte(1).lte(2147483)
            })
        })),
        fork: z.optional(z.object({
            restore_time: z.optional(z.iso.datetime()),
            source: z.int()
        })),
        label: z.string().min(3).max(32),
        private_network: z.optional(z.union([
            z.object({
                public_access: z.boolean().default(false),
                subnet_id: z.int(),
                vpc_id: z.int()
            }),
            z.null()
        ])),
        region: z.string(),
        ssl_connection: z.optional(z.boolean()).default(true),
        type: z.string()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Managed MySQL Databases object.
 */
export const postDatabasesMysqlInstancesResponseSchema = z.object({
    allow_list: z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0),
    cluster_size: z.union([
        z.literal(1),
        z.literal(2),
        z.literal(3)
    ]),
    created: z.iso.datetime().readonly(),
    encrypted: z.boolean().readonly().default(true),
    engine: z.string().readonly(),
    engine_config: z.object({
        binlog_retention_period: z.int().gte(600).lte(86400),
        mysql: z.object({
            connect_timeout: z.int().gte(2).lte(3600),
            default_time_zone: z.string().min(2).max(100).regex(/^([-+][\\d:]*|[\\w\/]*)$/),
            group_concat_max_len: z.int().gte(4).lte(18446744073709552000),
            information_schema_stats_expiry: z.int().gte(900).lte(31536000),
            innodb_change_buffer_max_size: z.int().gte(0).lte(50).default(25),
            innodb_flush_neighbors: z.int().gte(0).lte(2).default(1),
            innodb_ft_min_token_size: z.int().gte(0).lte(16),
            innodb_ft_server_stopword_table: z.union([
                z.string().max(1024).regex(/^.+\/.+$/),
                z.null()
            ]),
            innodb_lock_wait_timeout: z.int().gte(1).lte(3600).default(120),
            innodb_log_buffer_size: z.int().gte(1048576).lte(4294967295),
            innodb_online_alter_log_max_size: z.int().gte(65536).lte(1099511627776),
            innodb_read_io_threads: z.int().gte(1).lte(64).default(4),
            innodb_rollback_on_timeout: z.boolean(),
            innodb_thread_concurrency: z.int().gte(0).lte(1000).default(0),
            innodb_write_io_threads: z.int().gte(1).lte(64).default(4),
            interactive_timeout: z.int().gte(30).lte(604800),
            internal_tmp_mem_storage_engine: z.enum(['TempTable', 'MEMORY']),
            max_allowed_packet: z.int().gte(102400).lte(1073741824).default(7108864),
            max_heap_table_size: z.int().gte(1048576).lte(1073741824).default(16777216),
            net_buffer_length: z.int().gte(1024).lte(1048576).default(16384),
            net_read_timeout: z.int().gte(1).lte(3600),
            net_write_timeout: z.int().gte(1).lte(3600),
            sql_mode: z.string().max(1024).regex(/^[A-Z_]*(,[A-Z_]+)*$/),
            sql_require_primary_key: z.boolean(),
            tmp_table_size: z.int().gte(1048576).lte(1073741824).default(16777216),
            wait_timeout: z.int().gte(1).lte(2147483)
        })
    }),
    fork: z.object({
        restore_time: z.iso.datetime(),
        source: z.int()
    }),
    hosts: z.object({
        primary: z.union([
            z.string(),
            z.null()
        ]),
        secondary: z.union([
            z.string(),
            z.null()
        ])
    }).readonly(),
    id: z.int().readonly(),
    label: z.string().min(3).max(32),
    members: z.record(z.string(), z.unknown()).readonly(),
    oldest_restore_time: z.iso.datetime().readonly(),
    platform: z.enum(['rdbms-legacy', 'rdbms-default']),
    port: z.int().readonly(),
    private_network: z.union([
        z.object({
            public_access: z.boolean().default(false),
            subnet_id: z.int(),
            vpc_id: z.int()
        }),
        z.null()
    ]),
    region: z.string(),
    ssl_connection: z.boolean().default(true),
    status: z.enum([
        'provisioning',
        'active',
        'suspending',
        'suspended',
        'resuming',
        'failed',
        'degraded',
        'updating',
        'resizing'
    ]),
    total_disk_size_gb: z.int().readonly(),
    type: z.string(),
    updated: z.iso.datetime().readonly(),
    updates: z.object({
        day_of_week: z.int().gte(1).lte(7),
        duration: z.int().gte(1).lte(3),
        frequency: z.enum(['weekly']),
        hour_of_day: z.int().gte(0).lte(23),
        pending: z.array(z.object({
            deadline: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            description: z.string(),
            planned_for: z.union([
                z.iso.datetime(),
                z.null()
            ])
        })).min(0).readonly()
    }),
    used_disk_size_gb: z.int().readonly(),
    version: z.string()
});

export const deleteDatabasesMysqlInstanceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteDatabasesMysqlInstanceResponseSchema = z.record(z.string(), z.unknown());

export const getDatabasesMysqlInstanceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Managed MySQL Databases object.
 */
export const getDatabasesMysqlInstanceResponseSchema = z.object({
    allow_list: z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0),
    cluster_size: z.union([
        z.literal(1),
        z.literal(2),
        z.literal(3)
    ]),
    created: z.iso.datetime().readonly(),
    encrypted: z.boolean().readonly().default(true),
    engine: z.string().readonly(),
    engine_config: z.object({
        binlog_retention_period: z.int().gte(600).lte(86400),
        mysql: z.object({
            connect_timeout: z.int().gte(2).lte(3600),
            default_time_zone: z.string().min(2).max(100).regex(/^([-+][\\d:]*|[\\w\/]*)$/),
            group_concat_max_len: z.int().gte(4).lte(18446744073709552000),
            information_schema_stats_expiry: z.int().gte(900).lte(31536000),
            innodb_change_buffer_max_size: z.int().gte(0).lte(50).default(25),
            innodb_flush_neighbors: z.int().gte(0).lte(2).default(1),
            innodb_ft_min_token_size: z.int().gte(0).lte(16),
            innodb_ft_server_stopword_table: z.union([
                z.string().max(1024).regex(/^.+\/.+$/),
                z.null()
            ]),
            innodb_lock_wait_timeout: z.int().gte(1).lte(3600).default(120),
            innodb_log_buffer_size: z.int().gte(1048576).lte(4294967295),
            innodb_online_alter_log_max_size: z.int().gte(65536).lte(1099511627776),
            innodb_read_io_threads: z.int().gte(1).lte(64).default(4),
            innodb_rollback_on_timeout: z.boolean(),
            innodb_thread_concurrency: z.int().gte(0).lte(1000).default(0),
            innodb_write_io_threads: z.int().gte(1).lte(64).default(4),
            interactive_timeout: z.int().gte(30).lte(604800),
            internal_tmp_mem_storage_engine: z.enum(['TempTable', 'MEMORY']),
            max_allowed_packet: z.int().gte(102400).lte(1073741824).default(7108864),
            max_heap_table_size: z.int().gte(1048576).lte(1073741824).default(16777216),
            net_buffer_length: z.int().gte(1024).lte(1048576).default(16384),
            net_read_timeout: z.int().gte(1).lte(3600),
            net_write_timeout: z.int().gte(1).lte(3600),
            sql_mode: z.string().max(1024).regex(/^[A-Z_]*(,[A-Z_]+)*$/),
            sql_require_primary_key: z.boolean(),
            tmp_table_size: z.int().gte(1048576).lte(1073741824).default(16777216),
            wait_timeout: z.int().gte(1).lte(2147483)
        })
    }),
    fork: z.object({
        restore_time: z.iso.datetime(),
        source: z.int()
    }),
    hosts: z.object({
        primary: z.union([
            z.string(),
            z.null()
        ]),
        secondary: z.union([
            z.string(),
            z.null()
        ])
    }).readonly(),
    id: z.int().readonly(),
    label: z.string().min(3).max(32),
    members: z.record(z.string(), z.unknown()).readonly(),
    oldest_restore_time: z.iso.datetime().readonly(),
    platform: z.enum(['rdbms-legacy', 'rdbms-default']),
    port: z.int().readonly(),
    private_network: z.union([
        z.object({
            public_access: z.boolean().default(false),
            subnet_id: z.int(),
            vpc_id: z.int()
        }),
        z.null()
    ]),
    region: z.string(),
    ssl_connection: z.boolean().default(true),
    status: z.enum([
        'provisioning',
        'active',
        'suspending',
        'suspended',
        'resuming',
        'failed',
        'degraded',
        'updating',
        'resizing'
    ]),
    total_disk_size_gb: z.int().readonly(),
    type: z.string(),
    updated: z.iso.datetime().readonly(),
    updates: z.object({
        day_of_week: z.int().gte(1).lte(7),
        duration: z.int().gte(1).lte(3),
        frequency: z.enum(['weekly']),
        hour_of_day: z.int().gte(0).lte(23),
        pending: z.array(z.object({
            deadline: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            description: z.string(),
            planned_for: z.union([
                z.iso.datetime(),
                z.null()
            ])
        })).min(0).readonly()
    }),
    used_disk_size_gb: z.int().readonly(),
    version: z.string()
});

export const putDatabasesMysqlInstanceRequestSchema = z.object({
    body: z.object({
        allow_list: z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0),
        engine_config: z.object({
            binlog_retention_period: z.int().gte(600).lte(86400),
            mysql: z.object({
                connect_timeout: z.int().gte(2).lte(3600),
                default_time_zone: z.string().min(2).max(100).regex(/^([-+][\\d:]*|[\\w\/]*)$/),
                group_concat_max_len: z.int().gte(4).lte(18446744073709552000),
                information_schema_stats_expiry: z.int().gte(900).lte(31536000),
                innodb_change_buffer_max_size: z.int().gte(0).lte(50).default(25),
                innodb_flush_neighbors: z.int().gte(0).lte(2).default(1),
                innodb_ft_min_token_size: z.int().gte(0).lte(16),
                innodb_ft_server_stopword_table: z.union([
                    z.string().max(1024).regex(/^.+\/.+$/),
                    z.null()
                ]),
                innodb_lock_wait_timeout: z.int().gte(1).lte(3600).default(120),
                innodb_log_buffer_size: z.int().gte(1048576).lte(4294967295),
                innodb_online_alter_log_max_size: z.int().gte(65536).lte(1099511627776),
                innodb_read_io_threads: z.int().gte(1).lte(64).default(4),
                innodb_rollback_on_timeout: z.boolean(),
                innodb_thread_concurrency: z.int().gte(0).lte(1000).default(0),
                innodb_write_io_threads: z.int().gte(1).lte(64).default(4),
                interactive_timeout: z.int().gte(30).lte(604800),
                internal_tmp_mem_storage_engine: z.enum(['TempTable', 'MEMORY']),
                max_allowed_packet: z.int().gte(102400).lte(1073741824).default(7108864),
                max_heap_table_size: z.int().gte(1048576).lte(1073741824).default(16777216),
                net_buffer_length: z.int().gte(1024).lte(1048576).default(16384),
                net_read_timeout: z.int().gte(1).lte(3600),
                net_write_timeout: z.int().gte(1).lte(3600),
                sql_mode: z.string().max(1024).regex(/^[A-Z_]*(,[A-Z_]+)*$/),
                sql_require_primary_key: z.boolean(),
                tmp_table_size: z.int().gte(1048576).lte(1073741824).default(16777216),
                wait_timeout: z.int().gte(1).lte(2147483)
            })
        }),
        label: z.string().min(3).max(32),
        private_network: z.union([
            z.object({
                public_access: z.boolean().default(false),
                subnet_id: z.int(),
                vpc_id: z.int()
            }),
            z.null()
        ]),
        type: z.string(),
        updates: z.object({
            day_of_week: z.int().gte(1).lte(7),
            duration: z.int().gte(1).lte(3),
            frequency: z.enum(['weekly']),
            hour_of_day: z.int().gte(0).lte(23),
            pending: z.array(z.object({
                deadline: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.string(),
                planned_for: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            })).min(0).readonly()
        }),
        version: z.string()
    }),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Managed MySQL Databases object.
 */
export const putDatabasesMysqlInstanceResponseSchema = z.object({
    allow_list: z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0),
    cluster_size: z.union([
        z.literal(1),
        z.literal(2),
        z.literal(3)
    ]),
    created: z.iso.datetime().readonly(),
    encrypted: z.boolean().readonly().default(true),
    engine: z.string().readonly(),
    engine_config: z.object({
        binlog_retention_period: z.int().gte(600).lte(86400),
        mysql: z.object({
            connect_timeout: z.int().gte(2).lte(3600),
            default_time_zone: z.string().min(2).max(100).regex(/^([-+][\\d:]*|[\\w\/]*)$/),
            group_concat_max_len: z.int().gte(4).lte(18446744073709552000),
            information_schema_stats_expiry: z.int().gte(900).lte(31536000),
            innodb_change_buffer_max_size: z.int().gte(0).lte(50).default(25),
            innodb_flush_neighbors: z.int().gte(0).lte(2).default(1),
            innodb_ft_min_token_size: z.int().gte(0).lte(16),
            innodb_ft_server_stopword_table: z.union([
                z.string().max(1024).regex(/^.+\/.+$/),
                z.null()
            ]),
            innodb_lock_wait_timeout: z.int().gte(1).lte(3600).default(120),
            innodb_log_buffer_size: z.int().gte(1048576).lte(4294967295),
            innodb_online_alter_log_max_size: z.int().gte(65536).lte(1099511627776),
            innodb_read_io_threads: z.int().gte(1).lte(64).default(4),
            innodb_rollback_on_timeout: z.boolean(),
            innodb_thread_concurrency: z.int().gte(0).lte(1000).default(0),
            innodb_write_io_threads: z.int().gte(1).lte(64).default(4),
            interactive_timeout: z.int().gte(30).lte(604800),
            internal_tmp_mem_storage_engine: z.enum(['TempTable', 'MEMORY']),
            max_allowed_packet: z.int().gte(102400).lte(1073741824).default(7108864),
            max_heap_table_size: z.int().gte(1048576).lte(1073741824).default(16777216),
            net_buffer_length: z.int().gte(1024).lte(1048576).default(16384),
            net_read_timeout: z.int().gte(1).lte(3600),
            net_write_timeout: z.int().gte(1).lte(3600),
            sql_mode: z.string().max(1024).regex(/^[A-Z_]*(,[A-Z_]+)*$/),
            sql_require_primary_key: z.boolean(),
            tmp_table_size: z.int().gte(1048576).lte(1073741824).default(16777216),
            wait_timeout: z.int().gte(1).lte(2147483)
        })
    }),
    fork: z.object({
        restore_time: z.iso.datetime(),
        source: z.int()
    }),
    hosts: z.object({
        primary: z.union([
            z.string(),
            z.null()
        ]),
        secondary: z.union([
            z.string(),
            z.null()
        ])
    }).readonly(),
    id: z.int().readonly(),
    label: z.string().min(3).max(32),
    members: z.record(z.string(), z.unknown()).readonly(),
    oldest_restore_time: z.iso.datetime().readonly(),
    platform: z.enum(['rdbms-legacy', 'rdbms-default']),
    port: z.int().readonly(),
    private_network: z.union([
        z.object({
            public_access: z.boolean().default(false),
            subnet_id: z.int(),
            vpc_id: z.int()
        }),
        z.null()
    ]),
    region: z.string(),
    ssl_connection: z.boolean().default(true),
    status: z.enum([
        'provisioning',
        'active',
        'suspending',
        'suspended',
        'resuming',
        'failed',
        'degraded',
        'updating',
        'resizing'
    ]),
    total_disk_size_gb: z.int().readonly(),
    type: z.string(),
    updated: z.iso.datetime().readonly(),
    updates: z.object({
        day_of_week: z.int().gte(1).lte(7),
        duration: z.int().gte(1).lte(3),
        frequency: z.enum(['weekly']),
        hour_of_day: z.int().gte(0).lte(23),
        pending: z.array(z.object({
            deadline: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            description: z.string(),
            planned_for: z.union([
                z.iso.datetime(),
                z.null()
            ])
        })).min(0).readonly()
    }),
    used_disk_size_gb: z.int().readonly(),
    version: z.string()
});

export const getDatabasesMysqlInstanceCredentialsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Managed Database object for database credentials.
 */
export const getDatabasesMysqlInstanceCredentialsResponseSchema = z.object({
    password: z.string().readonly(),
    username: z.string().readonly()
});

export const postDatabasesMysqlInstanceCredentialsResetRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postDatabasesMysqlInstanceCredentialsResetResponseSchema = z.record(z.string(), z.unknown());

export const postDatabasesMysqlInstancePatchRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postDatabasesMysqlInstancePatchResponseSchema = z.record(z.string(), z.unknown());

export const resumeDatabasesMysqlInstanceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const resumeDatabasesMysqlInstanceResponseSchema = z.record(z.string(), z.unknown());

export const getDatabasesMysqlInstanceSslRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Managed Database SSL object.
 */
export const getDatabasesMysqlInstanceSslResponseSchema = z.object({
    ca_certificate: z.string()
});

export const suspendDatabasesMysqlInstanceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const suspendDatabasesMysqlInstanceResponseSchema = z.record(z.string(), z.unknown());

export const getDatabasesPostgresqlConfigRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Available [advanced parameters](https://aiven.io/docs/products/postgresql/reference/advanced-params) for a PostgreSQL Managed Database.
 */
export const getDatabasesPostgresqlConfigResponseSchema = z.object({
    pg: z.object({
        autovacuum_analyze_scale_factor: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        autovacuum_analyze_threshold: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        autovacuum_max_workers: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        autovacuum_naptime: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        autovacuum_vacuum_cost_delay: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        autovacuum_vacuum_cost_limit: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        autovacuum_vacuum_scale_factor: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        autovacuum_vacuum_threshold: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        bgwriter_delay: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        bgwriter_flush_after: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        bgwriter_lru_maxpages: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        bgwriter_lru_multiplier: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        deadlock_timeout: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        default_toast_compression: z.object({
            description: z.string(),
            enum: z.string(),
            example: z.string(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        idle_in_transaction_session_timeout: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        jit: z.object({
            description: z.string(),
            example: z.string(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_files_per_process: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_locks_per_transaction: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_logical_replication_workers: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_parallel_workers: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_parallel_workers_per_gather: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_pred_locks_per_transaction: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_replication_slots: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_slot_wal_keep_size: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_stack_depth: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_standby_archive_delay: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_standby_streaming_delay: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_wal_senders: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        max_worker_processes: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        password_encryption: z.object({
            description: z.string(),
            enum: z.string(),
            example: z.string(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        'pg_partman_bgw.interval': z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        'pg_partman_bgw.role': z.object({
            description: z.string(),
            example: z.string(),
            maxLength: z.int(),
            pattern: z.string(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        'pg_stat_monitor.pgsm_enable_query_plan': z.object({
            description: z.string(),
            example: z.string(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        'pg_stat_monitor.pgsm_max_buckets': z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        'pg_stat_statements.track': z.object({
            description: z.string(),
            enum: z.string(),
            example: z.string(),
            requires_restart: z.boolean(),
            type: z.array(z.int())
        }),
        temp_file_limit: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        timezone: z.object({
            description: z.string(),
            example: z.string(),
            maxLength: z.int(),
            pattern: z.string(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        track_activity_query_size: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        track_commit_timestamp: z.object({
            description: z.string(),
            enum: z.string(),
            example: z.string(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        track_functions: z.object({
            description: z.string(),
            enum: z.string(),
            example: z.string(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        track_io_timing: z.object({
            description: z.string(),
            enum: z.string(),
            example: z.string(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        wal_sender_timeout: z.object({
            description: z.string(),
            example: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        }),
        wal_writer_delay: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        })
    }),
    pg_stat_monitor_enable: z.object({
        description: z.string(),
        requires_restart: z.boolean(),
        type: z.string()
    }),
    pglookout: z.object({
        max_failover_replication_time_lag: z.object({
            description: z.string(),
            example: z.int(),
            maximum: z.int(),
            minimum: z.int(),
            requires_restart: z.boolean(),
            type: z.string()
        })
    }),
    shared_buffers_percentage: z.object({
        description: z.string(),
        example: z.int(),
        maximum: z.int(),
        minimum: z.int(),
        requires_restart: z.boolean(),
        type: z.string()
    }),
    work_mem: z.object({
        description: z.string(),
        example: z.int(),
        maximum: z.int(),
        minimum: z.int(),
        requires_restart: z.boolean(),
        type: z.string()
    })
});

export const getDatabasesPostgreSqlInstancesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of all accessible PostgreSQL Managed Databases on your account.
 */
export const getDatabasesPostgreSqlInstancesResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.array(z.object({
        allow_list: z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0),
        cluster_size: z.union([
            z.literal(1),
            z.literal(2),
            z.literal(3)
        ]),
        created: z.iso.datetime().readonly(),
        encrypted: z.boolean().readonly().default(true),
        engine: z.string().readonly(),
        engine_config: z.object({
            pg: z.object({
                autovacuum_analyze_scale_factor: z.number().gte(0).lte(1).default(0.2),
                autovacuum_analyze_threshold: z.int().gte(0).lte(2147483647).default(50),
                autovacuum_max_workers: z.int().gte(1).lte(20).default(3),
                autovacuum_naptime: z.int().gte(1).lte(86400).default(60),
                autovacuum_vacuum_cost_delay: z.int().gte(-1).lte(100).default(20),
                autovacuum_vacuum_cost_limit: z.int().gte(-1).lte(10000).default(-1),
                autovacuum_vacuum_scale_factor: z.number().gte(0).lte(1).default(0.2),
                autovacuum_vacuum_threshold: z.int().gte(0).lte(2147483647).default(50),
                bgwriter_delay: z.int().gte(20).lte(10000).default(200),
                bgwriter_flush_after: z.int().gte(0).lte(2048).default(512),
                bgwriter_lru_maxpages: z.int().gte(0).lte(1073741823).default(100),
                bgwriter_lru_multiplier: z.number().gte(0).lte(10).default(2.5),
                deadlock_timeout: z.int().gte(500).lte(1800000),
                default_toast_compression: z.enum(['lz4', 'pglz']),
                idle_in_transaction_session_timeout: z.int().gte(0).lte(604800000),
                jit: z.boolean(),
                max_files_per_process: z.int().gte(1000).lte(4096),
                max_locks_per_transaction: z.int().gte(64).lte(6400),
                max_logical_replication_workers: z.int().gte(4).lte(64),
                max_parallel_workers: z.int().gte(0).lte(96),
                max_parallel_workers_per_gather: z.int().gte(0).lte(96),
                max_pred_locks_per_transaction: z.int().gte(64).lte(5120),
                max_replication_slots: z.int().gte(8).lte(64),
                max_slot_wal_keep_size: z.int().gte(-1).lte(2147483647).default(-1),
                max_stack_depth: z.int().gte(2097152).lte(6291456),
                max_standby_archive_delay: z.int().gte(1).lte(43200000),
                max_standby_streaming_delay: z.int().gte(1).lte(43200000),
                max_wal_senders: z.int().gte(20).lte(64),
                max_worker_processes: z.int().gte(8).lte(96),
                password_encryption: z.enum(['scram-sh-256', 'md5']),
                'pg_partman_bgw.interval': z.int().gte(3600).lte(604800),
                'pg_partman_bgw.role': z.string(),
                'pg_stat_monitor.pgsm_enable_query_plan': z.boolean(),
                'pg_stat_monitor.pgsm_max_buckets': z.int().gte(1).lte(10),
                'pg_stat_statements.track': z.enum([
                    'all',
                    'top',
                    'none'
                ]),
                temp_file_limit: z.int().gte(-1).lte(2147483647),
                timezone: z.string().max(64).regex(/^[\\w\/]*$/),
                track_activity_query_size: z.int().gte(1024).lte(10240),
                track_commit_timestamp: z.enum(['on', 'off']),
                track_functions: z.enum([
                    'all',
                    'pl',
                    'none'
                ]),
                track_io_timing: z.enum(['on', 'off']),
                wal_sender_timeout: z.int().gte(0).lte(60000),
                wal_writer_delay: z.int().gte(10).lte(200).default(200)
            }),
            pg_stat_monitor_enable: z.boolean(),
            pglookout: z.object({
                max_failover_replication_time_lag: z.int().gte(10).lte(999999)
            }),
            shared_buffers_percentage: z.number().gte(20).lte(60),
            work_mem: z.int().gte(1).lte(4)
        }),
        fork: z.object({
            restore_time: z.iso.datetime(),
            source: z.int()
        }),
        hosts: z.object({
            primary: z.union([
                z.string(),
                z.null()
            ]),
            secondary: z.union([
                z.string(),
                z.null()
            ])
        }).readonly(),
        id: z.int().readonly(),
        label: z.string().min(3).max(32),
        members: z.record(z.string(), z.unknown()).readonly(),
        oldest_restore_time: z.iso.datetime().readonly(),
        platform: z.enum(['rdbms-legacy', 'rdbms-default']),
        port: z.int().readonly(),
        private_network: z.union([
            z.object({
                public_access: z.boolean().default(false),
                subnet_id: z.int(),
                vpc_id: z.int()
            }),
            z.null()
        ]),
        region: z.string(),
        ssl_connection: z.boolean().default(true),
        status: z.enum([
            'provisioning',
            'active',
            'suspending',
            'suspended',
            'resuming',
            'failed',
            'degraded',
            'updating',
            'resizing'
        ]),
        total_disk_size_gb: z.int().readonly(),
        type: z.string(),
        updated: z.iso.datetime().readonly(),
        updates: z.object({
            day_of_week: z.int().gte(1).lte(7),
            duration: z.int().gte(1).lte(3),
            frequency: z.enum(['weekly']),
            hour_of_day: z.int().gte(0).lte(23),
            pending: z.array(z.object({
                deadline: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.string(),
                planned_for: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            })).min(0).readonly()
        }),
        used_disk_size_gb: z.int().readonly(),
        version: z.string()
    }))
}));

export const postDatabasesPostgreSqlInstancesRequestSchema = z.object({
    body: z.object({
        allow_list: z.optional(z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0)),
        cluster_size: z.optional(z.union([
            z.literal(1),
            z.literal(2),
            z.literal(3)
        ])),
        engine: z.string(),
        engine_config: z.optional(z.object({
            pg: z.object({
                autovacuum_analyze_scale_factor: z.number().gte(0).lte(1).default(0.2),
                autovacuum_analyze_threshold: z.int().gte(0).lte(2147483647).default(50),
                autovacuum_max_workers: z.int().gte(1).lte(20).default(3),
                autovacuum_naptime: z.int().gte(1).lte(86400).default(60),
                autovacuum_vacuum_cost_delay: z.int().gte(-1).lte(100).default(20),
                autovacuum_vacuum_cost_limit: z.int().gte(-1).lte(10000).default(-1),
                autovacuum_vacuum_scale_factor: z.number().gte(0).lte(1).default(0.2),
                autovacuum_vacuum_threshold: z.int().gte(0).lte(2147483647).default(50),
                bgwriter_delay: z.int().gte(20).lte(10000).default(200),
                bgwriter_flush_after: z.int().gte(0).lte(2048).default(512),
                bgwriter_lru_maxpages: z.int().gte(0).lte(1073741823).default(100),
                bgwriter_lru_multiplier: z.number().gte(0).lte(10).default(2.5),
                deadlock_timeout: z.int().gte(500).lte(1800000),
                default_toast_compression: z.enum(['lz4', 'pglz']),
                idle_in_transaction_session_timeout: z.int().gte(0).lte(604800000),
                jit: z.boolean(),
                max_files_per_process: z.int().gte(1000).lte(4096),
                max_locks_per_transaction: z.int().gte(64).lte(6400),
                max_logical_replication_workers: z.int().gte(4).lte(64),
                max_parallel_workers: z.int().gte(0).lte(96),
                max_parallel_workers_per_gather: z.int().gte(0).lte(96),
                max_pred_locks_per_transaction: z.int().gte(64).lte(5120),
                max_replication_slots: z.int().gte(8).lte(64),
                max_slot_wal_keep_size: z.int().gte(-1).lte(2147483647).default(-1),
                max_stack_depth: z.int().gte(2097152).lte(6291456),
                max_standby_archive_delay: z.int().gte(1).lte(43200000),
                max_standby_streaming_delay: z.int().gte(1).lte(43200000),
                max_wal_senders: z.int().gte(20).lte(64),
                max_worker_processes: z.int().gte(8).lte(96),
                password_encryption: z.enum(['scram-sh-256', 'md5']),
                'pg_partman_bgw.interval': z.int().gte(3600).lte(604800),
                'pg_partman_bgw.role': z.string(),
                'pg_stat_monitor.pgsm_enable_query_plan': z.boolean(),
                'pg_stat_monitor.pgsm_max_buckets': z.int().gte(1).lte(10),
                'pg_stat_statements.track': z.enum([
                    'all',
                    'top',
                    'none'
                ]),
                temp_file_limit: z.int().gte(-1).lte(2147483647),
                timezone: z.string().max(64).regex(/^[\\w\/]*$/),
                track_activity_query_size: z.int().gte(1024).lte(10240),
                track_commit_timestamp: z.enum(['on', 'off']),
                track_functions: z.enum([
                    'all',
                    'pl',
                    'none'
                ]),
                track_io_timing: z.enum(['on', 'off']),
                wal_sender_timeout: z.int().gte(0).lte(60000),
                wal_writer_delay: z.int().gte(10).lte(200).default(200)
            }),
            pg_stat_monitor_enable: z.boolean(),
            pglookout: z.object({
                max_failover_replication_time_lag: z.int().gte(10).lte(999999)
            }),
            shared_buffers_percentage: z.number().gte(20).lte(60),
            work_mem: z.int().gte(1).lte(4)
        })),
        fork: z.optional(z.object({
            restore_time: z.optional(z.iso.datetime()),
            source: z.int()
        })),
        label: z.string().min(3).max(32),
        private_network: z.optional(z.union([
            z.object({
                public_access: z.boolean().default(false),
                subnet_id: z.int(),
                vpc_id: z.int()
            }),
            z.null()
        ])),
        region: z.string(),
        ssl_connection: z.optional(z.boolean()).default(true),
        type: z.string()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Managed PostgreSQL Databases object.
 */
export const postDatabasesPostgreSqlInstancesResponseSchema = z.object({
    allow_list: z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0),
    cluster_size: z.union([
        z.literal(1),
        z.literal(2),
        z.literal(3)
    ]),
    created: z.iso.datetime().readonly(),
    encrypted: z.boolean().readonly().default(true),
    engine: z.string().readonly(),
    engine_config: z.object({
        pg: z.object({
            autovacuum_analyze_scale_factor: z.number().gte(0).lte(1).default(0.2),
            autovacuum_analyze_threshold: z.int().gte(0).lte(2147483647).default(50),
            autovacuum_max_workers: z.int().gte(1).lte(20).default(3),
            autovacuum_naptime: z.int().gte(1).lte(86400).default(60),
            autovacuum_vacuum_cost_delay: z.int().gte(-1).lte(100).default(20),
            autovacuum_vacuum_cost_limit: z.int().gte(-1).lte(10000).default(-1),
            autovacuum_vacuum_scale_factor: z.number().gte(0).lte(1).default(0.2),
            autovacuum_vacuum_threshold: z.int().gte(0).lte(2147483647).default(50),
            bgwriter_delay: z.int().gte(20).lte(10000).default(200),
            bgwriter_flush_after: z.int().gte(0).lte(2048).default(512),
            bgwriter_lru_maxpages: z.int().gte(0).lte(1073741823).default(100),
            bgwriter_lru_multiplier: z.number().gte(0).lte(10).default(2.5),
            deadlock_timeout: z.int().gte(500).lte(1800000),
            default_toast_compression: z.enum(['lz4', 'pglz']),
            idle_in_transaction_session_timeout: z.int().gte(0).lte(604800000),
            jit: z.boolean(),
            max_files_per_process: z.int().gte(1000).lte(4096),
            max_locks_per_transaction: z.int().gte(64).lte(6400),
            max_logical_replication_workers: z.int().gte(4).lte(64),
            max_parallel_workers: z.int().gte(0).lte(96),
            max_parallel_workers_per_gather: z.int().gte(0).lte(96),
            max_pred_locks_per_transaction: z.int().gte(64).lte(5120),
            max_replication_slots: z.int().gte(8).lte(64),
            max_slot_wal_keep_size: z.int().gte(-1).lte(2147483647).default(-1),
            max_stack_depth: z.int().gte(2097152).lte(6291456),
            max_standby_archive_delay: z.int().gte(1).lte(43200000),
            max_standby_streaming_delay: z.int().gte(1).lte(43200000),
            max_wal_senders: z.int().gte(20).lte(64),
            max_worker_processes: z.int().gte(8).lte(96),
            password_encryption: z.enum(['scram-sh-256', 'md5']),
            'pg_partman_bgw.interval': z.int().gte(3600).lte(604800),
            'pg_partman_bgw.role': z.string(),
            'pg_stat_monitor.pgsm_enable_query_plan': z.boolean(),
            'pg_stat_monitor.pgsm_max_buckets': z.int().gte(1).lte(10),
            'pg_stat_statements.track': z.enum([
                'all',
                'top',
                'none'
            ]),
            temp_file_limit: z.int().gte(-1).lte(2147483647),
            timezone: z.string().max(64).regex(/^[\\w\/]*$/),
            track_activity_query_size: z.int().gte(1024).lte(10240),
            track_commit_timestamp: z.enum(['on', 'off']),
            track_functions: z.enum([
                'all',
                'pl',
                'none'
            ]),
            track_io_timing: z.enum(['on', 'off']),
            wal_sender_timeout: z.int().gte(0).lte(60000),
            wal_writer_delay: z.int().gte(10).lte(200).default(200)
        }),
        pg_stat_monitor_enable: z.boolean(),
        pglookout: z.object({
            max_failover_replication_time_lag: z.int().gte(10).lte(999999)
        }),
        shared_buffers_percentage: z.number().gte(20).lte(60),
        work_mem: z.int().gte(1).lte(4)
    }),
    fork: z.object({
        restore_time: z.iso.datetime(),
        source: z.int()
    }),
    hosts: z.object({
        primary: z.union([
            z.string(),
            z.null()
        ]),
        secondary: z.union([
            z.string(),
            z.null()
        ])
    }).readonly(),
    id: z.int().readonly(),
    label: z.string().min(3).max(32),
    members: z.record(z.string(), z.unknown()).readonly(),
    platform: z.enum(['rdbms-legacy', 'rdbms-default']),
    port: z.int().readonly(),
    region: z.string(),
    ssl_connection: z.boolean().default(true),
    status: z.enum([
        'provisioning',
        'active',
        'suspending',
        'suspended',
        'resuming',
        'failed',
        'degraded',
        'updating',
        'resizing'
    ]),
    total_disk_size_gb: z.int().readonly(),
    type: z.string(),
    updated: z.iso.datetime().readonly(),
    updates: z.object({
        day_of_week: z.int().gte(1).lte(7),
        duration: z.int().gte(1).lte(3),
        frequency: z.enum(['weekly']),
        hour_of_day: z.int().gte(0).lte(23),
        pending: z.array(z.object({
            deadline: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            description: z.string(),
            planned_for: z.union([
                z.iso.datetime(),
                z.null()
            ])
        })).min(0).readonly()
    }),
    used_disk_size_gb: z.int().readonly(),
    version: z.string()
});

export const deleteDatabasesPostgreSqlInstanceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteDatabasesPostgreSqlInstanceResponseSchema = z.record(z.string(), z.unknown());

export const getDatabasesPostgreSqlInstanceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Managed PostgreSQL Databases object.
 */
export const getDatabasesPostgreSqlInstanceResponseSchema = z.object({
    allow_list: z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0),
    cluster_size: z.union([
        z.literal(1),
        z.literal(2),
        z.literal(3)
    ]),
    created: z.iso.datetime().readonly(),
    encrypted: z.boolean().readonly().default(true),
    engine: z.string().readonly(),
    engine_config: z.object({
        pg: z.object({
            autovacuum_analyze_scale_factor: z.number().gte(0).lte(1).default(0.2),
            autovacuum_analyze_threshold: z.int().gte(0).lte(2147483647).default(50),
            autovacuum_max_workers: z.int().gte(1).lte(20).default(3),
            autovacuum_naptime: z.int().gte(1).lte(86400).default(60),
            autovacuum_vacuum_cost_delay: z.int().gte(-1).lte(100).default(20),
            autovacuum_vacuum_cost_limit: z.int().gte(-1).lte(10000).default(-1),
            autovacuum_vacuum_scale_factor: z.number().gte(0).lte(1).default(0.2),
            autovacuum_vacuum_threshold: z.int().gte(0).lte(2147483647).default(50),
            bgwriter_delay: z.int().gte(20).lte(10000).default(200),
            bgwriter_flush_after: z.int().gte(0).lte(2048).default(512),
            bgwriter_lru_maxpages: z.int().gte(0).lte(1073741823).default(100),
            bgwriter_lru_multiplier: z.number().gte(0).lte(10).default(2.5),
            deadlock_timeout: z.int().gte(500).lte(1800000),
            default_toast_compression: z.enum(['lz4', 'pglz']),
            idle_in_transaction_session_timeout: z.int().gte(0).lte(604800000),
            jit: z.boolean(),
            max_files_per_process: z.int().gte(1000).lte(4096),
            max_locks_per_transaction: z.int().gte(64).lte(6400),
            max_logical_replication_workers: z.int().gte(4).lte(64),
            max_parallel_workers: z.int().gte(0).lte(96),
            max_parallel_workers_per_gather: z.int().gte(0).lte(96),
            max_pred_locks_per_transaction: z.int().gte(64).lte(5120),
            max_replication_slots: z.int().gte(8).lte(64),
            max_slot_wal_keep_size: z.int().gte(-1).lte(2147483647).default(-1),
            max_stack_depth: z.int().gte(2097152).lte(6291456),
            max_standby_archive_delay: z.int().gte(1).lte(43200000),
            max_standby_streaming_delay: z.int().gte(1).lte(43200000),
            max_wal_senders: z.int().gte(20).lte(64),
            max_worker_processes: z.int().gte(8).lte(96),
            password_encryption: z.enum(['scram-sh-256', 'md5']),
            'pg_partman_bgw.interval': z.int().gte(3600).lte(604800),
            'pg_partman_bgw.role': z.string(),
            'pg_stat_monitor.pgsm_enable_query_plan': z.boolean(),
            'pg_stat_monitor.pgsm_max_buckets': z.int().gte(1).lte(10),
            'pg_stat_statements.track': z.enum([
                'all',
                'top',
                'none'
            ]),
            temp_file_limit: z.int().gte(-1).lte(2147483647),
            timezone: z.string().max(64).regex(/^[\\w\/]*$/),
            track_activity_query_size: z.int().gte(1024).lte(10240),
            track_commit_timestamp: z.enum(['on', 'off']),
            track_functions: z.enum([
                'all',
                'pl',
                'none'
            ]),
            track_io_timing: z.enum(['on', 'off']),
            wal_sender_timeout: z.int().gte(0).lte(60000),
            wal_writer_delay: z.int().gte(10).lte(200).default(200)
        }),
        pg_stat_monitor_enable: z.boolean(),
        pglookout: z.object({
            max_failover_replication_time_lag: z.int().gte(10).lte(999999)
        }),
        shared_buffers_percentage: z.number().gte(20).lte(60),
        work_mem: z.int().gte(1).lte(4)
    }),
    fork: z.object({
        restore_time: z.iso.datetime(),
        source: z.int()
    }),
    hosts: z.object({
        primary: z.union([
            z.string(),
            z.null()
        ]),
        secondary: z.union([
            z.string(),
            z.null()
        ])
    }).readonly(),
    id: z.int().readonly(),
    label: z.string().min(3).max(32),
    members: z.record(z.string(), z.unknown()).readonly(),
    oldest_restore_time: z.iso.datetime().readonly(),
    platform: z.enum(['rdbms-legacy', 'rdbms-default']),
    port: z.int().readonly(),
    private_network: z.union([
        z.object({
            public_access: z.boolean().default(false),
            subnet_id: z.int(),
            vpc_id: z.int()
        }),
        z.null()
    ]),
    region: z.string(),
    ssl_connection: z.boolean().default(true),
    status: z.enum([
        'provisioning',
        'active',
        'suspending',
        'suspended',
        'resuming',
        'failed',
        'degraded',
        'updating',
        'resizing'
    ]),
    total_disk_size_gb: z.int().readonly(),
    type: z.string(),
    updated: z.iso.datetime().readonly(),
    updates: z.object({
        day_of_week: z.int().gte(1).lte(7),
        duration: z.int().gte(1).lte(3),
        frequency: z.enum(['weekly']),
        hour_of_day: z.int().gte(0).lte(23),
        pending: z.array(z.object({
            deadline: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            description: z.string(),
            planned_for: z.union([
                z.iso.datetime(),
                z.null()
            ])
        })).min(0).readonly()
    }),
    used_disk_size_gb: z.int().readonly(),
    version: z.string()
});

export const putDatabasesPostgreSqlInstanceRequestSchema = z.object({
    body: z.object({
        allow_list: z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0),
        engine_config: z.object({
            pg: z.object({
                autovacuum_analyze_scale_factor: z.number().gte(0).lte(1).default(0.2),
                autovacuum_analyze_threshold: z.int().gte(0).lte(2147483647).default(50),
                autovacuum_max_workers: z.int().gte(1).lte(20).default(3),
                autovacuum_naptime: z.int().gte(1).lte(86400).default(60),
                autovacuum_vacuum_cost_delay: z.int().gte(-1).lte(100).default(20),
                autovacuum_vacuum_cost_limit: z.int().gte(-1).lte(10000).default(-1),
                autovacuum_vacuum_scale_factor: z.number().gte(0).lte(1).default(0.2),
                autovacuum_vacuum_threshold: z.int().gte(0).lte(2147483647).default(50),
                bgwriter_delay: z.int().gte(20).lte(10000).default(200),
                bgwriter_flush_after: z.int().gte(0).lte(2048).default(512),
                bgwriter_lru_maxpages: z.int().gte(0).lte(1073741823).default(100),
                bgwriter_lru_multiplier: z.number().gte(0).lte(10).default(2.5),
                deadlock_timeout: z.int().gte(500).lte(1800000),
                default_toast_compression: z.enum(['lz4', 'pglz']),
                idle_in_transaction_session_timeout: z.int().gte(0).lte(604800000),
                jit: z.boolean(),
                max_files_per_process: z.int().gte(1000).lte(4096),
                max_locks_per_transaction: z.int().gte(64).lte(6400),
                max_logical_replication_workers: z.int().gte(4).lte(64),
                max_parallel_workers: z.int().gte(0).lte(96),
                max_parallel_workers_per_gather: z.int().gte(0).lte(96),
                max_pred_locks_per_transaction: z.int().gte(64).lte(5120),
                max_replication_slots: z.int().gte(8).lte(64),
                max_slot_wal_keep_size: z.int().gte(-1).lte(2147483647).default(-1),
                max_stack_depth: z.int().gte(2097152).lte(6291456),
                max_standby_archive_delay: z.int().gte(1).lte(43200000),
                max_standby_streaming_delay: z.int().gte(1).lte(43200000),
                max_wal_senders: z.int().gte(20).lte(64),
                max_worker_processes: z.int().gte(8).lte(96),
                password_encryption: z.enum(['scram-sh-256', 'md5']),
                'pg_partman_bgw.interval': z.int().gte(3600).lte(604800),
                'pg_partman_bgw.role': z.string(),
                'pg_stat_monitor.pgsm_enable_query_plan': z.boolean(),
                'pg_stat_monitor.pgsm_max_buckets': z.int().gte(1).lte(10),
                'pg_stat_statements.track': z.enum([
                    'all',
                    'top',
                    'none'
                ]),
                temp_file_limit: z.int().gte(-1).lte(2147483647),
                timezone: z.string().max(64).regex(/^[\\w\/]*$/),
                track_activity_query_size: z.int().gte(1024).lte(10240),
                track_commit_timestamp: z.enum(['on', 'off']),
                track_functions: z.enum([
                    'all',
                    'pl',
                    'none'
                ]),
                track_io_timing: z.enum(['on', 'off']),
                wal_sender_timeout: z.int().gte(0).lte(60000),
                wal_writer_delay: z.int().gte(10).lte(200).default(200)
            }),
            pg_stat_monitor_enable: z.boolean(),
            pglookout: z.object({
                max_failover_replication_time_lag: z.int().gte(10).lte(999999)
            }),
            shared_buffers_percentage: z.number().gte(20).lte(60),
            work_mem: z.int().gte(1).lte(4)
        }),
        label: z.string().min(3).max(32),
        private_network: z.union([
            z.object({
                public_access: z.boolean().default(false),
                subnet_id: z.int(),
                vpc_id: z.int()
            }),
            z.null()
        ]),
        type: z.string(),
        updates: z.object({
            day_of_week: z.int().gte(1).lte(7),
            duration: z.int().gte(1).lte(3),
            frequency: z.enum(['weekly']),
            hour_of_day: z.int().gte(0).lte(23),
            pending: z.array(z.object({
                deadline: z.union([
                    z.iso.datetime(),
                    z.null()
                ]),
                description: z.string(),
                planned_for: z.union([
                    z.iso.datetime(),
                    z.null()
                ])
            })).min(0).readonly()
        }),
        version: z.string()
    }),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Managed PostgreSQL Databases object.
 */
export const putDatabasesPostgreSqlInstanceResponseSchema = z.object({
    allow_list: z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0),
    cluster_size: z.union([
        z.literal(1),
        z.literal(2),
        z.literal(3)
    ]),
    created: z.iso.datetime().readonly(),
    encrypted: z.boolean().readonly().default(true),
    engine: z.string().readonly(),
    engine_config: z.object({
        pg: z.object({
            autovacuum_analyze_scale_factor: z.number().gte(0).lte(1).default(0.2),
            autovacuum_analyze_threshold: z.int().gte(0).lte(2147483647).default(50),
            autovacuum_max_workers: z.int().gte(1).lte(20).default(3),
            autovacuum_naptime: z.int().gte(1).lte(86400).default(60),
            autovacuum_vacuum_cost_delay: z.int().gte(-1).lte(100).default(20),
            autovacuum_vacuum_cost_limit: z.int().gte(-1).lte(10000).default(-1),
            autovacuum_vacuum_scale_factor: z.number().gte(0).lte(1).default(0.2),
            autovacuum_vacuum_threshold: z.int().gte(0).lte(2147483647).default(50),
            bgwriter_delay: z.int().gte(20).lte(10000).default(200),
            bgwriter_flush_after: z.int().gte(0).lte(2048).default(512),
            bgwriter_lru_maxpages: z.int().gte(0).lte(1073741823).default(100),
            bgwriter_lru_multiplier: z.number().gte(0).lte(10).default(2.5),
            deadlock_timeout: z.int().gte(500).lte(1800000),
            default_toast_compression: z.enum(['lz4', 'pglz']),
            idle_in_transaction_session_timeout: z.int().gte(0).lte(604800000),
            jit: z.boolean(),
            max_files_per_process: z.int().gte(1000).lte(4096),
            max_locks_per_transaction: z.int().gte(64).lte(6400),
            max_logical_replication_workers: z.int().gte(4).lte(64),
            max_parallel_workers: z.int().gte(0).lte(96),
            max_parallel_workers_per_gather: z.int().gte(0).lte(96),
            max_pred_locks_per_transaction: z.int().gte(64).lte(5120),
            max_replication_slots: z.int().gte(8).lte(64),
            max_slot_wal_keep_size: z.int().gte(-1).lte(2147483647).default(-1),
            max_stack_depth: z.int().gte(2097152).lte(6291456),
            max_standby_archive_delay: z.int().gte(1).lte(43200000),
            max_standby_streaming_delay: z.int().gte(1).lte(43200000),
            max_wal_senders: z.int().gte(20).lte(64),
            max_worker_processes: z.int().gte(8).lte(96),
            password_encryption: z.enum(['scram-sh-256', 'md5']),
            'pg_partman_bgw.interval': z.int().gte(3600).lte(604800),
            'pg_partman_bgw.role': z.string(),
            'pg_stat_monitor.pgsm_enable_query_plan': z.boolean(),
            'pg_stat_monitor.pgsm_max_buckets': z.int().gte(1).lte(10),
            'pg_stat_statements.track': z.enum([
                'all',
                'top',
                'none'
            ]),
            temp_file_limit: z.int().gte(-1).lte(2147483647),
            timezone: z.string().max(64).regex(/^[\\w\/]*$/),
            track_activity_query_size: z.int().gte(1024).lte(10240),
            track_commit_timestamp: z.enum(['on', 'off']),
            track_functions: z.enum([
                'all',
                'pl',
                'none'
            ]),
            track_io_timing: z.enum(['on', 'off']),
            wal_sender_timeout: z.int().gte(0).lte(60000),
            wal_writer_delay: z.int().gte(10).lte(200).default(200)
        }),
        pg_stat_monitor_enable: z.boolean(),
        pglookout: z.object({
            max_failover_replication_time_lag: z.int().gte(10).lte(999999)
        }),
        shared_buffers_percentage: z.number().gte(20).lte(60),
        work_mem: z.int().gte(1).lte(4)
    }),
    fork: z.object({
        restore_time: z.iso.datetime(),
        source: z.int()
    }),
    hosts: z.object({
        primary: z.union([
            z.string(),
            z.null()
        ]),
        secondary: z.union([
            z.string(),
            z.null()
        ])
    }).readonly(),
    id: z.int().readonly(),
    label: z.string().min(3).max(32),
    members: z.record(z.string(), z.unknown()).readonly(),
    oldest_restore_time: z.iso.datetime().readonly(),
    platform: z.enum(['rdbms-legacy', 'rdbms-default']),
    port: z.int().readonly(),
    private_network: z.union([
        z.object({
            public_access: z.boolean().default(false),
            subnet_id: z.int(),
            vpc_id: z.int()
        }),
        z.null()
    ]),
    region: z.string(),
    ssl_connection: z.boolean().default(true),
    status: z.enum([
        'provisioning',
        'active',
        'suspending',
        'suspended',
        'resuming',
        'failed',
        'degraded',
        'updating',
        'resizing'
    ]),
    total_disk_size_gb: z.int().readonly(),
    type: z.string(),
    updated: z.iso.datetime().readonly(),
    updates: z.object({
        day_of_week: z.int().gte(1).lte(7),
        duration: z.int().gte(1).lte(3),
        frequency: z.enum(['weekly']),
        hour_of_day: z.int().gte(0).lte(23),
        pending: z.array(z.object({
            deadline: z.union([
                z.iso.datetime(),
                z.null()
            ]),
            description: z.string(),
            planned_for: z.union([
                z.iso.datetime(),
                z.null()
            ])
        })).min(0).readonly()
    }),
    used_disk_size_gb: z.int().readonly(),
    version: z.string()
});

export const getDatabasesPostgreSqlInstanceCredentialsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Managed Database object for database credentials.
 */
export const getDatabasesPostgreSqlInstanceCredentialsResponseSchema = z.object({
    password: z.string().readonly(),
    username: z.string().readonly()
});

export const postDatabasesPostgreSqlInstanceCredentialsResetRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postDatabasesPostgreSqlInstanceCredentialsResetResponseSchema = z.record(z.string(), z.unknown());

export const postDatabasesPostgreSqlInstancePatchRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postDatabasesPostgreSqlInstancePatchResponseSchema = z.record(z.string(), z.unknown());

export const resumeDatabasesPostgreSqlInstanceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const resumeDatabasesPostgreSqlInstanceResponseSchema = z.record(z.string(), z.unknown());

export const getDatabasesPostgresqlInstanceSslRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Managed Database SSL object.
 */
export const getDatabasesPostgresqlInstanceSslResponseSchema = z.object({
    ca_certificate: z.string()
});

export const suspendDatabasesPostgreSqlInstanceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        instanceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const suspendDatabasesPostgreSqlInstanceResponseSchema = z.record(z.string(), z.unknown());

export const getDatabasesTypesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of all Managed Databases types.
 */
export const getDatabasesTypesResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.array(z.object({
        class: z.enum([
            'dedicated',
            'shared',
            'premium'
        ]),
        disk: z.int(),
        engines: z.object({
            mysql: z.array(z.object({
                price: z.object({
                    hourly: z.number(),
                    monthly: z.number()
                }),
                quantity: z.union([
                    z.literal(1),
                    z.literal(2),
                    z.literal(3)
                ])
            })),
            postgresql: z.array(z.object({
                price: z.object({
                    hourly: z.number(),
                    monthly: z.number()
                }),
                quantity: z.union([
                    z.literal(1),
                    z.literal(2),
                    z.literal(3)
                ])
            }))
        }),
        id: z.string().readonly(),
        label: z.string().readonly(),
        memory: z.int(),
        vcpus: z.int()
    }))
}));

export const getDatabasesTypeRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        typeId: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Managed Database plan type object.
 */
export const getDatabasesTypeResponseSchema = z.object({
    class: z.enum([
        'dedicated',
        'shared',
        'premium'
    ]),
    disk: z.int(),
    engines: z.object({
        mysql: z.array(z.object({
            price: z.object({
                hourly: z.number(),
                monthly: z.number()
            }),
            quantity: z.union([
                z.literal(1),
                z.literal(2),
                z.literal(3)
            ])
        })),
        postgresql: z.array(z.object({
            price: z.object({
                hourly: z.number(),
                monthly: z.number()
            }),
            quantity: z.union([
                z.literal(1),
                z.literal(2),
                z.literal(3)
            ])
        }))
    }),
    id: z.string().readonly(),
    label: z.string().readonly(),
    memory: z.int(),
    vcpus: z.int()
});

export const getDomainsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of Domains you have registered.
 */
export const getDomainsResponseSchema = z.object({
    data: z.array(z.object({
        axfr_ips: z.array(z.string()),
        description: z.union([
            z.string().min(1).max(253),
            z.null()
        ]),
        domain: z.string().min(1).max(253).regex(/^(\*\.)?([a-zA-Z0-9-_]{1,63}\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)$/),
        expire_sec: z.int().default(0),
        group: z.union([
            z.string().min(1).max(50),
            z.null()
        ]),
        id: z.int().readonly(),
        master_ips: z.array(z.string()),
        refresh_sec: z.int().default(0),
        retry_sec: z.int().default(0),
        soa_email: z.email(),
        status: z.enum(['disabled', 'active']),
        tags: z.array(z.string()),
        ttl_sec: z.int().default(0),
        type: z.enum(['master', 'slave'])
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postDomainRequestSchema = z.object({
    body: z.object({
        axfr_ips: z.array(z.string()),
        description: z.union([
            z.string().min(1).max(253),
            z.null()
        ]),
        domain: z.string().min(1).max(253).regex(/^(\*\.)?([a-zA-Z0-9-_]{1,63}\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)$/),
        expire_sec: z.int().default(0),
        group: z.union([
            z.string().min(1).max(50),
            z.null()
        ]),
        id: z.int().readonly(),
        master_ips: z.array(z.string()),
        refresh_sec: z.int().default(0),
        retry_sec: z.int().default(0),
        soa_email: z.email(),
        status: z.enum(['disabled', 'active']),
        tags: z.array(z.string()),
        ttl_sec: z.int().default(0),
        type: z.enum(['master', 'slave'])
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Domain
 *
 * A domain zonefile in our DNS system.  You must own the domain name and tell your registrar to use Linode's nameservers in order for a domain in our system to be treated as authoritative.
 */
export const postDomainResponseSchema = z.object({
    axfr_ips: z.array(z.string()),
    description: z.union([
        z.string().min(1).max(253),
        z.null()
    ]),
    domain: z.string().min(1).max(253).regex(/^(\*\.)?([a-zA-Z0-9-_]{1,63}\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)$/),
    expire_sec: z.int().default(0),
    group: z.union([
        z.string().min(1).max(50),
        z.null()
    ]),
    id: z.int().readonly(),
    master_ips: z.array(z.string()),
    refresh_sec: z.int().default(0),
    retry_sec: z.int().default(0),
    soa_email: z.email(),
    status: z.enum(['disabled', 'active']),
    tags: z.array(z.string()),
    ttl_sec: z.int().default(0),
    type: z.enum(['master', 'slave'])
});

export const postImportDomainRequestSchema = z.object({
    body: z.optional(z.object({
        domain: z.string(),
        remote_nameserver: z.string()
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Domain
 *
 * A domain zonefile in our DNS system.  You must own the domain name and tell your registrar to use Linode's nameservers in order for a domain in our system to be treated as authoritative.
 */
export const postImportDomainResponseSchema = z.object({
    axfr_ips: z.array(z.string()),
    description: z.union([
        z.string().min(1).max(253),
        z.null()
    ]),
    domain: z.string().min(1).max(253).regex(/^(\*\.)?([a-zA-Z0-9-_]{1,63}\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)$/),
    expire_sec: z.int().default(0),
    group: z.union([
        z.string().min(1).max(50),
        z.null()
    ]),
    id: z.int().readonly(),
    master_ips: z.array(z.string()),
    refresh_sec: z.int().default(0),
    retry_sec: z.int().default(0),
    soa_email: z.email(),
    status: z.enum(['disabled', 'active']),
    tags: z.array(z.string()),
    ttl_sec: z.int().default(0),
    type: z.enum(['master', 'slave'])
});

export const deleteDomainRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        domainId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteDomainResponseSchema = z.record(z.string(), z.unknown());

export const getDomainRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        domainId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Domain
 *
 * A domain zonefile in our DNS system.  You must own the domain name and tell your registrar to use Linode's nameservers in order for a domain in our system to be treated as authoritative.
 */
export const getDomainResponseSchema = z.object({
    axfr_ips: z.array(z.string()),
    description: z.union([
        z.string().min(1).max(253),
        z.null()
    ]),
    domain: z.string().min(1).max(253).regex(/^(\*\.)?([a-zA-Z0-9-_]{1,63}\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)$/),
    expire_sec: z.int().default(0),
    group: z.union([
        z.string().min(1).max(50),
        z.null()
    ]),
    id: z.int().readonly(),
    master_ips: z.array(z.string()),
    refresh_sec: z.int().default(0),
    retry_sec: z.int().default(0),
    soa_email: z.email(),
    status: z.enum(['disabled', 'active']),
    tags: z.array(z.string()),
    ttl_sec: z.int().default(0),
    type: z.enum(['master', 'slave'])
});

export const putDomainRequestSchema = z.object({
    body: z.object({
        axfr_ips: z.array(z.string()),
        description: z.union([
            z.string().min(1).max(253),
            z.null()
        ]),
        domain: z.string().min(1).max(253).regex(/^(\*\.)?([a-zA-Z0-9-_]{1,63}\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)$/),
        expire_sec: z.int().default(0),
        group: z.union([
            z.string().min(1).max(50),
            z.null()
        ]),
        id: z.int().readonly(),
        master_ips: z.array(z.string()),
        refresh_sec: z.int().default(0),
        retry_sec: z.int().default(0),
        soa_email: z.email(),
        status: z.enum(['disabled', 'active']),
        tags: z.array(z.string()),
        ttl_sec: z.int().default(0),
        type: z.enum(['master', 'slave'])
    }),
    path: z.object({
        domainId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Domain
 *
 * A domain zonefile in our DNS system.  You must own the domain name and tell your registrar to use Linode's nameservers in order for a domain in our system to be treated as authoritative.
 */
export const putDomainResponseSchema = z.object({
    axfr_ips: z.array(z.string()),
    description: z.union([
        z.string().min(1).max(253),
        z.null()
    ]),
    domain: z.string().min(1).max(253).regex(/^(\*\.)?([a-zA-Z0-9-_]{1,63}\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)$/),
    expire_sec: z.int().default(0),
    group: z.union([
        z.string().min(1).max(50),
        z.null()
    ]),
    id: z.int().readonly(),
    master_ips: z.array(z.string()),
    refresh_sec: z.int().default(0),
    retry_sec: z.int().default(0),
    soa_email: z.email(),
    status: z.enum(['disabled', 'active']),
    tags: z.array(z.string()),
    ttl_sec: z.int().default(0),
    type: z.enum(['master', 'slave'])
});

export const postCloneDomainRequestSchema = z.object({
    body: z.object({
        domain: z.string().min(1).max(253).regex(/^(\*\.)?([a-zA-Z0-9-_]{1,63}\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)$/)
    }),
    path: z.object({
        domainId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Domain
 *
 * A domain zonefile in our DNS system.  You must own the domain name and tell your registrar to use Linode's nameservers in order for a domain in our system to be treated as authoritative.
 */
export const postCloneDomainResponseSchema = z.object({
    axfr_ips: z.array(z.string()),
    description: z.union([
        z.string().min(1).max(253),
        z.null()
    ]),
    domain: z.string().min(1).max(253).regex(/^(\*\.)?([a-zA-Z0-9-_]{1,63}\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)$/),
    expire_sec: z.int().default(0),
    group: z.union([
        z.string().min(1).max(50),
        z.null()
    ]),
    id: z.int().readonly(),
    master_ips: z.array(z.string()),
    refresh_sec: z.int().default(0),
    retry_sec: z.int().default(0),
    soa_email: z.email(),
    status: z.enum(['disabled', 'active']),
    tags: z.array(z.string()),
    ttl_sec: z.int().default(0),
    type: z.enum(['master', 'slave'])
});

export const getDomainRecordsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        domainId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A list of Domain Records.
 */
export const getDomainRecordsResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        name: z.string().min(1).max(100),
        port: z.int().gte(0).lte(65535),
        priority: z.int().gte(0).lte(255),
        protocol: z.union([
            z.string(),
            z.null()
        ]),
        service: z.union([
            z.string(),
            z.null()
        ]),
        tag: z.enum([
            'issue',
            'issuewild',
            'iodef'
        ]),
        target: z.string().max(65535),
        ttl_sec: z.int(),
        type: z.enum([
            'A',
            'AAAA',
            'NS',
            'MX',
            'CNAME',
            'TXT',
            'SRV',
            'PTR',
            'CAA'
        ]),
        updated: z.iso.datetime().readonly(),
        weight: z.int().gte(0).lte(65535)
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postDomainRecordRequestSchema = z.object({
    body: z.object({
        created: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        name: z.string().min(1).max(100),
        port: z.int().gte(0).lte(65535),
        priority: z.int().gte(0).lte(255),
        protocol: z.union([
            z.string(),
            z.null()
        ]),
        service: z.union([
            z.string(),
            z.null()
        ]),
        tag: z.enum([
            'issue',
            'issuewild',
            'iodef'
        ]),
        target: z.string().max(65535),
        ttl_sec: z.int(),
        type: z.enum([
            'A',
            'AAAA',
            'NS',
            'MX',
            'CNAME',
            'TXT',
            'SRV',
            'PTR',
            'CAA'
        ]),
        updated: z.iso.datetime().readonly(),
        weight: z.int().gte(0).lte(65535)
    }),
    path: z.object({
        domainId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A single record on a Domain.
 */
export const postDomainRecordResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    name: z.string().min(1).max(100),
    port: z.int().gte(0).lte(65535),
    priority: z.int().gte(0).lte(255),
    protocol: z.union([
        z.string(),
        z.null()
    ]),
    service: z.union([
        z.string(),
        z.null()
    ]),
    tag: z.enum([
        'issue',
        'issuewild',
        'iodef'
    ]),
    target: z.string().max(65535),
    ttl_sec: z.int(),
    type: z.enum([
        'A',
        'AAAA',
        'NS',
        'MX',
        'CNAME',
        'TXT',
        'SRV',
        'PTR',
        'CAA'
    ]),
    updated: z.iso.datetime().readonly(),
    weight: z.int().gte(0).lte(65535)
});

export const deleteDomainRecordRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        domainId: z.int(),
        recordId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteDomainRecordResponseSchema = z.record(z.string(), z.unknown());

export const getDomainRecordRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        domainId: z.int(),
        recordId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A single record on a Domain.
 */
export const getDomainRecordResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    name: z.string().min(1).max(100),
    port: z.int().gte(0).lte(65535),
    priority: z.int().gte(0).lte(255),
    protocol: z.union([
        z.string(),
        z.null()
    ]),
    service: z.union([
        z.string(),
        z.null()
    ]),
    tag: z.enum([
        'issue',
        'issuewild',
        'iodef'
    ]),
    target: z.string().max(65535),
    ttl_sec: z.int(),
    type: z.enum([
        'A',
        'AAAA',
        'NS',
        'MX',
        'CNAME',
        'TXT',
        'SRV',
        'PTR',
        'CAA'
    ]),
    updated: z.iso.datetime().readonly(),
    weight: z.int().gte(0).lte(65535)
});

export const putDomainRecordRequestSchema = z.object({
    body: z.object({
        name: z.string().min(1).max(100),
        port: z.int().gte(0).lte(65535),
        priority: z.int().gte(0).lte(255),
        protocol: z.union([
            z.string(),
            z.null()
        ]),
        service: z.union([
            z.string(),
            z.null()
        ]),
        tag: z.enum([
            'issue',
            'issuewild',
            'iodef'
        ]),
        target: z.string().max(65535),
        ttl_sec: z.int(),
        weight: z.int().gte(0).lte(65535)
    }),
    path: z.object({
        domainId: z.int(),
        recordId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A single record on a Domain.
 */
export const putDomainRecordResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    name: z.string().min(1).max(100),
    port: z.int().gte(0).lte(65535),
    priority: z.int().gte(0).lte(255),
    protocol: z.union([
        z.string(),
        z.null()
    ]),
    service: z.union([
        z.string(),
        z.null()
    ]),
    tag: z.enum([
        'issue',
        'issuewild',
        'iodef'
    ]),
    target: z.string().max(65535),
    ttl_sec: z.int(),
    type: z.enum([
        'A',
        'AAAA',
        'NS',
        'MX',
        'CNAME',
        'TXT',
        'SRV',
        'PTR',
        'CAA'
    ]),
    updated: z.iso.datetime().readonly(),
    weight: z.int().gte(0).lte(65535)
});

export const getDomainZoneRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        domainId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * An array containing the lines of the domain zone file.
 */
export const getDomainZoneResponseSchema = z.object({
    zone_file: z.array(z.string())
});

export const getImagesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of images.
 */
export const getImagesResponseSchema = z.object({
    data: z.array(z.object({
        capabilities: z.array(z.string()).readonly(),
        created: z.iso.datetime().readonly(),
        created_by: z.string().readonly(),
        deprecated: z.boolean().readonly(),
        description: z.union([
            z.string().min(1).max(65000),
            z.null()
        ]),
        eol: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        expiry: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        id: z.string().readonly(),
        image_sharing: z.union([
            z.object({
                shared_by: z.union([
                    z.record(z.string(), z.unknown()),
                    z.null()
                ]),
                shared_with: z.object({
                    sharegroup_count: z.int(),
                    sharegroup_list_url: z.string()
                })
            }),
            z.object({
                shared_by: z.object({
                    sharegroup_id: z.int(),
                    sharegroup_label: z.string(),
                    sharegroup_uuid: z.uuid(),
                    source_image_id: z.union([
                        z.string(),
                        z.null()
                    ])
                }),
                shared_with: z.union([
                    z.record(z.string(), z.unknown()),
                    z.null()
                ])
            })
        ]),
        is_public: z.boolean().readonly(),
        is_shared: z.union([
            z.literal(true),
            z.literal(false),
            z.literal('none')
        ]),
        label: z.string(),
        regions: z.array(z.object({
            region: z.string(),
            status: z.enum([
                'available',
                'creating',
                'pending',
                'pending deletion',
                'pending replication',
                'replicating'
            ])
        })).readonly(),
        size: z.int().readonly(),
        status: z.enum([
            'creating',
            'pending_upload',
            'available'
        ]),
        tags: z.array(z.string().min(3).max(100)).min(0).max(500),
        total_size: z.int().readonly(),
        type: z.enum([
            'manual',
            'automatic',
            'shared'
        ]),
        updated: z.iso.datetime().readonly(),
        vendor: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postImageRequestSchema = z.object({
    body: z.optional(z.object({
        cloud_init: z.optional(z.boolean()),
        description: z.optional(z.string()),
        disk_id: z.int(),
        label: z.optional(z.string()),
        tags: z.optional(z.array(z.string().min(3).max(100)).min(0).max(500))
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Image object.
 */
export const postImageResponseSchema = z.object({
    capabilities: z.array(z.string()).readonly(),
    created: z.iso.datetime().readonly(),
    created_by: z.string().readonly(),
    deprecated: z.boolean().readonly(),
    description: z.union([
        z.string().min(1).max(65000),
        z.null()
    ]),
    eol: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    id: z.string().readonly(),
    image_sharing: z.union([
        z.object({
            shared_by: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ]),
            shared_with: z.object({
                sharegroup_count: z.int(),
                sharegroup_list_url: z.string()
            })
        }),
        z.object({
            shared_by: z.object({
                sharegroup_id: z.int(),
                sharegroup_label: z.string(),
                sharegroup_uuid: z.uuid(),
                source_image_id: z.union([
                    z.string(),
                    z.null()
                ])
            }),
            shared_with: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ])
        })
    ]),
    is_public: z.boolean().readonly(),
    is_shared: z.union([
        z.literal(true),
        z.literal(false),
        z.literal('none')
    ]),
    label: z.string(),
    regions: z.array(z.object({
        region: z.string(),
        status: z.enum([
            'available',
            'creating',
            'pending',
            'pending deletion',
            'pending replication',
            'replicating'
        ])
    })).readonly(),
    size: z.int().readonly(),
    status: z.enum([
        'creating',
        'pending_upload',
        'available'
    ]),
    tags: z.array(z.string().min(3).max(100)).min(0).max(500),
    total_size: z.int().readonly(),
    type: z.enum([
        'manual',
        'automatic',
        'shared'
    ]),
    updated: z.iso.datetime().readonly(),
    vendor: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const getSharegroupsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of sharegroups.
 */
export const getSharegroupsResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        expiry: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        id: z.int(),
        images_count: z.int().readonly(),
        is_suspended: z.boolean().readonly(),
        label: z.string(),
        members_count: z.int().readonly(),
        updated: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        uuid: z.uuid()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postSharegroupsRequestSchema = z.object({
    body: z.optional(z.object({
        description: z.optional(z.string()),
        images: z.optional(z.array(z.object({
            description: z.optional(z.string()),
            id: z.string(),
            label: z.optional(z.string())
        }))),
        label: z.string()
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The share group's details.
 */
export const postSharegroupsResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    id: z.int().readonly(),
    images_count: z.int().readonly(),
    is_suspended: z.boolean().readonly(),
    label: z.string(),
    members_count: z.int().readonly(),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    uuid: z.uuid().readonly()
});

export const getUserTokensRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of the tokens.
 */
export const getUserTokensResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        expiry: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        label: z.string(),
        sharegroup_label: z.string().readonly(),
        sharegroup_uuid: z.string().readonly(),
        status: z.enum([
            'pending',
            'active',
            'revoked',
            'expired'
        ]),
        token_uuid: z.string().readonly(),
        updated: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        valid_for_sharegroup_uuid: z.string().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postSharegroupTokensRequestSchema = z.object({
    body: z.optional(z.object({
        label: z.optional(z.string()),
        valid_for_sharegroup_uuid: z.string()
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The share group membership token's details.
 */
export const postSharegroupTokensResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    label: z.union([
        z.string(),
        z.null()
    ]),
    sharegroup_label: z.string().readonly(),
    sharegroup_uuid: z.string().readonly(),
    status: z.enum([
        'pending',
        'active',
        'revoked',
        'expired'
    ]),
    token: z.string().readonly(),
    token_uuid: z.string().readonly(),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    valid_for_sharegroup_uuid: z.string().readonly()
});

export const deleteSharegroupTokenRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tokenUuid: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteSharegroupTokenResponseSchema = z.record(z.string(), z.unknown());

export const getSharegroupTokenRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tokenUuid: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * ImageShareGroupMemberTokens object.
 */
export const getSharegroupTokenResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    label: z.string(),
    sharegroup_label: z.string().readonly(),
    sharegroup_uuid: z.string().readonly(),
    status: z.enum([
        'pending',
        'active',
        'revoked',
        'expired'
    ]),
    token_uuid: z.string().readonly(),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    valid_for_sharegroup_uuid: z.string().readonly()
});

export const putSharegroupTokenRequestSchema = z.object({
    body: z.optional(z.object({
        label: z.string()
    })),
    path: z.object({
        tokenUuid: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * ImageShareGroupMemberTokens object.
 */
export const putSharegroupTokenResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    label: z.string(),
    sharegroup_label: z.string().readonly(),
    sharegroup_uuid: z.string().readonly(),
    status: z.enum([
        'pending',
        'active',
        'revoked',
        'expired'
    ]),
    token_uuid: z.string().readonly(),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    valid_for_sharegroup_uuid: z.string().readonly()
});

export const getSharegroupByTokenRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tokenUuid: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * The share group's details.
 */
export const getSharegroupByTokenResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    id: z.int().readonly(),
    is_suspended: z.boolean().readonly(),
    label: z.string(),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    uuid: z.uuid().readonly()
});

export const getSharegroupImagesByTokenRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tokenUuid: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * A paginated list of shared images in a share group.
 */
export const getSharegroupImagesByTokenResponseSchema = z.object({
    data: z.array(z.object({
        capabilities: z.array(z.string()).readonly(),
        created: z.iso.datetime().readonly(),
        created_by: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        deprecated: z.boolean().readonly(),
        description: z.string(),
        eol: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        expiry: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        id: z.string().readonly(),
        image_sharing: z.object({
            shared_by: z.object({
                sharegroup_id: z.int().readonly(),
                sharegroup_label: z.string(),
                sharegroup_uuid: z.uuid().readonly(),
                source_image_id: z.string().readonly()
            }),
            shared_with: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ])
        }).readonly(),
        is_public: z.boolean().readonly(),
        is_shared: z.union([
            z.literal(true),
            z.literal(false),
            z.literal('none')
        ]),
        label: z.string(),
        regions: z.array(z.object({
            region: z.string(),
            status: z.enum([
                'available',
                'creating',
                'pending',
                'pending deletion',
                'pending replication',
                'replicating'
            ])
        })).readonly(),
        size: z.int().readonly(),
        status: z.enum([
            'creating',
            'pending_upload',
            'available'
        ]),
        tags: z.array(z.string().min(3).max(100)).min(0).max(500).readonly(),
        total_size: z.int().readonly(),
        type: z.enum([
            'manual',
            'automatic',
            'shared'
        ]),
        updated: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        vendor: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const deleteSharegroupRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        sharegroupId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteSharegroupResponseSchema = z.record(z.string(), z.unknown());

export const getSharegroupRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        sharegroupId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The share group's details.
 */
export const getSharegroupResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    id: z.int().readonly(),
    images_count: z.int().readonly(),
    is_suspended: z.boolean().readonly(),
    label: z.string(),
    members_count: z.int().readonly(),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    uuid: z.uuid().readonly()
});

export const putSharegroupRequestSchema = z.object({
    body: z.object({
        description: z.string(),
        label: z.string()
    }),
    path: z.object({
        sharegroupId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The share group's details.
 */
export const putSharegroupResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    description: z.union([
        z.string(),
        z.null()
    ]),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    id: z.int().readonly(),
    images_count: z.int().readonly(),
    is_suspended: z.boolean().readonly(),
    label: z.string(),
    members_count: z.int().readonly(),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    uuid: z.uuid().readonly()
});

export const getSharegroupImagesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        sharegroupId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of shared images within a given group.
 */
export const getSharegroupImagesResponseSchema = z.object({
    data: z.array(z.object({
        capabilities: z.array(z.string()).readonly(),
        created: z.iso.datetime().readonly(),
        created_by: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        deprecated: z.boolean().readonly(),
        description: z.string(),
        eol: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        expiry: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        id: z.string().readonly(),
        image_sharing: z.object({
            shared_by: z.object({
                sharegroup_id: z.int().readonly(),
                sharegroup_label: z.string(),
                sharegroup_uuid: z.uuid().readonly(),
                source_image_id: z.string().readonly()
            }),
            shared_with: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ])
        }).readonly(),
        is_public: z.boolean().readonly(),
        is_shared: z.union([
            z.literal(true),
            z.literal(false),
            z.literal('none')
        ]),
        label: z.string(),
        regions: z.array(z.object({
            region: z.string(),
            status: z.enum([
                'available',
                'creating',
                'pending',
                'pending deletion',
                'pending replication',
                'replicating'
            ])
        })).readonly(),
        size: z.int().readonly(),
        status: z.enum([
            'creating',
            'pending_upload',
            'available'
        ]),
        tags: z.array(z.string().min(3).max(100)).min(0).max(500).readonly(),
        total_size: z.int().readonly(),
        type: z.enum([
            'manual',
            'automatic',
            'shared'
        ]),
        updated: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        vendor: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postSharegroupImagesRequestSchema = z.object({
    body: z.optional(z.object({
        images: z.array(z.object({
            description: z.optional(z.string()),
            id: z.string(),
            label: z.optional(z.string())
        }))
    })),
    path: z.object({
        sharegroupId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The shared image's details.
 */
export const postSharegroupImagesResponseSchema = z.object({
    capabilities: z.array(z.string()).readonly(),
    created: z.iso.datetime().readonly(),
    created_by: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    deprecated: z.boolean().readonly(),
    description: z.string(),
    eol: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    id: z.string().readonly(),
    image_sharing: z.object({
        shared_by: z.object({
            sharegroup_id: z.int().readonly(),
            sharegroup_label: z.string(),
            sharegroup_uuid: z.uuid().readonly(),
            source_image_id: z.string().readonly()
        }),
        shared_with: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])
    }).readonly(),
    is_public: z.boolean().readonly(),
    is_shared: z.union([
        z.literal(true),
        z.literal(false),
        z.literal('none')
    ]),
    label: z.string(),
    regions: z.array(z.object({
        region: z.string(),
        status: z.enum([
            'available',
            'creating',
            'pending',
            'pending deletion',
            'pending replication',
            'replicating'
        ])
    })).readonly(),
    size: z.int().readonly(),
    status: z.enum([
        'creating',
        'pending_upload',
        'available'
    ]),
    tags: z.array(z.string().min(3).max(100)).min(0).max(500).readonly(),
    total_size: z.int().readonly(),
    type: z.enum([
        'manual',
        'automatic',
        'shared'
    ]),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    vendor: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const deleteSharegroupImageshareRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        sharegroupId: z.int(),
        imageId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteSharegroupImageshareResponseSchema = z.record(z.string(), z.unknown());

export const putSharegroupImageshareRequestSchema = z.object({
    body: z.object({
        description: z.string(),
        label: z.string()
    }),
    path: z.object({
        sharegroupId: z.int(),
        imageId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The shared image's details.
 */
export const putSharegroupImageshareResponseSchema = z.object({
    capabilities: z.array(z.string()).readonly(),
    created: z.iso.datetime().readonly(),
    created_by: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    deprecated: z.boolean().readonly(),
    description: z.string(),
    eol: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    id: z.string().readonly(),
    image_sharing: z.object({
        shared_by: z.object({
            sharegroup_id: z.int().readonly(),
            sharegroup_label: z.string(),
            sharegroup_uuid: z.uuid().readonly(),
            source_image_id: z.string().readonly()
        }),
        shared_with: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])
    }).readonly(),
    is_public: z.boolean().readonly(),
    is_shared: z.union([
        z.literal(true),
        z.literal(false),
        z.literal('none')
    ]),
    label: z.string(),
    regions: z.array(z.object({
        region: z.string(),
        status: z.enum([
            'available',
            'creating',
            'pending',
            'pending deletion',
            'pending replication',
            'replicating'
        ])
    })).readonly(),
    size: z.int().readonly(),
    status: z.enum([
        'creating',
        'pending_upload',
        'available'
    ]),
    tags: z.array(z.string().min(3).max(100)).min(0).max(500).readonly(),
    total_size: z.int().readonly(),
    type: z.enum([
        'manual',
        'automatic',
        'shared'
    ]),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    vendor: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const getSharegroupMembersRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        sharegroupId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of the current members linked to the targeted share group.
 */
export const getSharegroupMembersResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        expiry: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        label: z.string(),
        status: z.enum(['active', 'revoked']),
        token_uuid: z.string().readonly(),
        updated: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postSharegroupMembersRequestSchema = z.object({
    body: z.optional(z.object({
        label: z.string(),
        token: z.string()
    })),
    path: z.object({
        sharegroupId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The shared group membership's details.
 */
export const postSharegroupMembersResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    label: z.string(),
    status: z.enum(['active', 'revoked']),
    token_uuid: z.string().readonly(),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly()
});

export const deleteSharegroupMemberTokenRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        sharegroupId: z.int(),
        tokenUuid: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteSharegroupMemberTokenResponseSchema = z.record(z.string(), z.unknown());

export const getSharegroupMemberTokenRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        sharegroupId: z.int(),
        tokenUuid: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * The shared group membership's details.
 */
export const getSharegroupMemberTokenResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    label: z.string(),
    status: z.enum(['active', 'revoked']),
    token_uuid: z.string().readonly(),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly()
});

export const putSharegroupMemberTokenRequestSchema = z.object({
    body: z.object({
        label: z.string()
    }),
    path: z.object({
        sharegroupId: z.int(),
        tokenUuid: z.uuid()
    }),
    query: z.optional(z.never())
});

/**
 * The shared group membership's details.
 */
export const putSharegroupMemberTokenResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    label: z.string(),
    status: z.enum(['active', 'revoked']),
    token_uuid: z.string().readonly(),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly()
});

export const postUploadImageRequestSchema = z.object({
    body: z.optional(z.object({
        cloud_init: z.optional(z.boolean()),
        description: z.optional(z.string()),
        label: z.string(),
        region: z.string(),
        tags: z.optional(z.array(z.string().min(3).max(100)).min(0).max(500))
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Image Upload object including the upload URL and image object.
 */
export const postUploadImageResponseSchema = z.object({
    image: z.object({
        capabilities: z.array(z.string()).readonly(),
        created: z.iso.datetime().readonly(),
        created_by: z.string().readonly(),
        deprecated: z.boolean().readonly(),
        description: z.union([
            z.string().min(1).max(65000),
            z.null()
        ]),
        eol: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        expiry: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        id: z.string().readonly(),
        image_sharing: z.union([
            z.object({
                shared_by: z.union([
                    z.record(z.string(), z.unknown()),
                    z.null()
                ]),
                shared_with: z.object({
                    sharegroup_count: z.int(),
                    sharegroup_list_url: z.string()
                })
            }),
            z.object({
                shared_by: z.object({
                    sharegroup_id: z.int(),
                    sharegroup_label: z.string(),
                    sharegroup_uuid: z.uuid(),
                    source_image_id: z.union([
                        z.string(),
                        z.null()
                    ])
                }),
                shared_with: z.union([
                    z.record(z.string(), z.unknown()),
                    z.null()
                ])
            })
        ]),
        is_public: z.boolean().readonly(),
        is_shared: z.union([
            z.literal(true),
            z.literal(false),
            z.literal('none')
        ]),
        label: z.string(),
        regions: z.array(z.object({
            region: z.string(),
            status: z.enum([
                'available',
                'creating',
                'pending',
                'pending deletion',
                'pending replication',
                'replicating'
            ])
        })).readonly(),
        size: z.int().readonly(),
        status: z.enum([
            'creating',
            'pending_upload',
            'available'
        ]),
        tags: z.array(z.string().min(3).max(100)).min(0).max(500),
        total_size: z.int().readonly(),
        type: z.enum([
            'manual',
            'automatic',
            'shared'
        ]),
        updated: z.iso.datetime().readonly(),
        vendor: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    }),
    upload_to: z.string()
});

export const deleteImageRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        imageId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteImageResponseSchema = z.record(z.string(), z.unknown());

export const getImageRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        imageId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Image object.
 */
export const getImageResponseSchema = z.object({
    capabilities: z.array(z.string()).readonly(),
    created: z.iso.datetime().readonly(),
    created_by: z.string().readonly(),
    deprecated: z.boolean().readonly(),
    description: z.union([
        z.string().min(1).max(65000),
        z.null()
    ]),
    eol: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    id: z.string().readonly(),
    image_sharing: z.union([
        z.object({
            shared_by: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ]),
            shared_with: z.object({
                sharegroup_count: z.int(),
                sharegroup_list_url: z.string()
            })
        }),
        z.object({
            shared_by: z.object({
                sharegroup_id: z.int(),
                sharegroup_label: z.string(),
                sharegroup_uuid: z.uuid(),
                source_image_id: z.union([
                    z.string(),
                    z.null()
                ])
            }),
            shared_with: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ])
        })
    ]),
    is_public: z.boolean().readonly(),
    is_shared: z.union([
        z.literal(true),
        z.literal(false),
        z.literal('none')
    ]),
    label: z.string(),
    regions: z.array(z.object({
        region: z.string(),
        status: z.enum([
            'available',
            'creating',
            'pending',
            'pending deletion',
            'pending replication',
            'replicating'
        ])
    })).readonly(),
    size: z.int().readonly(),
    status: z.enum([
        'creating',
        'pending_upload',
        'available'
    ]),
    tags: z.array(z.string().min(3).max(100)).min(0).max(500),
    total_size: z.int().readonly(),
    type: z.enum([
        'manual',
        'automatic',
        'shared'
    ]),
    updated: z.iso.datetime().readonly(),
    vendor: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const putImageRequestSchema = z.object({
    body: z.object({
        capabilities: z.array(z.string()).readonly(),
        created: z.iso.datetime().readonly(),
        created_by: z.string().readonly(),
        deprecated: z.boolean().readonly(),
        description: z.union([
            z.string().min(1).max(65000),
            z.null()
        ]),
        eol: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        expiry: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        id: z.string().readonly(),
        is_public: z.boolean().readonly(),
        is_shared: z.union([
            z.literal(true),
            z.literal(false),
            z.literal('none')
        ]),
        label: z.string(),
        regions: z.array(z.object({
            region: z.string(),
            status: z.enum([
                'available',
                'creating',
                'pending',
                'pending deletion',
                'pending replication',
                'replicating'
            ])
        })).readonly(),
        size: z.int().readonly(),
        status: z.enum([
            'creating',
            'pending_upload',
            'available'
        ]),
        tags: z.array(z.string().min(3).max(100)).min(0).max(500),
        total_size: z.int().readonly(),
        type: z.enum(['manual', 'automatic']),
        updated: z.iso.datetime().readonly(),
        vendor: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    }),
    path: z.object({
        imageId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Image object.
 */
export const putImageResponseSchema = z.object({
    capabilities: z.array(z.string()).readonly(),
    created: z.iso.datetime().readonly(),
    created_by: z.string().readonly(),
    deprecated: z.boolean().readonly(),
    description: z.union([
        z.string().min(1).max(65000),
        z.null()
    ]),
    eol: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    id: z.string().readonly(),
    image_sharing: z.union([
        z.object({
            shared_by: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ]),
            shared_with: z.object({
                sharegroup_count: z.int(),
                sharegroup_list_url: z.string()
            })
        }),
        z.object({
            shared_by: z.object({
                sharegroup_id: z.int(),
                sharegroup_label: z.string(),
                sharegroup_uuid: z.uuid(),
                source_image_id: z.union([
                    z.string(),
                    z.null()
                ])
            }),
            shared_with: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ])
        })
    ]),
    is_public: z.boolean().readonly(),
    is_shared: z.union([
        z.literal(true),
        z.literal(false),
        z.literal('none')
    ]),
    label: z.string(),
    regions: z.array(z.object({
        region: z.string(),
        status: z.enum([
            'available',
            'creating',
            'pending',
            'pending deletion',
            'pending replication',
            'replicating'
        ])
    })).readonly(),
    size: z.int().readonly(),
    status: z.enum([
        'creating',
        'pending_upload',
        'available'
    ]),
    tags: z.array(z.string().min(3).max(100)).min(0).max(500),
    total_size: z.int().readonly(),
    type: z.enum([
        'manual',
        'automatic',
        'shared'
    ]),
    updated: z.iso.datetime().readonly(),
    vendor: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const postReplicateImageRequestSchema = z.object({
    body: z.object({
        regions: z.array(z.string())
    }),
    path: z.object({
        imageId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Image object.
 */
export const postReplicateImageResponseSchema = z.object({
    capabilities: z.array(z.string()).readonly(),
    created: z.iso.datetime().readonly(),
    created_by: z.string().readonly(),
    deprecated: z.boolean().readonly(),
    description: z.union([
        z.string().min(1).max(65000),
        z.null()
    ]),
    eol: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    id: z.string().readonly(),
    image_sharing: z.union([
        z.object({
            shared_by: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ]),
            shared_with: z.object({
                sharegroup_count: z.int(),
                sharegroup_list_url: z.string()
            })
        }),
        z.object({
            shared_by: z.object({
                sharegroup_id: z.int(),
                sharegroup_label: z.string(),
                sharegroup_uuid: z.uuid(),
                source_image_id: z.union([
                    z.string(),
                    z.null()
                ])
            }),
            shared_with: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ])
        })
    ]),
    is_public: z.boolean().readonly(),
    is_shared: z.union([
        z.literal(true),
        z.literal(false),
        z.literal('none')
    ]),
    label: z.string(),
    regions: z.array(z.object({
        region: z.string(),
        status: z.enum([
            'available',
            'creating',
            'pending',
            'pending deletion',
            'pending replication',
            'replicating'
        ])
    })).readonly(),
    size: z.int().readonly(),
    status: z.enum([
        'creating',
        'pending_upload',
        'available'
    ]),
    tags: z.array(z.string().min(3).max(100)).min(0).max(500),
    total_size: z.int().readonly(),
    type: z.enum([
        'manual',
        'automatic',
        'shared'
    ]),
    updated: z.iso.datetime().readonly(),
    vendor: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const getImagesSharegroupsImageRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        imageId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of share groups.
 */
export const getImagesSharegroupsImageResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        description: z.union([
            z.string(),
            z.null()
        ]),
        expiry: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        id: z.int(),
        images_count: z.int().readonly(),
        is_suspended: z.boolean().readonly(),
        label: z.string(),
        members_count: z.int().readonly(),
        updated: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        uuid: z.uuid()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getLinodeInstancesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    })),
    headers: z.optional(z.object({
        'X-Filter': z.optional(z.union([
            z.record(z.string(), z.unknown()),
            z.object({
                '+and': z.array(z.record(z.string(), z.unknown())),
                '+contains': z.string(),
                '+gt': z.number(),
                '+gte': z.number(),
                '+lt': z.number(),
                '+lte': z.number(),
                '+neq': z.string(),
                '+or': z.array(z.record(z.string(), z.unknown())),
                '+order': z.enum(['asc', 'desc']),
                '+order_by': z.string()
            })
        ]))
    }))
});

/**
 * Returns an array of all Linodes on your Account.
 */
export const getLinodeInstancesResponseSchema = z.object({
    data: z.array(z.object({
        alerts: z.object({
            cpu: z.int(),
            io: z.int(),
            network_in: z.int(),
            network_out: z.int(),
            transfer_quota: z.int()
        }),
        backups: z.object({
            available: z.boolean().readonly(),
            enabled: z.boolean().readonly(),
            last_successful: z.iso.datetime().readonly(),
            schedule: z.object({
                day: z.enum([
                    'Scheduling',
                    'Sunday',
                    'Monday',
                    'Tuesday',
                    'Wednesday',
                    'Thursday',
                    'Friday',
                    'Saturday'
                ]),
                window: z.enum([
                    'Scheduling',
                    'W0',
                    'W2',
                    'W4',
                    'W6',
                    'W8',
                    'W10',
                    'W12',
                    'W14',
                    'W16',
                    'W18',
                    'W20',
                    'W22'
                ])
            })
        }),
        capabilities: z.array(z.string()).readonly(),
        created: z.iso.datetime().readonly(),
        disk_encryption: z.enum(['enabled', 'disabled']),
        group: z.string(),
        has_user_data: z.boolean().readonly(),
        host_uuid: z.uuid().readonly(),
        hypervisor: z.enum(['kvm']),
        id: z.int().readonly(),
        image: z.union([
            z.string(),
            z.null()
        ]),
        interface_generation: z.enum(['legacy_config', 'linode']),
        ipv4: z.array(z.string()).readonly(),
        ipv6: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        label: z.string().min(3).max(64).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
        lke_cluster_id: z.union([
            z.int().readonly(),
            z.null()
        ]).readonly(),
        maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
        placement_group: z.union([
            z.object({
                id: z.int(),
                label: z.string().min(1),
                migrating_to: z.union([
                    z.int().readonly(),
                    z.null()
                ]).readonly(),
                placement_group_policy: z.enum(['strict', 'flexible']),
                placement_group_type: z.enum(['anti_affinity:local'])
            }).readonly(),
            z.null()
        ]).readonly(),
        region: z.string().readonly(),
        specs: z.object({
            disk: z.int().readonly(),
            gpus: z.int().readonly(),
            memory: z.int().readonly(),
            transfer: z.int().readonly(),
            vcpus: z.int().readonly()
        }).readonly(),
        status: z.enum([
            'running',
            'offline',
            'booting',
            'busy',
            'rebooting',
            'shutting_down',
            'provisioning',
            'deleting',
            'migrating',
            'rebuilding',
            'cloning',
            'restoring',
            'stopped',
            'billing_suspension'
        ]),
        tags: z.array(z.string()),
        type: z.string().readonly(),
        updated: z.iso.datetime().readonly(),
        watchdog_enabled: z.boolean()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postLinodeInstanceRequestSchema = z.object({
    body: z.object({
        authorized_keys: z.array(z.string()),
        authorized_users: z.array(z.string()),
        booted: z.boolean().default(true),
        disk_encryption: z.enum(['enabled', 'disabled']),
        image: z.union([
            z.string(),
            z.null()
        ]),
        maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
        metadata: z.object({
            user_data: z.string()
        }),
        root_pass: z.string().min(7).max(128),
        stackscript_data: z.record(z.string(), z.unknown()),
        stackscript_id: z.int()
    }).and(z.object({
        backup_id: z.optional(z.int()),
        backups_enabled: z.optional(z.boolean()),
        firewall_id: z.optional(z.int()),
        group: z.optional(z.string()),
        interface_generation: z.optional(z.enum(['legacy_config', 'linode'])),
        interfaces: z.optional(z.array(z.union([
            z.object({
                default_route: z.object({
                    ipv4: z.union([
                        z.boolean(),
                        z.null()
                    ]),
                    ipv6: z.union([
                        z.boolean(),
                        z.null()
                    ])
                }),
                firewall_id: z.union([
                    z.int(),
                    z.null()
                ]),
                public: z.union([
                    z.object({
                        ipv4: z.object({
                            addresses: z.array(z.object({
                                address: z.union([
                                    z.string().min(1),
                                    z.enum(['auto']),
                                    z.string()
                                ]),
                                primary: z.boolean().default(false)
                            }))
                        }),
                        ipv6: z.object({
                            ranges: z.array(z.object({
                                range: z.string()
                            }))
                        })
                    }),
                    z.null()
                ])
            }),
            z.object({
                vlan: z.union([
                    z.object({
                        ipam_address: z.string(),
                        vlan_label: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/)
                    }),
                    z.null()
                ])
            }),
            z.object({
                default_route: z.object({
                    ipv4: z.union([
                        z.boolean(),
                        z.null()
                    ])
                }),
                firewall_id: z.union([
                    z.int(),
                    z.null()
                ]),
                vpc: z.union([
                    z.object({
                        ipv4: z.optional(z.object({
                            addresses: z.array(z.object({
                                address: z.union([
                                    z.string().min(1),
                                    z.enum(['auto'])
                                ]),
                                nat_1_1_address: z.union([
                                    z.string().min(1),
                                    z.enum(['auto']),
                                    z.null()
                                ]),
                                primary: z.union([
                                    z.boolean().default(false),
                                    z.null()
                                ]).default(false)
                            })),
                            ranges: z.array(z.object({
                                range: z.string()
                            }))
                        })),
                        subnet_id: z.int()
                    }),
                    z.null()
                ])
            }),
            z.intersection(z.unknown(), z.object({
                active: z.optional(z.boolean().readonly()),
                id: z.optional(z.int().readonly()),
                ip_ranges: z.optional(z.union([
                    z.array(z.string()),
                    z.null()
                ])),
                ipam_address: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                ipv4: z.optional(z.object({
                    nat_1_1: z.union([
                        z.string().min(1),
                        z.enum(['any']),
                        z.null()
                    ]),
                    vpc: z.union([
                        z.string(),
                        z.null()
                    ])
                })),
                label: z.optional(z.union([
                    z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
                    z.null()
                ])),
                primary: z.optional(z.boolean()),
                purpose: z.enum([
                    'public',
                    'vlan',
                    'vpc'
                ]),
                subnet_id: z.optional(z.union([
                    z.int(),
                    z.null()
                ])),
                vpc_id: z.optional(z.union([
                    z.int().readonly(),
                    z.null()
                ]).readonly())
            }))
        ]))).default([]),
        label: z.optional(z.string().min(3).max(64).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/)),
        network_helper: z.optional(z.union([
            z.boolean(),
            z.null()
        ])),
        placement_group: z.optional(z.object({
            id: z.int()
        })),
        private_ip: z.optional(z.boolean()),
        region: z.string(),
        swap_size: z.optional(z.int()).default(512),
        tags: z.optional(z.array(z.string())),
        type: z.string()
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Linode
 *
 * A new Linode is being created.
 */
export const postLinodeInstanceResponseSchema = z.object({
    alerts: z.object({
        cpu: z.int(),
        io: z.int(),
        network_in: z.int(),
        network_out: z.int(),
        transfer_quota: z.int()
    }),
    backups: z.object({
        available: z.boolean().readonly(),
        enabled: z.boolean().readonly(),
        last_successful: z.iso.datetime().readonly(),
        schedule: z.object({
            day: z.enum([
                'Scheduling',
                'Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday'
            ]),
            window: z.enum([
                'Scheduling',
                'W0',
                'W2',
                'W4',
                'W6',
                'W8',
                'W10',
                'W12',
                'W14',
                'W16',
                'W18',
                'W20',
                'W22'
            ])
        })
    }),
    capabilities: z.array(z.string()).readonly(),
    created: z.iso.datetime().readonly(),
    disk_encryption: z.union([
        z.string().readonly().default('enabled'),
        z.null()
    ]).readonly().default('enabled'),
    group: z.string(),
    has_user_data: z.boolean().readonly(),
    host_uuid: z.uuid().readonly(),
    hypervisor: z.enum(['kvm']),
    id: z.int().readonly(),
    image: z.union([
        z.string(),
        z.null()
    ]),
    interface_generation: z.enum(['legacy_config', 'linode']),
    ipv4: z.array(z.string()).readonly(),
    ipv6: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    label: z.string().min(3).max(64).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
    lke_cluster_id: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
    placement_group: z.union([
        z.object({
            id: z.int(),
            label: z.string().min(1),
            placement_group_policy: z.enum(['strict', 'flexible']),
            placement_group_type: z.enum(['anti_affinity:local'])
        }).readonly(),
        z.null()
    ]).readonly(),
    region: z.string().readonly(),
    specs: z.object({
        disk: z.int().readonly(),
        gpus: z.int().readonly(),
        memory: z.int().readonly(),
        transfer: z.int().readonly(),
        vcpus: z.int().readonly()
    }).readonly(),
    status: z.enum([
        'running',
        'offline',
        'booting',
        'busy',
        'rebooting',
        'shutting_down',
        'provisioning',
        'deleting',
        'migrating',
        'rebuilding',
        'cloning',
        'restoring',
        'stopped',
        'billing_suspension'
    ]),
    tags: z.array(z.string()),
    type: z.string().readonly(),
    updated: z.iso.datetime().readonly(),
    watchdog_enabled: z.boolean()
});

export const deleteLinodeInstanceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteLinodeInstanceResponseSchema = z.record(z.string(), z.unknown());

export const getLinodeInstanceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Linode
 *
 * Returns a single Linode object.
 */
export const getLinodeInstanceResponseSchema = z.object({
    alerts: z.object({
        cpu: z.int(),
        io: z.int(),
        network_in: z.int(),
        network_out: z.int(),
        transfer_quota: z.int()
    }),
    backups: z.object({
        available: z.boolean().readonly(),
        enabled: z.boolean().readonly(),
        last_successful: z.iso.datetime().readonly(),
        schedule: z.object({
            day: z.enum([
                'Scheduling',
                'Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday'
            ]),
            window: z.enum([
                'Scheduling',
                'W0',
                'W2',
                'W4',
                'W6',
                'W8',
                'W10',
                'W12',
                'W14',
                'W16',
                'W18',
                'W20',
                'W22'
            ])
        })
    }),
    capabilities: z.array(z.string()).readonly(),
    created: z.iso.datetime().readonly(),
    disk_encryption: z.enum(['enabled', 'disabled']),
    group: z.string(),
    has_user_data: z.boolean().readonly(),
    host_uuid: z.uuid().readonly(),
    hypervisor: z.enum(['kvm']),
    id: z.int().readonly(),
    image: z.union([
        z.string(),
        z.null()
    ]),
    interface_generation: z.enum(['legacy_config', 'linode']),
    ipv4: z.array(z.string()).readonly(),
    ipv6: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    label: z.string().min(3).max(64).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
    lke_cluster_id: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
    placement_group: z.union([
        z.object({
            id: z.int(),
            label: z.string().min(1),
            migrating_to: z.union([
                z.int().readonly(),
                z.null()
            ]).readonly(),
            placement_group_policy: z.enum(['strict', 'flexible']),
            placement_group_type: z.enum(['anti_affinity:local'])
        }).readonly(),
        z.null()
    ]).readonly(),
    region: z.string().readonly(),
    specs: z.object({
        disk: z.int().readonly(),
        gpus: z.int().readonly(),
        memory: z.int().readonly(),
        transfer: z.int().readonly(),
        vcpus: z.int().readonly()
    }).readonly(),
    status: z.enum([
        'running',
        'offline',
        'booting',
        'busy',
        'rebooting',
        'shutting_down',
        'provisioning',
        'deleting',
        'migrating',
        'rebuilding',
        'cloning',
        'restoring',
        'stopped',
        'billing_suspension'
    ]),
    tags: z.array(z.string()),
    type: z.string().readonly(),
    updated: z.iso.datetime().readonly(),
    watchdog_enabled: z.boolean()
});

export const putLinodeInstanceRequestSchema = z.object({
    body: z.object({
        alerts: z.object({
            cpu: z.int(),
            io: z.int(),
            network_in: z.int(),
            network_out: z.int(),
            transfer_quota: z.int()
        }),
        backups: z.object({
            available: z.boolean().readonly(),
            enabled: z.boolean().readonly(),
            last_successful: z.iso.datetime().readonly(),
            schedule: z.object({
                day: z.enum([
                    'Scheduling',
                    'Sunday',
                    'Monday',
                    'Tuesday',
                    'Wednesday',
                    'Thursday',
                    'Friday',
                    'Saturday'
                ]),
                window: z.enum([
                    'Scheduling',
                    'W0',
                    'W2',
                    'W4',
                    'W6',
                    'W8',
                    'W10',
                    'W12',
                    'W14',
                    'W16',
                    'W18',
                    'W20',
                    'W22'
                ])
            })
        }),
        capabilities: z.array(z.string()).readonly(),
        created: z.iso.datetime().readonly(),
        disk_encryption: z.union([
            z.string().readonly().default('enabled'),
            z.null()
        ]).readonly().default('enabled'),
        group: z.string(),
        has_user_data: z.boolean().readonly(),
        host_uuid: z.uuid().readonly(),
        hypervisor: z.enum(['kvm']),
        id: z.int().readonly(),
        image: z.union([
            z.string(),
            z.null()
        ]),
        interface_generation: z.enum(['legacy_config', 'linode']),
        ipv4: z.array(z.string()).readonly(),
        ipv6: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        label: z.string().min(3).max(64).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
        lke_cluster_id: z.union([
            z.int().readonly(),
            z.null()
        ]).readonly(),
        maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
        placement_group: z.union([
            z.object({
                id: z.int(),
                label: z.string().min(1),
                placement_group_policy: z.enum(['strict', 'flexible']),
                placement_group_type: z.enum(['anti_affinity:local'])
            }).readonly(),
            z.null()
        ]).readonly(),
        region: z.string().readonly(),
        specs: z.object({
            disk: z.int().readonly(),
            gpus: z.int().readonly(),
            memory: z.int().readonly(),
            transfer: z.int().readonly(),
            vcpus: z.int().readonly()
        }).readonly(),
        status: z.enum([
            'running',
            'offline',
            'booting',
            'busy',
            'rebooting',
            'shutting_down',
            'provisioning',
            'deleting',
            'migrating',
            'rebuilding',
            'cloning',
            'restoring',
            'stopped',
            'billing_suspension'
        ]),
        tags: z.array(z.string()),
        type: z.string().readonly(),
        updated: z.iso.datetime().readonly(),
        watchdog_enabled: z.boolean()
    }),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Linode
 *
 * The updated Linode.
 */
export const putLinodeInstanceResponseSchema = z.object({
    alerts: z.object({
        cpu: z.int(),
        io: z.int(),
        network_in: z.int(),
        network_out: z.int(),
        transfer_quota: z.int()
    }),
    backups: z.object({
        available: z.boolean().readonly(),
        enabled: z.boolean().readonly(),
        last_successful: z.iso.datetime().readonly(),
        schedule: z.object({
            day: z.enum([
                'Scheduling',
                'Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday'
            ]),
            window: z.enum([
                'Scheduling',
                'W0',
                'W2',
                'W4',
                'W6',
                'W8',
                'W10',
                'W12',
                'W14',
                'W16',
                'W18',
                'W20',
                'W22'
            ])
        })
    }),
    capabilities: z.array(z.string()).readonly(),
    created: z.iso.datetime().readonly(),
    disk_encryption: z.union([
        z.string().readonly().default('enabled'),
        z.null()
    ]).readonly().default('enabled'),
    group: z.string(),
    has_user_data: z.boolean().readonly(),
    host_uuid: z.uuid().readonly(),
    hypervisor: z.enum(['kvm']),
    id: z.int().readonly(),
    image: z.union([
        z.string(),
        z.null()
    ]),
    interface_generation: z.enum(['legacy_config', 'linode']),
    ipv4: z.array(z.string()).readonly(),
    ipv6: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    label: z.string().min(3).max(64).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
    lke_cluster_id: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
    placement_group: z.union([
        z.object({
            id: z.int(),
            label: z.string().min(1),
            placement_group_policy: z.enum(['strict', 'flexible']),
            placement_group_type: z.enum(['anti_affinity:local'])
        }).readonly(),
        z.null()
    ]).readonly(),
    region: z.string().readonly(),
    specs: z.object({
        disk: z.int().readonly(),
        gpus: z.int().readonly(),
        memory: z.int().readonly(),
        transfer: z.int().readonly(),
        vcpus: z.int().readonly()
    }).readonly(),
    status: z.enum([
        'running',
        'offline',
        'booting',
        'busy',
        'rebooting',
        'shutting_down',
        'provisioning',
        'deleting',
        'migrating',
        'rebuilding',
        'cloning',
        'restoring',
        'stopped',
        'billing_suspension'
    ]),
    tags: z.array(z.string()),
    type: z.string().readonly(),
    updated: z.iso.datetime().readonly(),
    watchdog_enabled: z.boolean()
});

export const getBackupsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A collection of the specified Linode's available backups.
 */
export const getBackupsResponseSchema = z.object({
    automatic: z.array(z.object({
        available: z.boolean().readonly(),
        configs: z.array(z.string()).readonly(),
        created: z.iso.datetime().readonly(),
        disks: z.array(z.object({
            filesystem: z.enum([
                'raw',
                'swap',
                'ext2',
                'ext3',
                'ext4',
                'initrd'
            ]),
            label: z.string(),
            size: z.int()
        })).readonly(),
        finished: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        label: z.union([
            z.string(),
            z.null()
        ]),
        status: z.enum([
            'paused',
            'pending',
            'running',
            'needsPostProcessing',
            'successful',
            'failed',
            'userAborted'
        ]),
        type: z.enum(['auto', 'snapshot']),
        updated: z.iso.datetime().readonly()
    }).and(z.object({
        type: z.optional(z.string())
    }))),
    snapshot: z.object({
        current: z.object({
            available: z.boolean().readonly(),
            configs: z.array(z.string()).readonly(),
            created: z.iso.datetime().readonly(),
            disks: z.array(z.object({
                filesystem: z.enum([
                    'raw',
                    'swap',
                    'ext2',
                    'ext3',
                    'ext4',
                    'initrd'
                ]),
                label: z.string(),
                size: z.int()
            })).readonly(),
            finished: z.iso.datetime().readonly(),
            id: z.int().readonly(),
            label: z.union([
                z.string(),
                z.null()
            ]),
            status: z.enum([
                'paused',
                'pending',
                'running',
                'needsPostProcessing',
                'successful',
                'failed',
                'userAborted'
            ]),
            type: z.enum(['auto', 'snapshot']),
            updated: z.iso.datetime().readonly()
        }),
        in_progress: z.object({
            available: z.boolean().readonly(),
            configs: z.array(z.string()).readonly(),
            created: z.iso.datetime().readonly(),
            disks: z.array(z.object({
                filesystem: z.enum([
                    'raw',
                    'swap',
                    'ext2',
                    'ext3',
                    'ext4',
                    'initrd'
                ]),
                label: z.string(),
                size: z.int()
            })).readonly(),
            finished: z.iso.datetime().readonly(),
            id: z.int().readonly(),
            label: z.union([
                z.string(),
                z.null()
            ]),
            status: z.enum([
                'paused',
                'pending',
                'running',
                'needsPostProcessing',
                'successful',
                'failed',
                'userAborted'
            ]),
            type: z.enum(['auto', 'snapshot']),
            updated: z.iso.datetime().readonly()
        })
    })
});

export const postSnapshotRequestSchema = z.object({
    body: z.object({
        label: z.string().min(1).max(255)
    }),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * An object representing a Backup or snapshot for a Linode with Backup service enabled.
 */
export const postSnapshotResponseSchema = z.object({
    available: z.boolean().readonly(),
    configs: z.array(z.string()).readonly(),
    created: z.iso.datetime().readonly(),
    disks: z.array(z.object({
        filesystem: z.enum([
            'raw',
            'swap',
            'ext2',
            'ext3',
            'ext4',
            'initrd'
        ]),
        label: z.string(),
        size: z.int()
    })).readonly(),
    finished: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    label: z.union([
        z.string(),
        z.null()
    ]),
    status: z.enum([
        'paused',
        'pending',
        'running',
        'needsPostProcessing',
        'successful',
        'failed',
        'userAborted'
    ]),
    type: z.enum(['auto', 'snapshot']),
    updated: z.iso.datetime().readonly()
});

export const postCancelBackupsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postCancelBackupsResponseSchema = z.record(z.string(), z.unknown());

export const postEnableBackupsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postEnableBackupsResponseSchema = z.record(z.string(), z.unknown());

export const getBackupRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        backupId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * An object representing a Backup or snapshot for a Linode with Backup service enabled.
 */
export const getBackupResponseSchema = z.object({
    available: z.boolean().readonly(),
    configs: z.array(z.string()).readonly(),
    created: z.iso.datetime().readonly(),
    disks: z.array(z.object({
        filesystem: z.enum([
            'raw',
            'swap',
            'ext2',
            'ext3',
            'ext4',
            'initrd'
        ]),
        label: z.string(),
        size: z.int()
    })).readonly(),
    finished: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    label: z.union([
        z.string(),
        z.null()
    ]),
    status: z.enum([
        'paused',
        'pending',
        'running',
        'needsPostProcessing',
        'successful',
        'failed',
        'userAborted'
    ]),
    type: z.enum(['auto', 'snapshot']),
    updated: z.iso.datetime().readonly()
});

export const postRestoreBackupRequestSchema = z.object({
    body: z.object({
        linode_id: z.int(),
        overwrite: z.optional(z.boolean())
    }),
    path: z.object({
        linodeId: z.int(),
        backupId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postRestoreBackupResponseSchema = z.record(z.string(), z.unknown());

export const postBootLinodeInstanceRequestSchema = z.object({
    body: z.optional(z.object({
        config_id: z.union([
            z.int(),
            z.null()
        ])
    })),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postBootLinodeInstanceResponseSchema = z.record(z.string(), z.unknown());

export const postCloneLinodeInstanceRequestSchema = z.object({
    body: z.object({
        backups_enabled: z.boolean(),
        configs: z.array(z.int()),
        disks: z.array(z.int()),
        group: z.string(),
        label: z.string().min(3).max(64),
        linode_id: z.int(),
        maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
        metadata: z.object({
            user_data: z.string()
        }),
        placement_group: z.object({
            id: z.int()
        }),
        private_ip: z.boolean(),
        region: z.string(),
        type: z.string()
    }),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Linode
 *
 * Clone started.
 */
export const postCloneLinodeInstanceResponseSchema = z.object({
    alerts: z.object({
        cpu: z.int(),
        io: z.int(),
        network_in: z.int(),
        network_out: z.int(),
        transfer_quota: z.int()
    }),
    backups: z.object({
        available: z.boolean().readonly(),
        enabled: z.boolean().readonly(),
        last_successful: z.iso.datetime().readonly(),
        schedule: z.object({
            day: z.enum([
                'Scheduling',
                'Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday'
            ]),
            window: z.enum([
                'Scheduling',
                'W0',
                'W2',
                'W4',
                'W6',
                'W8',
                'W10',
                'W12',
                'W14',
                'W16',
                'W18',
                'W20',
                'W22'
            ])
        })
    }),
    capabilities: z.array(z.string()).readonly(),
    created: z.iso.datetime().readonly(),
    disk_encryption: z.union([
        z.string().readonly().default('enabled'),
        z.null()
    ]).readonly().default('enabled'),
    group: z.string(),
    has_user_data: z.boolean().readonly(),
    host_uuid: z.uuid().readonly(),
    hypervisor: z.enum(['kvm']),
    id: z.int().readonly(),
    image: z.union([
        z.string(),
        z.null()
    ]),
    interface_generation: z.enum(['legacy_config', 'linode']),
    ipv4: z.array(z.string()).readonly(),
    ipv6: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    label: z.string().min(3).max(64).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
    lke_cluster_id: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
    placement_group: z.union([
        z.object({
            id: z.int(),
            label: z.string().min(1),
            placement_group_policy: z.enum(['strict', 'flexible']),
            placement_group_type: z.enum(['anti_affinity:local'])
        }).readonly(),
        z.null()
    ]).readonly(),
    region: z.string().readonly(),
    specs: z.object({
        disk: z.int().readonly(),
        gpus: z.int().readonly(),
        memory: z.int().readonly(),
        transfer: z.int().readonly(),
        vcpus: z.int().readonly()
    }).readonly(),
    status: z.enum([
        'running',
        'offline',
        'booting',
        'busy',
        'rebooting',
        'shutting_down',
        'provisioning',
        'deleting',
        'migrating',
        'rebuilding',
        'cloning',
        'restoring',
        'stopped',
        'billing_suspension'
    ]),
    tags: z.array(z.string()),
    type: z.string().readonly(),
    updated: z.iso.datetime().readonly(),
    watchdog_enabled: z.boolean()
});

export const getLinodeConfigsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns the configuration profiles associated with this Linode.
 */
export const getLinodeConfigsResponseSchema = z.object({
    data: z.array(z.object({
        comments: z.union([
            z.string(),
            z.null()
        ]),
        devices: z.object({
            sda: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdb: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdc: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdd: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sde: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdf: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdg: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdh: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            })
        }),
        helpers: z.object({
            devtmpfs_automount: z.boolean().default(false),
            distro: z.boolean(),
            modules_dep: z.boolean(),
            network: z.union([
                z.boolean(),
                z.null()
            ]),
            updatedb_disabled: z.boolean()
        }),
        id: z.int().readonly(),
        interfaces: z.array(z.object({
            active: z.optional(z.boolean().readonly()),
            id: z.optional(z.int().readonly()),
            ip_ranges: z.optional(z.union([
                z.array(z.string()),
                z.null()
            ])),
            ipam_address: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            ipv4: z.optional(z.object({
                nat_1_1: z.union([
                    z.string().min(1),
                    z.enum(['any']),
                    z.null()
                ]),
                vpc: z.union([
                    z.string(),
                    z.null()
                ])
            })),
            label: z.optional(z.union([
                z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
                z.null()
            ])),
            primary: z.optional(z.boolean()),
            purpose: z.enum([
                'public',
                'vlan',
                'vpc'
            ]),
            subnet_id: z.optional(z.union([
                z.int(),
                z.null()
            ])),
            vpc_id: z.optional(z.union([
                z.int().readonly(),
                z.null()
            ]).readonly())
        })).min(1).max(3),
        kernel: z.string().default('linode/latest-64bit'),
        label: z.string().min(1).max(48),
        memory_limit: z.int(),
        root_device: z.string().regex(/a-z, A-Z, 0-9, \/, _, -/),
        run_level: z.enum([
            'default',
            'single',
            'binbash'
        ]),
        virt_mode: z.enum(['paravirt', 'fullvirt'])
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postAddLinodeConfigRequestSchema = z.object({
    body: z.object({
        comments: z.union([
            z.string(),
            z.null()
        ]),
        devices: z.object({
            sda: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdb: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdc: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdd: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sde: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdf: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdg: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdh: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            })
        }),
        helpers: z.object({
            devtmpfs_automount: z.boolean().default(false),
            distro: z.boolean(),
            modules_dep: z.boolean(),
            network: z.union([
                z.boolean(),
                z.null()
            ]),
            updatedb_disabled: z.boolean()
        }),
        id: z.int().readonly(),
        interfaces: z.array(z.object({
            active: z.optional(z.boolean().readonly()),
            id: z.optional(z.int().readonly()),
            ip_ranges: z.optional(z.union([
                z.array(z.string()),
                z.null()
            ])),
            ipam_address: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            ipv4: z.optional(z.object({
                nat_1_1: z.union([
                    z.string().min(1),
                    z.enum(['any']),
                    z.null()
                ]),
                vpc: z.union([
                    z.string(),
                    z.null()
                ])
            })),
            label: z.optional(z.union([
                z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
                z.null()
            ])),
            primary: z.optional(z.boolean()),
            purpose: z.enum([
                'public',
                'vlan',
                'vpc'
            ]),
            subnet_id: z.optional(z.union([
                z.int(),
                z.null()
            ])),
            vpc_id: z.optional(z.union([
                z.int().readonly(),
                z.null()
            ]).readonly())
        })).min(1).max(3),
        kernel: z.string().default('linode/latest-64bit'),
        label: z.string().min(1).max(48),
        memory_limit: z.int(),
        root_device: z.string().regex(/a-z, A-Z, 0-9, \/, _, -/),
        run_level: z.enum([
            'default',
            'single',
            'binbash'
        ]),
        virt_mode: z.enum(['paravirt', 'fullvirt'])
    }),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A configuration profile was created.
 */
export const postAddLinodeConfigResponseSchema = z.object({
    comments: z.union([
        z.string(),
        z.null()
    ]),
    devices: z.object({
        sda: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdb: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdc: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdd: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sde: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdf: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdg: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdh: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        })
    }),
    helpers: z.object({
        devtmpfs_automount: z.boolean().default(false),
        distro: z.boolean(),
        modules_dep: z.boolean(),
        network: z.union([
            z.boolean(),
            z.null()
        ]),
        updatedb_disabled: z.boolean()
    }),
    id: z.int().readonly(),
    interfaces: z.array(z.object({
        active: z.optional(z.boolean().readonly()),
        id: z.optional(z.int().readonly()),
        ip_ranges: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ])),
        ipam_address: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        ipv4: z.optional(z.object({
            nat_1_1: z.union([
                z.string().min(1),
                z.enum(['any']),
                z.null()
            ]),
            vpc: z.union([
                z.string(),
                z.null()
            ])
        })),
        label: z.optional(z.union([
            z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
            z.null()
        ])),
        primary: z.optional(z.boolean()),
        purpose: z.enum([
            'public',
            'vlan',
            'vpc'
        ]),
        subnet_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        vpc_id: z.optional(z.union([
            z.int().readonly(),
            z.null()
        ]).readonly())
    })).min(1).max(3),
    kernel: z.string().default('linode/latest-64bit'),
    label: z.string().min(1).max(48),
    memory_limit: z.int(),
    root_device: z.string().regex(/a-z, A-Z, 0-9, \/, _, -/),
    run_level: z.enum([
        'default',
        'single',
        'binbash'
    ]),
    virt_mode: z.enum(['paravirt', 'fullvirt'])
});

export const deleteLinodeConfigRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        configId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteLinodeConfigResponseSchema = z.record(z.string(), z.unknown());

export const getLinodeConfigRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        configId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A configuration profile object.
 */
export const getLinodeConfigResponseSchema = z.object({
    comments: z.union([
        z.string(),
        z.null()
    ]),
    devices: z.object({
        sda: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdb: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdc: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdd: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sde: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdf: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdg: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdh: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        })
    }),
    helpers: z.object({
        devtmpfs_automount: z.boolean().default(false),
        distro: z.boolean(),
        modules_dep: z.boolean(),
        network: z.union([
            z.boolean(),
            z.null()
        ]),
        updatedb_disabled: z.boolean()
    }),
    id: z.int().readonly(),
    interfaces: z.array(z.object({
        active: z.optional(z.boolean().readonly()),
        id: z.optional(z.int().readonly()),
        ip_ranges: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ])),
        ipam_address: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        ipv4: z.optional(z.object({
            nat_1_1: z.union([
                z.string().min(1),
                z.enum(['any']),
                z.null()
            ]),
            vpc: z.union([
                z.string(),
                z.null()
            ])
        })),
        label: z.optional(z.union([
            z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
            z.null()
        ])),
        primary: z.optional(z.boolean()),
        purpose: z.enum([
            'public',
            'vlan',
            'vpc'
        ]),
        subnet_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        vpc_id: z.optional(z.union([
            z.int().readonly(),
            z.null()
        ]).readonly())
    })).min(1).max(3),
    kernel: z.string().default('linode/latest-64bit'),
    label: z.string().min(1).max(48),
    memory_limit: z.int(),
    root_device: z.string().regex(/a-z, A-Z, 0-9, \/, _, -/),
    run_level: z.enum([
        'default',
        'single',
        'binbash'
    ]),
    virt_mode: z.enum(['paravirt', 'fullvirt'])
});

export const putLinodeConfigRequestSchema = z.object({
    body: z.object({
        comments: z.union([
            z.string(),
            z.null()
        ]),
        devices: z.object({
            sda: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdb: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdc: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdd: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sde: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdf: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdg: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdh: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            })
        }),
        helpers: z.object({
            devtmpfs_automount: z.boolean().default(false),
            distro: z.boolean(),
            modules_dep: z.boolean(),
            network: z.union([
                z.boolean(),
                z.null()
            ]),
            updatedb_disabled: z.boolean()
        }),
        id: z.int().readonly(),
        interfaces: z.array(z.object({
            active: z.optional(z.boolean().readonly()),
            id: z.optional(z.int().readonly()),
            ip_ranges: z.optional(z.union([
                z.array(z.string()),
                z.null()
            ])),
            ipam_address: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            ipv4: z.optional(z.object({
                nat_1_1: z.union([
                    z.string().min(1),
                    z.enum(['any']),
                    z.null()
                ]),
                vpc: z.union([
                    z.string(),
                    z.null()
                ])
            })),
            label: z.optional(z.union([
                z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
                z.null()
            ])),
            primary: z.optional(z.boolean()),
            purpose: z.enum([
                'public',
                'vlan',
                'vpc'
            ]),
            subnet_id: z.optional(z.union([
                z.int(),
                z.null()
            ])),
            vpc_id: z.optional(z.union([
                z.int().readonly(),
                z.null()
            ]).readonly())
        })).min(1).max(3),
        kernel: z.string().default('linode/latest-64bit'),
        label: z.string().min(1).max(48),
        memory_limit: z.int(),
        root_device: z.string().regex(/a-z, A-Z, 0-9, \/, _, -/),
        run_level: z.enum([
            'default',
            'single',
            'binbash'
        ]),
        virt_mode: z.enum(['paravirt', 'fullvirt'])
    }),
    path: z.object({
        linodeId: z.int(),
        configId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Configuration profile successfully updated.
 */
export const putLinodeConfigResponseSchema = z.object({
    comments: z.union([
        z.string(),
        z.null()
    ]),
    devices: z.object({
        sda: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdb: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdc: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdd: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sde: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdf: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdg: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        }),
        sdh: z.object({
            disk_id: z.int(),
            volume_id: z.union([
                z.int(),
                z.null()
            ])
        })
    }),
    helpers: z.object({
        devtmpfs_automount: z.boolean().default(false),
        distro: z.boolean(),
        modules_dep: z.boolean(),
        network: z.union([
            z.boolean(),
            z.null()
        ]),
        updatedb_disabled: z.boolean()
    }),
    id: z.int().readonly(),
    interfaces: z.array(z.object({
        active: z.optional(z.boolean().readonly()),
        id: z.optional(z.int().readonly()),
        ip_ranges: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ])),
        ipam_address: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        ipv4: z.optional(z.object({
            nat_1_1: z.union([
                z.string().min(1),
                z.enum(['any']),
                z.null()
            ]),
            vpc: z.union([
                z.string(),
                z.null()
            ])
        })),
        label: z.optional(z.union([
            z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
            z.null()
        ])),
        primary: z.optional(z.boolean()),
        purpose: z.enum([
            'public',
            'vlan',
            'vpc'
        ]),
        subnet_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        vpc_id: z.optional(z.union([
            z.int().readonly(),
            z.null()
        ]).readonly())
    })).min(1).max(3),
    kernel: z.string().default('linode/latest-64bit'),
    label: z.string().min(1).max(48),
    memory_limit: z.int(),
    root_device: z.string().regex(/a-z, A-Z, 0-9, \/, _, -/),
    run_level: z.enum([
        'default',
        'single',
        'binbash'
    ]),
    virt_mode: z.enum(['paravirt', 'fullvirt'])
});

export const getLinodeConfigInterfacesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        configId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * `interfaces` is applicable only to legacy configuration profiles and does not apply to [Linode interfaces](https://techdocs.akamai.com/linode-api/reference/post-linode-interface).
 *
 * From one to three network interfaces to add to this Linode's configuration profile. The position in the array determines which of the Linode's network interfaces is configured:
 *
 * - First [0]:  `eth0`
 * - Second [1]: `eth1`
 * - Third [2]:  `eth2`
 *
 * When updating a Linode's legacy interfaces, _each interface must be redefined_. An empty `interfaces` array results in a default `public` type interface configuration only.
 *
 * If no public Interface is configured, public IP addresses are still assigned to the Linode but will not be usable without manual configuration.
 *
 * > 
 * >
 * > Changes to Linode Interface configurations can be enabled by rebooting the Linode.
 *
 * `vpc` details
 *
 * See the [VPC documentation](https://www.linode.com/docs/products/networking/vpc/#technical-specifications) guide for its specifications and limitations.
 *
 * `vlan` details
 *
 * - Only Next Generation Network (NGN) data centers support VLANs. Run the [List regions](https://techdocs.akamai.com/linode-api/reference/get-regions) operation to view the capabilities of data center regions. If a VLAN is attached to your Linode and you attempt to migrate or clone it to a non-NGN data center, the migration or cloning will not initiate. If a Linode cannot be migrated or cloned because of an incompatibility, you will be prompted to select a different data center or contact support.
 * - See the [VLANs Overview](https://www.linode.com/docs/products/networking/vlans/#technical-specifications) guide to view additional specifications and limitations.
 */
export const getLinodeConfigInterfacesResponseSchema = z.array(z.object({
    active: z.optional(z.boolean().readonly()),
    id: z.optional(z.int().readonly()),
    ip_ranges: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    ipam_address: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    ipv4: z.optional(z.object({
        nat_1_1: z.union([
            z.string().min(1),
            z.enum(['any']),
            z.null()
        ]),
        vpc: z.union([
            z.string(),
            z.null()
        ])
    })),
    label: z.optional(z.union([
        z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
        z.null()
    ])),
    primary: z.optional(z.boolean()),
    purpose: z.enum([
        'public',
        'vlan',
        'vpc'
    ]),
    subnet_id: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    vpc_id: z.optional(z.union([
        z.int().readonly(),
        z.null()
    ]).readonly())
})).min(1).max(3);

export const postLinodeConfigInterfaceRequestSchema = z.object({
    body: z.intersection(z.unknown(), z.object({
        active: z.optional(z.boolean().readonly()),
        id: z.optional(z.int().readonly()),
        ip_ranges: z.optional(z.union([
            z.array(z.string()),
            z.null()
        ])),
        ipam_address: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        ipv4: z.optional(z.object({
            nat_1_1: z.union([
                z.string().min(1),
                z.enum(['any']),
                z.null()
            ]),
            vpc: z.union([
                z.string(),
                z.null()
            ])
        })),
        label: z.optional(z.union([
            z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
            z.null()
        ])),
        primary: z.optional(z.boolean()),
        purpose: z.enum([
            'public',
            'vlan',
            'vpc'
        ]),
        subnet_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        vpc_id: z.optional(z.union([
            z.int().readonly(),
            z.null()
        ]).readonly())
    })),
    path: z.object({
        linodeId: z.int(),
        configId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The network interface to apply to this Linode's configuration profile.
 */
export const postLinodeConfigInterfaceResponseSchema = z.object({
    active: z.optional(z.boolean().readonly()),
    id: z.optional(z.int().readonly()),
    ip_ranges: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    ipam_address: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    ipv4: z.optional(z.object({
        nat_1_1: z.union([
            z.string().min(1),
            z.enum(['any']),
            z.null()
        ]),
        vpc: z.union([
            z.string(),
            z.null()
        ])
    })),
    label: z.optional(z.union([
        z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
        z.null()
    ])),
    primary: z.optional(z.boolean()),
    purpose: z.enum([
        'public',
        'vlan',
        'vpc'
    ]),
    subnet_id: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    vpc_id: z.optional(z.union([
        z.int().readonly(),
        z.null()
    ]).readonly())
});

export const postLinodeConfigInterfacesRequestSchema = z.object({
    body: z.object({
        ids: z.array(z.int().readonly())
    }),
    path: z.object({
        linodeId: z.int(),
        configId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postLinodeConfigInterfacesResponseSchema = z.record(z.string(), z.unknown());

export const deleteLinodeConfigInterfaceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        configId: z.int(),
        interfaceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteLinodeConfigInterfaceResponseSchema = z.record(z.string(), z.unknown());

export const getLinodeConfigInterfaceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        configId: z.int(),
        interfaceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The network interface to apply to this Linode's configuration profile.
 */
export const getLinodeConfigInterfaceResponseSchema = z.object({
    active: z.optional(z.boolean().readonly()),
    id: z.optional(z.int().readonly()),
    ip_ranges: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    ipam_address: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    ipv4: z.optional(z.object({
        nat_1_1: z.union([
            z.string().min(1),
            z.enum(['any']),
            z.null()
        ]),
        vpc: z.union([
            z.string(),
            z.null()
        ])
    })),
    label: z.optional(z.union([
        z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
        z.null()
    ])),
    primary: z.optional(z.boolean()),
    purpose: z.enum([
        'public',
        'vlan',
        'vpc'
    ]),
    subnet_id: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    vpc_id: z.optional(z.union([
        z.int().readonly(),
        z.null()
    ]).readonly())
});

export const putLinodeConfigInterfaceRequestSchema = z.object({
    body: z.object({
        ip_ranges: z.array(z.string()),
        ipv4: z.object({
            nat_1_1: z.union([
                z.string().min(1),
                z.enum(['any']),
                z.null()
            ]),
            vpc: z.union([
                z.string(),
                z.null()
            ])
        }),
        primary: z.boolean()
    }),
    path: z.object({
        linodeId: z.int(),
        configId: z.int(),
        interfaceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The network interface to apply to this Linode's configuration profile.
 */
export const putLinodeConfigInterfaceResponseSchema = z.object({
    active: z.optional(z.boolean().readonly()),
    id: z.optional(z.int().readonly()),
    ip_ranges: z.optional(z.union([
        z.array(z.string()),
        z.null()
    ])),
    ipam_address: z.optional(z.union([
        z.string(),
        z.null()
    ])),
    ipv4: z.optional(z.object({
        nat_1_1: z.union([
            z.string(),
            z.null()
        ]),
        vpc: z.union([
            z.string(),
            z.null()
        ])
    })),
    label: z.optional(z.union([
        z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
        z.null()
    ])),
    primary: z.optional(z.boolean()),
    purpose: z.enum([
        'public',
        'vlan',
        'vpc'
    ]),
    subnet_id: z.optional(z.union([
        z.int(),
        z.null()
    ])),
    vpc_id: z.optional(z.union([
        z.int().readonly(),
        z.null()
    ]).readonly())
});

export const getLinodeDisksRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of disks associated with this Linode.
 */
export const getLinodeDisksResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        disk_encryption: z.string().readonly().default('enabled'),
        filesystem: z.enum([
            'raw',
            'swap',
            'ext2',
            'ext3',
            'ext4',
            'initrd'
        ]),
        id: z.int().readonly(),
        label: z.string().min(1).max(48),
        size: z.int(),
        status: z.enum([
            'ready',
            'not ready',
            'deleting'
        ]),
        updated: z.iso.datetime().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postAddLinodeDiskRequestSchema = z.object({
    body: z.object({
        authorized_keys: z.array(z.string()),
        authorized_users: z.array(z.string()),
        filesystem: z.enum([
            'raw',
            'swap',
            'ext2',
            'ext3',
            'ext4',
            'initrd'
        ]),
        image: z.union([
            z.string(),
            z.null()
        ]),
        label: z.string().min(1).max(48),
        root_pass: z.string().min(7).max(128),
        size: z.int(),
        stackscript_data: z.record(z.string(), z.unknown()),
        stackscript_id: z.int()
    }),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Disk created.
 */
export const postAddLinodeDiskResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    disk_encryption: z.string().readonly().default('enabled'),
    filesystem: z.enum([
        'raw',
        'swap',
        'ext2',
        'ext3',
        'ext4',
        'initrd'
    ]),
    id: z.int().readonly(),
    label: z.string().min(1).max(48),
    size: z.int(),
    status: z.enum([
        'ready',
        'not ready',
        'deleting'
    ]),
    updated: z.iso.datetime().readonly()
});

export const deleteDiskRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        diskId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteDiskResponseSchema = z.record(z.string(), z.unknown());

export const getLinodeDiskRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        diskId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a single Disk object.
 */
export const getLinodeDiskResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    disk_encryption: z.string().readonly().default('enabled'),
    filesystem: z.enum([
        'raw',
        'swap',
        'ext2',
        'ext3',
        'ext4',
        'initrd'
    ]),
    id: z.int().readonly(),
    label: z.string().min(1).max(48),
    size: z.int(),
    status: z.enum([
        'ready',
        'not ready',
        'deleting'
    ]),
    updated: z.iso.datetime().readonly()
});

export const putDiskRequestSchema = z.object({
    body: z.object({
        label: z.string().min(1).max(48)
    }),
    path: z.object({
        linodeId: z.int(),
        diskId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The updated Disk.
 */
export const putDiskResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    disk_encryption: z.string().readonly().default('enabled'),
    filesystem: z.enum([
        'raw',
        'swap',
        'ext2',
        'ext3',
        'ext4',
        'initrd'
    ]),
    id: z.int().readonly(),
    label: z.string().min(1).max(48),
    size: z.int(),
    status: z.enum([
        'ready',
        'not ready',
        'deleting'
    ]),
    updated: z.iso.datetime().readonly()
});

export const postCloneLinodeDiskRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        diskId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Disk clone initiated.
 */
export const postCloneLinodeDiskResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    disk_encryption: z.string().readonly().default('enabled'),
    filesystem: z.enum([
        'raw',
        'swap',
        'ext2',
        'ext3',
        'ext4',
        'initrd'
    ]),
    id: z.int().readonly(),
    label: z.string().min(1).max(48),
    size: z.int(),
    status: z.enum([
        'ready',
        'not ready',
        'deleting'
    ]),
    updated: z.iso.datetime().readonly()
});

export const postResetDiskPasswordRequestSchema = z.object({
    body: z.object({
        password: z.string()
    }),
    path: z.object({
        linodeId: z.int(),
        diskId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postResetDiskPasswordResponseSchema = z.record(z.string(), z.unknown());

export const postResizeDiskRequestSchema = z.object({
    body: z.object({
        size: z.int().gte(1)
    }),
    path: z.object({
        linodeId: z.int(),
        diskId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postResizeDiskResponseSchema = z.record(z.string(), z.unknown());

export const getLinodeFirewallsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of Firewalls assigned to this Linode.
 */
export const getLinodeFirewallsResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        entities: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            parent_entity: z.union([
                z.object({
                    id: z.int(),
                    label: z.string(),
                    parent_entity: z.union([
                        z.string().readonly(),
                        z.null()
                    ]).readonly(),
                    type: z.enum(['linode']),
                    url: z.string()
                }).readonly(),
                z.null()
            ]).readonly(),
            type: z.enum([
                'linode',
                'linode_interface',
                'nodebalancer'
            ]),
            url: z.string().readonly()
        })).readonly(),
        id: z.int().readonly(),
        label: z.string().min(3).max(32).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
        rules: z.object({
            fingerprint: z.string().readonly(),
            inbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            inbound_policy: z.enum(['ACCEPT', 'DROP']),
            outbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            outbound_policy: z.enum(['ACCEPT', 'DROP']),
            version: z.int().readonly()
        }),
        status: z.enum([
            'enabled',
            'disabled',
            'deleted'
        ]),
        tags: z.array(z.string()),
        updated: z.iso.datetime().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const putLinodeFirewallsRequestSchema = z.object({
    body: z.object({
        firewall_ids: z.array(z.int()).min(0)
    }),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of Firewalls assigned to this Linode.
 */
export const putLinodeFirewallsResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        entities: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            parent_entity: z.union([
                z.object({
                    id: z.int(),
                    label: z.string(),
                    parent_entity: z.union([
                        z.string().readonly(),
                        z.null()
                    ]).readonly(),
                    type: z.enum(['linode']),
                    url: z.string()
                }).readonly(),
                z.null()
            ]).readonly(),
            type: z.enum([
                'linode',
                'linode_interface',
                'nodebalancer'
            ]),
            url: z.string().readonly()
        })).readonly(),
        id: z.int().readonly(),
        label: z.string().min(3).max(32).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
        rules: z.object({
            fingerprint: z.string().readonly(),
            inbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            inbound_policy: z.enum(['ACCEPT', 'DROP']),
            outbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            outbound_policy: z.enum(['ACCEPT', 'DROP']),
            version: z.int().readonly()
        }),
        status: z.enum([
            'enabled',
            'disabled',
            'deleted'
        ]),
        tags: z.array(z.string()),
        updated: z.iso.datetime().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postApplyFirewallsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postApplyFirewallsResponseSchema = z.record(z.string(), z.unknown());

export const getLinodeInterfacesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A list of all the interfaces available for a Linode.
 */
export const getLinodeInterfacesResponseSchema = z.object({
    interfaces: z.array(z.union([
        z.object({
            created: z.iso.datetime(),
            default_route: z.union([
                z.object({
                    ipv4: z.boolean().default(false),
                    ipv6: z.boolean().default(false)
                }),
                z.null()
            ]),
            id: z.int().readonly(),
            mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
            public: z.object({
                ipv4: z.object({
                    addresses: z.array(z.object({
                        address: z.string(),
                        primary: z.boolean()
                    })),
                    shared: z.array(z.object({
                        address: z.string(),
                        linode_id: z.string()
                    }))
                }),
                ipv6: z.object({
                    ranges: z.array(z.object({
                        range: z.string(),
                        route_target: z.string()
                    })),
                    shared: z.array(z.object({
                        range: z.string(),
                        route_target: z.string()
                    })),
                    slaac: z.array(z.object({
                        address: z.string(),
                        prefix: z.int()
                    }))
                })
            }),
            updated: z.iso.datetime(),
            version: z.int(),
            vlan: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ]),
            vpc: z.union([
                z.record(z.string(), z.never()),
                z.null()
            ])
        }),
        z.object({
            created: z.iso.datetime(),
            id: z.int().readonly(),
            mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
            public: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ]),
            updated: z.iso.datetime(),
            version: z.int(),
            vlan: z.object({
                ipam_address: z.union([
                    z.string(),
                    z.null()
                ]),
                vlan_label: z.string()
            }),
            vpc: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ])
        }),
        z.object({
            created: z.iso.datetime(),
            default_route: z.object({
                ipv4: z.boolean().default(false)
            }),
            id: z.int().readonly(),
            mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
            public: z.union([
                z.record(z.string(), z.never()),
                z.null()
            ]),
            updated: z.iso.datetime(),
            version: z.int(),
            vlan: z.union([
                z.record(z.string(), z.never()),
                z.null()
            ]),
            vpc: z.object({
                ipv4: z.object({
                    addresses: z.array(z.object({
                        address: z.string(),
                        nat_1_1_address: z.union([
                            z.string(),
                            z.null()
                        ]),
                        primary: z.boolean()
                    })),
                    ranges: z.array(z.object({
                        range: z.string()
                    }))
                }),
                subnet_id: z.int(),
                vpc_id: z.int()
            })
        })
    ]))
});

export const postLinodeInterfaceRequestSchema = z.object({
    body: z.optional(z.union([
        z.object({
            default_route: z.object({
                ipv4: z.union([
                    z.boolean(),
                    z.null()
                ]),
                ipv6: z.union([
                    z.boolean(),
                    z.null()
                ])
            }),
            firewall_id: z.union([
                z.int(),
                z.null()
            ]),
            public: z.union([
                z.object({
                    ipv4: z.object({
                        addresses: z.array(z.object({
                            address: z.union([
                                z.string().min(1),
                                z.enum(['auto']),
                                z.string()
                            ]),
                            primary: z.boolean().default(false)
                        }))
                    }),
                    ipv6: z.object({
                        ranges: z.array(z.object({
                            range: z.string()
                        }))
                    })
                }),
                z.null()
            ])
        }),
        z.object({
            vlan: z.union([
                z.object({
                    ipam_address: z.string(),
                    vlan_label: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/)
                }),
                z.null()
            ])
        }),
        z.object({
            default_route: z.object({
                ipv4: z.union([
                    z.boolean(),
                    z.null()
                ])
            }),
            firewall_id: z.union([
                z.int(),
                z.null()
            ]),
            vpc: z.union([
                z.object({
                    ipv4: z.optional(z.object({
                        addresses: z.array(z.object({
                            address: z.union([
                                z.string().min(1),
                                z.enum(['auto'])
                            ]),
                            nat_1_1_address: z.union([
                                z.string().min(1),
                                z.enum(['auto']),
                                z.null()
                            ]),
                            primary: z.union([
                                z.boolean().default(false),
                                z.null()
                            ]).default(false)
                        })),
                        ranges: z.array(z.object({
                            range: z.string()
                        }))
                    })),
                    subnet_id: z.int()
                }),
                z.null()
            ])
        })
    ])),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * One of the following interface types: VPC, public, or VLAN.
 */
export const postLinodeInterfaceResponseSchema = z.union([
    z.object({
        created: z.iso.datetime(),
        default_route: z.union([
            z.object({
                ipv4: z.boolean().default(false),
                ipv6: z.boolean().default(false)
            }),
            z.null()
        ]),
        id: z.int().readonly(),
        mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
        public: z.object({
            ipv4: z.object({
                addresses: z.array(z.object({
                    address: z.string(),
                    primary: z.boolean()
                })),
                shared: z.array(z.object({
                    address: z.string(),
                    linode_id: z.string()
                }))
            }),
            ipv6: z.object({
                ranges: z.array(z.object({
                    range: z.string(),
                    route_target: z.string()
                })),
                shared: z.array(z.object({
                    range: z.string(),
                    route_target: z.string()
                })),
                slaac: z.array(z.object({
                    address: z.string(),
                    prefix: z.int()
                }))
            })
        }),
        updated: z.iso.datetime(),
        version: z.int(),
        vlan: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]),
        vpc: z.union([
            z.record(z.string(), z.never()),
            z.null()
        ])
    }),
    z.object({
        created: z.iso.datetime(),
        id: z.int().readonly(),
        mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
        public: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]),
        updated: z.iso.datetime(),
        version: z.int(),
        vlan: z.object({
            ipam_address: z.union([
                z.string(),
                z.null()
            ]),
            vlan_label: z.string()
        }),
        vpc: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])
    }),
    z.object({
        created: z.iso.datetime(),
        default_route: z.object({
            ipv4: z.boolean().default(false)
        }),
        id: z.int().readonly(),
        mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
        public: z.union([
            z.record(z.string(), z.never()),
            z.null()
        ]),
        updated: z.iso.datetime(),
        version: z.int(),
        vlan: z.union([
            z.record(z.string(), z.never()),
            z.null()
        ]),
        vpc: z.object({
            ipv4: z.object({
                addresses: z.array(z.object({
                    address: z.string(),
                    nat_1_1_address: z.union([
                        z.string(),
                        z.null()
                    ]),
                    primary: z.boolean()
                })),
                ranges: z.array(z.object({
                    range: z.string()
                }))
            }),
            subnet_id: z.int(),
            vpc_id: z.int()
        })
    })
]);

export const getLinodeInterfaceHistoryRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of network interface versions for a Linode.
 */
export const getLinodeInterfaceHistoryResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        interface_data: z.string(),
        interface_history_id: z.int().readonly(),
        interface_id: z.int().readonly(),
        linode_id: z.int().readonly(),
        version: z.int().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getLinodeInterfaceSettingsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Linode interface settings.
 */
export const getLinodeInterfaceSettingsResponseSchema = z.object({
    default_route: z.object({
        ipv4_eligible_interface_ids: z.array(z.int().readonly()),
        ipv4_interface_id: z.union([
            z.int(),
            z.null()
        ]).default(null),
        ipv6_eligible_interface_ids: z.array(z.int().readonly()),
        ipv6_interface_id: z.union([
            z.int(),
            z.null()
        ]).default(null)
    }),
    network_helper: z.boolean()
});

export const putLinodeInterfaceSettingsRequestSchema = z.object({
    body: z.object({
        default_route: z.object({
            ipv4_eligible_interface_ids: z.array(z.int().readonly()),
            ipv4_interface_id: z.union([
                z.int(),
                z.null()
            ]).default(null),
            ipv6_eligible_interface_ids: z.array(z.int().readonly()),
            ipv6_interface_id: z.union([
                z.int(),
                z.null()
            ]).default(null)
        }),
        network_helper: z.boolean()
    }),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Linode interface settings.
 */
export const putLinodeInterfaceSettingsResponseSchema = z.object({
    default_route: z.object({
        ipv4_eligible_interface_ids: z.array(z.int().readonly()),
        ipv4_interface_id: z.union([
            z.int(),
            z.null()
        ]).default(null),
        ipv6_eligible_interface_ids: z.array(z.int().readonly()),
        ipv6_interface_id: z.union([
            z.int(),
            z.null()
        ]).default(null)
    }),
    network_helper: z.boolean()
});

export const deleteLinodeInterfaceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        interfaceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteLinodeInterfaceResponseSchema = z.record(z.string(), z.unknown());

export const getLinodeInterfaceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        interfaceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * One of the following interface types: VPC, public, or VLAN.
 */
export const getLinodeInterfaceResponseSchema = z.union([
    z.object({
        created: z.iso.datetime(),
        default_route: z.union([
            z.object({
                ipv4: z.boolean().default(false),
                ipv6: z.boolean().default(false)
            }),
            z.null()
        ]),
        id: z.int().readonly(),
        mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
        public: z.object({
            ipv4: z.object({
                addresses: z.array(z.object({
                    address: z.string(),
                    primary: z.boolean()
                })),
                shared: z.array(z.object({
                    address: z.string(),
                    linode_id: z.string()
                }))
            }),
            ipv6: z.object({
                ranges: z.array(z.object({
                    range: z.string(),
                    route_target: z.string()
                })),
                shared: z.array(z.object({
                    range: z.string(),
                    route_target: z.string()
                })),
                slaac: z.array(z.object({
                    address: z.string(),
                    prefix: z.int()
                }))
            })
        }),
        updated: z.iso.datetime(),
        version: z.int(),
        vlan: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]),
        vpc: z.union([
            z.record(z.string(), z.never()),
            z.null()
        ])
    }),
    z.object({
        created: z.iso.datetime(),
        id: z.int().readonly(),
        mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
        public: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]),
        updated: z.iso.datetime(),
        version: z.int(),
        vlan: z.object({
            ipam_address: z.union([
                z.string(),
                z.null()
            ]),
            vlan_label: z.string()
        }),
        vpc: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])
    }),
    z.object({
        created: z.iso.datetime(),
        default_route: z.object({
            ipv4: z.boolean().default(false)
        }),
        id: z.int().readonly(),
        mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
        public: z.union([
            z.record(z.string(), z.never()),
            z.null()
        ]),
        updated: z.iso.datetime(),
        version: z.int(),
        vlan: z.union([
            z.record(z.string(), z.never()),
            z.null()
        ]),
        vpc: z.object({
            ipv4: z.object({
                addresses: z.array(z.object({
                    address: z.string(),
                    nat_1_1_address: z.union([
                        z.string(),
                        z.null()
                    ]),
                    primary: z.boolean()
                })),
                ranges: z.array(z.object({
                    range: z.string()
                }))
            }),
            subnet_id: z.int(),
            vpc_id: z.int()
        })
    })
]);

export const putLinodeInterfaceRequestSchema = z.object({
    body: z.union([
        z.object({
            default_route: z.object({
                ipv4: z.union([
                    z.boolean(),
                    z.null()
                ]),
                ipv6: z.union([
                    z.boolean(),
                    z.null()
                ])
            }),
            public: z.union([
                z.object({
                    ipv4: z.object({
                        addresses: z.array(z.object({
                            address: z.string().default('auto'),
                            primary: z.union([
                                z.boolean(),
                                z.null()
                            ])
                        }))
                    }),
                    ipv6: z.object({
                        ranges: z.array(z.object({
                            range: z.string().default(null)
                        }))
                    })
                }),
                z.null()
            ])
        }),
        z.object({
            vlan: z.object({
                ipam_address: z.union([
                    z.string(),
                    z.null()
                ]),
                vlan_label: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/)
            })
        }),
        z.object({
            default_route: z.object({
                ipv4: z.union([
                    z.boolean(),
                    z.null()
                ])
            }),
            vpc: z.union([
                z.object({
                    ipv4: z.optional(z.object({
                        addresses: z.array(z.object({
                            address: z.string().default('auto'),
                            nat_1_1_address: z.optional(z.string()).default(null),
                            primary: z.optional(z.union([
                                z.boolean(),
                                z.null()
                            ]))
                        })),
                        ranges: z.array(z.object({
                            range: z.union([
                                z.string(),
                                z.null()
                            ]).default(null)
                        }))
                    })),
                    subnet_id: z.int()
                }),
                z.null()
            ])
        })
    ]),
    path: z.object({
        linodeId: z.int(),
        interfaceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * One of the following interface types: VPC, public, or VLAN.
 */
export const putLinodeInterfaceResponseSchema = z.union([
    z.object({
        created: z.iso.datetime(),
        default_route: z.union([
            z.object({
                ipv4: z.boolean().default(false),
                ipv6: z.boolean().default(false)
            }),
            z.null()
        ]),
        id: z.int().readonly(),
        mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
        public: z.object({
            ipv4: z.object({
                addresses: z.array(z.object({
                    address: z.string(),
                    primary: z.boolean()
                })),
                shared: z.array(z.object({
                    address: z.string(),
                    linode_id: z.string()
                }))
            }),
            ipv6: z.object({
                ranges: z.array(z.object({
                    range: z.string(),
                    route_target: z.string()
                })),
                shared: z.array(z.object({
                    range: z.string(),
                    route_target: z.string()
                })),
                slaac: z.array(z.object({
                    address: z.string(),
                    prefix: z.int()
                }))
            })
        }),
        updated: z.iso.datetime(),
        version: z.int(),
        vlan: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]),
        vpc: z.union([
            z.record(z.string(), z.never()),
            z.null()
        ])
    }),
    z.object({
        created: z.iso.datetime(),
        id: z.int().readonly(),
        mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
        public: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ]),
        updated: z.iso.datetime(),
        version: z.int(),
        vlan: z.object({
            ipam_address: z.union([
                z.string(),
                z.null()
            ]),
            vlan_label: z.string()
        }),
        vpc: z.union([
            z.record(z.string(), z.unknown()),
            z.null()
        ])
    }),
    z.object({
        created: z.iso.datetime(),
        default_route: z.object({
            ipv4: z.boolean().default(false)
        }),
        id: z.int().readonly(),
        mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
        public: z.union([
            z.record(z.string(), z.never()),
            z.null()
        ]),
        updated: z.iso.datetime(),
        version: z.int(),
        vlan: z.union([
            z.record(z.string(), z.never()),
            z.null()
        ]),
        vpc: z.object({
            ipv4: z.object({
                addresses: z.array(z.object({
                    address: z.string(),
                    nat_1_1_address: z.union([
                        z.string(),
                        z.null()
                    ]),
                    primary: z.boolean()
                })),
                ranges: z.array(z.object({
                    range: z.string()
                }))
            }),
            subnet_id: z.int(),
            vpc_id: z.int()
        })
    })
]);

export const getLinodeInterfaceFirewallsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        interfaceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of firewalls assigned to an interface.
 */
export const getLinodeInterfaceFirewallsResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        entities: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            parent_entity: z.union([
                z.object({
                    id: z.int(),
                    label: z.string(),
                    parent_entity: z.union([
                        z.string().readonly(),
                        z.null()
                    ]).readonly(),
                    type: z.enum(['linode']),
                    url: z.string()
                }).readonly(),
                z.null()
            ]).readonly(),
            type: z.enum([
                'linode',
                'linode_interface',
                'nodebalancer'
            ]),
            url: z.string().readonly()
        })).readonly(),
        id: z.int().readonly(),
        label: z.string().min(3).max(32).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
        rules: z.object({
            fingerprint: z.string().readonly(),
            inbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            inbound_policy: z.enum(['ACCEPT', 'DROP']),
            outbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            outbound_policy: z.enum(['ACCEPT', 'DROP']),
            version: z.int().readonly()
        }),
        status: z.enum([
            'enabled',
            'disabled',
            'deleted'
        ]),
        tags: z.array(z.string()),
        updated: z.iso.datetime().readonly()
    }))
}));

export const getLinodeIpsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Requested Linode's networking configuration.
 */
export const getLinodeIpsResponseSchema = z.object({
    ipv4: z.object({
        private: z.array(z.object({
            address: z.string().readonly(),
            gateway: z.union([
                z.string().readonly(),
                z.null()
            ]).readonly(),
            linode_id: z.int().readonly(),
            prefix: z.int().readonly(),
            public: z.boolean().readonly(),
            rdns: z.union([
                z.string(),
                z.null()
            ]),
            region: z.string().readonly(),
            subnet_mask: z.string().readonly(),
            type: z.string().readonly()
        })).readonly(),
        public: z.array(z.object({
            address: z.string().readonly(),
            gateway: z.union([
                z.string().readonly(),
                z.null()
            ]).readonly(),
            interface_id: z.union([
                z.int().readonly(),
                z.null()
            ]).readonly(),
            linode_id: z.int().readonly(),
            prefix: z.int().readonly(),
            public: z.boolean().readonly(),
            rdns: z.union([
                z.string(),
                z.null()
            ]),
            region: z.string().readonly(),
            subnet_mask: z.string().readonly(),
            type: z.enum([
                'ipv4',
                'ipv6',
                'ipv6/pool',
                'ipv6/range'
            ]),
            vpc_nat_1_1: z.object({
                address: z.ipv4(),
                subnet_id: z.int(),
                vpc_id: z.int().readonly()
            })
        })).readonly(),
        reserved: z.array(z.object({
            address: z.string().readonly(),
            gateway: z.union([
                z.string().readonly(),
                z.null()
            ]).readonly(),
            interface_id: z.union([
                z.int().readonly(),
                z.null()
            ]).readonly(),
            linode_id: z.int().readonly(),
            prefix: z.int().readonly(),
            public: z.boolean().readonly(),
            rdns: z.union([
                z.string(),
                z.null()
            ]),
            region: z.string().readonly(),
            subnet_mask: z.string().readonly(),
            type: z.enum([
                'ipv4',
                'ipv6',
                'ipv6/pool',
                'ipv6/range'
            ]),
            vpc_nat_1_1: z.object({
                address: z.ipv4(),
                subnet_id: z.int(),
                vpc_id: z.int().readonly()
            })
        })).readonly(),
        shared: z.array(z.object({
            address: z.string().readonly(),
            gateway: z.union([
                z.string().readonly(),
                z.null()
            ]).readonly(),
            interface_id: z.union([
                z.int().readonly(),
                z.null()
            ]).readonly(),
            linode_id: z.int().readonly(),
            prefix: z.int().readonly(),
            public: z.boolean().readonly(),
            rdns: z.union([
                z.string(),
                z.null()
            ]),
            region: z.string().readonly(),
            subnet_mask: z.string().readonly(),
            type: z.enum([
                'ipv4',
                'ipv6',
                'ipv6/pool',
                'ipv6/range'
            ]),
            vpc_nat_1_1: z.object({
                address: z.ipv4(),
                subnet_id: z.int(),
                vpc_id: z.int().readonly()
            })
        })).readonly(),
        vpc: z.array(z.object({
            active: z.boolean().readonly(),
            address: z.union([
                z.string().readonly(),
                z.null()
            ]).readonly(),
            address_range: z.union([
                z.string().readonly(),
                z.null()
            ]).readonly(),
            config_id: z.union([
                z.int().readonly(),
                z.null()
            ]).readonly(),
            gateway: z.union([
                z.string().readonly(),
                z.null()
            ]).readonly(),
            interface_id: z.int().readonly(),
            linode_id: z.int().readonly(),
            nat_1_1: z.string().readonly(),
            prefix: z.union([
                z.int().readonly(),
                z.null()
            ]).readonly(),
            region: z.string().readonly(),
            subnet_id: z.int(),
            subnet_mask: z.string().readonly(),
            vpc_id: z.int().readonly()
        })).readonly()
    }).readonly(),
    ipv6: z.object({
        global: z.array(z.object({
            prefix: z.int(),
            range: z.string().readonly(),
            region: z.string().readonly(),
            route_target: z.string()
        })),
        link_local: z.object({
            address: z.string().readonly(),
            gateway: z.string().readonly(),
            linode_id: z.int().readonly(),
            prefix: z.int().readonly(),
            public: z.boolean().readonly(),
            rdns: z.union([
                z.string(),
                z.null()
            ]),
            region: z.string().readonly(),
            subnet_mask: z.string().readonly(),
            type: z.string().readonly()
        }),
        slaac: z.object({
            address: z.string().readonly(),
            gateway: z.string().readonly(),
            linode_id: z.int().readonly(),
            prefix: z.int().readonly(),
            public: z.boolean().readonly(),
            rdns: z.union([
                z.string(),
                z.null()
            ]),
            region: z.string().readonly(),
            subnet_mask: z.string().readonly(),
            type: z.string().readonly()
        })
    }).readonly()
});

export const postAddLinodeIpRequestSchema = z.object({
    body: z.object({
        public: z.boolean(),
        type: z.enum(['ipv4'])
    }),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * An IP address that exists in Linode's system, either IPv4 or IPv6.
 */
export const postAddLinodeIpResponseSchema = z.object({
    address: z.string().readonly(),
    gateway: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    interface_id: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    linode_id: z.int().readonly(),
    prefix: z.int().readonly(),
    public: z.boolean().readonly(),
    rdns: z.union([
        z.string(),
        z.null()
    ]),
    region: z.string().readonly(),
    subnet_mask: z.string().readonly(),
    type: z.enum([
        'ipv4',
        'ipv6',
        'ipv6/pool',
        'ipv6/range'
    ]),
    vpc_nat_1_1: z.object({
        address: z.ipv4(),
        subnet_id: z.int(),
        vpc_id: z.int().readonly()
    })
});

export const deleteLinodeIpRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        address: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteLinodeIpResponseSchema = z.record(z.string(), z.unknown());

export const getLinodeIpRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        address: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * An IP address that exists in Linode's system, either IPv4 or IPv6.
 */
export const getLinodeIpResponseSchema = z.object({
    address: z.string().readonly(),
    gateway: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    interface_id: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    linode_id: z.int().readonly(),
    prefix: z.int().readonly(),
    public: z.boolean().readonly(),
    rdns: z.union([
        z.string(),
        z.null()
    ]),
    region: z.string().readonly(),
    subnet_mask: z.string().readonly(),
    type: z.enum([
        'ipv4',
        'ipv6',
        'ipv6/pool',
        'ipv6/range'
    ]),
    vpc_nat_1_1: z.object({
        address: z.ipv4(),
        subnet_id: z.int(),
        vpc_id: z.int().readonly()
    })
});

export const putLinodeIpRequestSchema = z.object({
    body: z.optional(z.object({
        rdns: z.union([
            z.string(),
            z.null()
        ])
    })),
    path: z.object({
        linodeId: z.int(),
        address: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * An IP address that exists in Linode's system, either IPv4 or IPv6.
 */
export const putLinodeIpResponseSchema = z.object({
    address: z.string().readonly(),
    gateway: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    interface_id: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    linode_id: z.int().readonly(),
    prefix: z.int().readonly(),
    public: z.boolean().readonly(),
    rdns: z.union([
        z.string(),
        z.null()
    ]),
    region: z.string().readonly(),
    subnet_mask: z.string().readonly(),
    type: z.enum([
        'ipv4',
        'ipv6',
        'ipv6/pool',
        'ipv6/range'
    ]),
    vpc_nat_1_1: z.object({
        address: z.ipv4(),
        subnet_id: z.int(),
        vpc_id: z.int().readonly()
    })
});

export const postMigrateLinodeInstanceRequestSchema = z.object({
    body: z.optional(z.object({
        placement_group: z.object({
            id: z.int()
        }),
        region: z.string(),
        type: z.enum(['warm', 'cold']),
        upgrade: z.boolean().default(false)
    })),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postMigrateLinodeInstanceResponseSchema = z.record(z.string(), z.unknown());

export const postMutateLinodeInstanceRequestSchema = z.object({
    body: z.optional(z.object({
        allow_auto_disk_resize: z.boolean().default(true)
    })),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postMutateLinodeInstanceResponseSchema = z.record(z.string(), z.unknown());

export const getLinodeNodeBalancersRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of NodeBalancers.
 */
export const getLinodeNodeBalancersResponseSchema = z.object({
    data: z.array(z.object({
        client_conn_throttle: z.int().gte(0).lte(20),
        created: z.iso.datetime().readonly(),
        hostname: z.string().readonly(),
        id: z.int().readonly(),
        ipv4: z.string().readonly(),
        ipv6: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_]{3,32}/),
        lke_cluster: z.union([
            z.object({
                id: z.string(),
                label: z.string(),
                type: z.string().readonly(),
                url: z.string()
            }).readonly(),
            z.null()
        ]).readonly(),
        region: z.string().readonly(),
        tags: z.array(z.string()),
        transfer: z.object({
            in: z.union([
                z.number().readonly(),
                z.null()
            ]).readonly(),
            out: z.union([
                z.number().readonly(),
                z.null()
            ]).readonly(),
            total: z.union([
                z.number().readonly(),
                z.null()
            ]).readonly()
        }).readonly(),
        type: z.enum(['common', 'premium']),
        updated: z.iso.datetime().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postResetLinodePasswordRequestSchema = z.object({
    body: z.optional(z.object({
        root_pass: z.string()
    })),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postResetLinodePasswordResponseSchema = z.record(z.string(), z.unknown());

export const postRebootLinodeInstanceRequestSchema = z.object({
    body: z.optional(z.object({
        config_id: z.union([
            z.int(),
            z.null()
        ])
    })),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postRebootLinodeInstanceResponseSchema = z.record(z.string(), z.unknown());

export const postRebuildLinodeInstanceRequestSchema = z.object({
    body: z.object({
        authorized_keys: z.array(z.string()),
        authorized_users: z.array(z.string()),
        booted: z.boolean().default(true),
        disk_encryption: z.enum(['enabled', 'disabled']),
        image: z.union([
            z.string(),
            z.null()
        ]),
        maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
        metadata: z.object({
            user_data: z.string()
        }),
        root_pass: z.string().min(7).max(128),
        stackscript_data: z.record(z.string(), z.unknown()),
        stackscript_id: z.int()
    }).and(z.object({
        type: z.string()
    })),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Linode
 *
 * Rebuild started.
 */
export const postRebuildLinodeInstanceResponseSchema = z.object({
    alerts: z.object({
        cpu: z.int(),
        io: z.int(),
        network_in: z.int(),
        network_out: z.int(),
        transfer_quota: z.int()
    }),
    backups: z.object({
        available: z.boolean().readonly(),
        enabled: z.boolean().readonly(),
        last_successful: z.iso.datetime().readonly(),
        schedule: z.object({
            day: z.enum([
                'Scheduling',
                'Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday'
            ]),
            window: z.enum([
                'Scheduling',
                'W0',
                'W2',
                'W4',
                'W6',
                'W8',
                'W10',
                'W12',
                'W14',
                'W16',
                'W18',
                'W20',
                'W22'
            ])
        })
    }),
    capabilities: z.array(z.string()).readonly(),
    created: z.iso.datetime().readonly(),
    disk_encryption: z.union([
        z.string().readonly().default('enabled'),
        z.null()
    ]).readonly().default('enabled'),
    group: z.string(),
    has_user_data: z.boolean().readonly(),
    host_uuid: z.uuid().readonly(),
    hypervisor: z.enum(['kvm']),
    id: z.int().readonly(),
    image: z.union([
        z.string(),
        z.null()
    ]),
    interface_generation: z.enum(['legacy_config', 'linode']),
    ipv4: z.array(z.string()).readonly(),
    ipv6: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    label: z.string().min(3).max(64).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
    lke_cluster_id: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
    placement_group: z.union([
        z.object({
            id: z.int(),
            label: z.string().min(1),
            placement_group_policy: z.enum(['strict', 'flexible']),
            placement_group_type: z.enum(['anti_affinity:local'])
        }).readonly(),
        z.null()
    ]).readonly(),
    region: z.string().readonly(),
    specs: z.object({
        disk: z.int().readonly(),
        gpus: z.int().readonly(),
        memory: z.int().readonly(),
        transfer: z.int().readonly(),
        vcpus: z.int().readonly()
    }).readonly(),
    status: z.enum([
        'running',
        'offline',
        'booting',
        'busy',
        'rebooting',
        'shutting_down',
        'provisioning',
        'deleting',
        'migrating',
        'rebuilding',
        'cloning',
        'restoring',
        'stopped',
        'billing_suspension'
    ]),
    tags: z.array(z.string()),
    type: z.string().readonly(),
    updated: z.iso.datetime().readonly(),
    watchdog_enabled: z.boolean()
});

export const postRescueLinodeInstanceRequestSchema = z.object({
    body: z.optional(z.object({
        devices: z.object({
            sda: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdb: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdc: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdd: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sde: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdf: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            }),
            sdg: z.object({
                disk_id: z.int(),
                volume_id: z.union([
                    z.int(),
                    z.null()
                ])
            })
        })
    })),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postRescueLinodeInstanceResponseSchema = z.record(z.string(), z.unknown());

export const postResizeLinodeInstanceRequestSchema = z.object({
    body: z.object({
        allow_auto_disk_resize: z.optional(z.boolean()).default(true),
        migration_type: z.optional(z.enum(['warm', 'cold'])),
        type: z.string()
    }),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postResizeLinodeInstanceResponseSchema = z.record(z.string(), z.unknown());

export const postShutdownLinodeInstanceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Shutdown started.
 */
export const postShutdownLinodeInstanceResponseSchema = z.record(z.string(), z.unknown());

export const getLinodeStatsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * __Read-only__ CPU, IO, IPv4, and IPv6 statistics. Graph data, if available, is in `[timestamp, reading]` array format. Timestamp is a UNIX timestamp in EST.
 */
export const getLinodeStatsResponseSchema = z.object({
    cpu: z.array(z.array(z.number())),
    io: z.object({
        io: z.array(z.array(z.number())),
        swap: z.array(z.array(z.number()))
    }),
    netv4: z.object({
        in: z.array(z.array(z.number())),
        out: z.array(z.array(z.number())),
        private_in: z.array(z.array(z.number())),
        private_out: z.array(z.array(z.number()))
    }),
    netv6: z.object({
        in: z.array(z.array(z.number())),
        out: z.array(z.array(z.number())),
        private_in: z.array(z.array(z.number())),
        private_out: z.array(z.array(z.number()))
    }),
    title: z.string()
}).readonly();

export const getLinodeStatsByYearMonthRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        year: z.int().gte(2000).lte(2037),
        month: z.int().gte(1).lte(12)
    }),
    query: z.optional(z.never())
});

/**
 * __Read-only__ CPU, IO, IPv4, and IPv6 statistics. Graph data, if available, is in `[timestamp, reading]` array format. Timestamp is a UNIX timestamp in EST.
 */
export const getLinodeStatsByYearMonthResponseSchema = z.object({
    cpu: z.array(z.array(z.number())),
    io: z.object({
        io: z.array(z.array(z.number())),
        swap: z.array(z.array(z.number()))
    }),
    netv4: z.object({
        in: z.array(z.array(z.number())),
        out: z.array(z.array(z.number())),
        private_in: z.array(z.array(z.number())),
        private_out: z.array(z.array(z.number()))
    }),
    netv6: z.object({
        in: z.array(z.array(z.number())),
        out: z.array(z.array(z.number())),
        private_in: z.array(z.array(z.number())),
        private_out: z.array(z.array(z.number()))
    }),
    title: z.string()
}).readonly();

export const getLinodeTransferRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A collection of the specified Linode's network transfer statistics.
 */
export const getLinodeTransferResponseSchema = z.object({
    billable: z.int().readonly(),
    quota: z.int().readonly(),
    used: z.int().readonly()
});

export const getLinodeTransferByYearMonthRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int(),
        year: z.int().gte(2000).lte(2037),
        month: z.int().gte(1).lte(12)
    }),
    query: z.optional(z.never())
});

/**
 * A collection of the specified Linode's network transfer statistics for the requested month.
 */
export const getLinodeTransferByYearMonthResponseSchema = z.object({
    bytes_in: z.int().readonly(),
    bytes_out: z.int().readonly(),
    bytes_total: z.int().readonly()
});

export const postUpgradeLinodeInterfacesRequestSchema = z.object({
    body: z.optional(z.union([
        z.object({
            config_id: z.union([
                z.int(),
                z.null()
            ]).default(null),
            dry_run: z.boolean().default(true)
        }),
        z.null()
    ])),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Upgraded interfaces
 */
export const postUpgradeLinodeInterfacesResponseSchema = z.object({
    config_id: z.int(),
    dry_run: z.boolean(),
    interfaces: z.array(z.union([
        z.object({
            created: z.iso.datetime(),
            default_route: z.union([
                z.object({
                    ipv4: z.boolean().default(false),
                    ipv6: z.boolean().default(false)
                }),
                z.null()
            ]),
            id: z.int().readonly(),
            mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
            public: z.object({
                ipv4: z.object({
                    addresses: z.array(z.object({
                        address: z.string(),
                        primary: z.boolean()
                    })),
                    shared: z.array(z.object({
                        address: z.string(),
                        linode_id: z.string()
                    }))
                }),
                ipv6: z.object({
                    ranges: z.array(z.object({
                        range: z.string(),
                        route_target: z.string()
                    })),
                    shared: z.array(z.object({
                        range: z.string(),
                        route_target: z.string()
                    })),
                    slaac: z.array(z.object({
                        address: z.string(),
                        prefix: z.int()
                    }))
                })
            }),
            updated: z.iso.datetime(),
            version: z.int(),
            vlan: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ]),
            vpc: z.union([
                z.record(z.string(), z.never()),
                z.null()
            ])
        }),
        z.object({
            created: z.iso.datetime(),
            id: z.int().readonly(),
            mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
            public: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ]),
            updated: z.iso.datetime(),
            version: z.int(),
            vlan: z.object({
                ipam_address: z.union([
                    z.string(),
                    z.null()
                ]),
                vlan_label: z.string()
            }),
            vpc: z.union([
                z.record(z.string(), z.unknown()),
                z.null()
            ])
        }),
        z.object({
            created: z.iso.datetime(),
            default_route: z.object({
                ipv4: z.boolean().default(false)
            }),
            id: z.int().readonly(),
            mac_address: z.string().min(1).max(64).regex(/[a-zA-Z0-9-]+/),
            public: z.union([
                z.record(z.string(), z.never()),
                z.null()
            ]),
            updated: z.iso.datetime(),
            version: z.int(),
            vlan: z.union([
                z.record(z.string(), z.never()),
                z.null()
            ]),
            vpc: z.object({
                ipv4: z.object({
                    addresses: z.array(z.object({
                        address: z.string(),
                        nat_1_1_address: z.union([
                            z.string(),
                            z.null()
                        ]),
                        primary: z.boolean()
                    })),
                    ranges: z.array(z.object({
                        range: z.string()
                    }))
                }),
                subnet_id: z.int(),
                vpc_id: z.int()
            })
        })
    ]))
});

export const getLinodeVolumesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns the Block Storage volumes attached to this Linode.
 */
export const getLinodeVolumesResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        encryption: z.enum(['enabled', 'disabled']),
        filesystem_path: z.string().readonly(),
        hardware_type: z.enum(['hdd', 'nvme']),
        id: z.int().readonly(),
        io_ready: z.boolean().readonly(),
        label: z.string().min(1).max(32).regex(/^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$/),
        linode_id: z.union([
            z.int(),
            z.null()
        ]),
        linode_label: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        region: z.string(),
        size: z.int().lte(10240),
        status: z.enum([
            'creating',
            'active',
            'resizing',
            'key_rotating'
        ]),
        tags: z.array(z.string()),
        updated: z.iso.datetime().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getKernelsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns an array of Kernels.
 */
export const getKernelsResponseSchema = z.object({
    data: z.array(z.object({
        architecture: z.enum(['x86_64', 'i386']),
        built: z.iso.datetime().readonly(),
        deprecated: z.boolean().readonly(),
        id: z.string().readonly(),
        kvm: z.boolean().readonly(),
        label: z.string().readonly(),
        pvops: z.boolean().readonly(),
        version: z.string().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getKernelRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        kernelId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Linux kernel object.
 */
export const getKernelResponseSchema = z.object({
    architecture: z.enum(['x86_64', 'i386']),
    built: z.iso.datetime().readonly(),
    deprecated: z.boolean().readonly(),
    id: z.string().readonly(),
    kvm: z.boolean().readonly(),
    label: z.string().readonly(),
    pvops: z.boolean().readonly(),
    version: z.string().readonly()
});

export const getStackScriptsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A list of StackScripts available to the User, including private StackScripts owned by the User if the request is authenticated.
 */
export const getStackScriptsResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        deployments_active: z.int().readonly(),
        deployments_total: z.int().readonly(),
        description: z.string(),
        id: z.int().readonly(),
        images: z.array(z.string()),
        is_public: z.boolean(),
        label: z.string().min(3).max(128),
        mine: z.boolean().readonly(),
        rev_note: z.string(),
        script: z.string(),
        updated: z.iso.datetime().readonly(),
        user_defined_fields: z.array(z.object({
            default: z.optional(z.string().readonly()),
            example: z.string().readonly(),
            label: z.string().readonly(),
            manyOf: z.optional(z.string().readonly()),
            name: z.string().readonly(),
            oneOf: z.optional(z.string().readonly())
        })).readonly(),
        user_gravatar_id: z.string().readonly(),
        username: z.string().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postAddStackScriptRequestSchema = z.object({
    body: z.object({
        created: z.iso.datetime().readonly(),
        deployments_active: z.int().readonly(),
        deployments_total: z.int().readonly(),
        description: z.string(),
        id: z.int().readonly(),
        images: z.array(z.string()),
        is_public: z.boolean(),
        label: z.string().min(3).max(128),
        mine: z.boolean().readonly(),
        rev_note: z.string(),
        script: z.string(),
        updated: z.iso.datetime().readonly(),
        user_defined_fields: z.array(z.object({
            default: z.optional(z.string().readonly()),
            example: z.string().readonly(),
            label: z.string().readonly(),
            manyOf: z.optional(z.string().readonly()),
            name: z.string().readonly(),
            oneOf: z.optional(z.string().readonly())
        })).readonly(),
        user_gravatar_id: z.string().readonly(),
        username: z.string().readonly()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A StackScript enables you to quickly deploy a fully configured application in an automated manner.
 */
export const postAddStackScriptResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    deployments_active: z.int().readonly(),
    deployments_total: z.int().readonly(),
    description: z.string(),
    id: z.int().readonly(),
    images: z.array(z.string()),
    is_public: z.boolean(),
    label: z.string().min(3).max(128),
    mine: z.boolean().readonly(),
    rev_note: z.string(),
    script: z.string(),
    updated: z.iso.datetime().readonly(),
    user_defined_fields: z.array(z.object({
        default: z.optional(z.string().readonly()),
        example: z.string().readonly(),
        label: z.string().readonly(),
        manyOf: z.optional(z.string().readonly()),
        name: z.string().readonly(),
        oneOf: z.optional(z.string().readonly())
    })).readonly(),
    user_gravatar_id: z.string().readonly(),
    username: z.string().readonly()
});

export const deleteStackScriptRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        stackscriptId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteStackScriptResponseSchema = z.record(z.string(), z.unknown());

export const getStackScriptRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        stackscriptId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A StackScript enables you to quickly deploy a fully configured application in an automated manner.
 */
export const getStackScriptResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    deployments_active: z.int().readonly(),
    deployments_total: z.int().readonly(),
    description: z.string(),
    id: z.int().readonly(),
    images: z.array(z.string()),
    is_public: z.boolean(),
    label: z.string().min(3).max(128),
    mine: z.boolean().readonly(),
    rev_note: z.string(),
    script: z.string(),
    updated: z.iso.datetime().readonly(),
    user_defined_fields: z.array(z.object({
        default: z.optional(z.string().readonly()),
        example: z.string().readonly(),
        label: z.string().readonly(),
        manyOf: z.optional(z.string().readonly()),
        name: z.string().readonly(),
        oneOf: z.optional(z.string().readonly())
    })).readonly(),
    user_gravatar_id: z.string().readonly(),
    username: z.string().readonly()
});

export const putStackScriptRequestSchema = z.object({
    body: z.optional(z.object({
        created: z.iso.datetime().readonly(),
        deployments_active: z.int().readonly(),
        deployments_total: z.int().readonly(),
        description: z.string(),
        id: z.int().readonly(),
        images: z.array(z.string()),
        is_public: z.boolean(),
        label: z.string().min(3).max(128),
        mine: z.boolean().readonly(),
        rev_note: z.string(),
        script: z.string(),
        updated: z.iso.datetime().readonly(),
        user_defined_fields: z.array(z.object({
            default: z.optional(z.string().readonly()),
            example: z.string().readonly(),
            label: z.string().readonly(),
            manyOf: z.optional(z.string().readonly()),
            name: z.string().readonly(),
            oneOf: z.optional(z.string().readonly())
        })).readonly(),
        user_gravatar_id: z.string().readonly(),
        username: z.string().readonly()
    })),
    path: z.object({
        stackscriptId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A StackScript enables you to quickly deploy a fully configured application in an automated manner.
 */
export const putStackScriptResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    deployments_active: z.int().readonly(),
    deployments_total: z.int().readonly(),
    description: z.string(),
    id: z.int().readonly(),
    images: z.array(z.string()),
    is_public: z.boolean(),
    label: z.string().min(3).max(128),
    mine: z.boolean().readonly(),
    rev_note: z.string(),
    script: z.string(),
    updated: z.iso.datetime().readonly(),
    user_defined_fields: z.array(z.object({
        default: z.optional(z.string().readonly()),
        example: z.string().readonly(),
        label: z.string().readonly(),
        manyOf: z.optional(z.string().readonly()),
        name: z.string().readonly(),
        oneOf: z.optional(z.string().readonly())
    })).readonly(),
    user_gravatar_id: z.string().readonly(),
    username: z.string().readonly()
});

export const getLinodeTypesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A collection of Linode Types.
 */
export const getLinodeTypesResponseSchema = z.object({
    data: z.array(z.object({
        addons: z.object({
            backups: z.object({
                price: z.object({
                    hourly: z.number(),
                    monthly: z.number()
                }),
                region_prices: z.array(z.object({
                    hourly: z.number(),
                    id: z.string(),
                    monthly: z.number()
                }))
            }).readonly()
        }).readonly(),
        class: z.enum([
            'nanode',
            'standard',
            'dedicated',
            'premium',
            'gpu',
            'accelerated',
            'highmem'
        ]),
        disk: z.int().readonly(),
        gpus: z.int().readonly(),
        id: z.string().readonly(),
        label: z.string().readonly(),
        memory: z.int().readonly(),
        network_out: z.int().readonly(),
        price: z.object({
            hourly: z.number(),
            monthly: z.number()
        }).readonly(),
        region_prices: z.array(z.object({
            hourly: z.number(),
            id: z.string(),
            monthly: z.number()
        })),
        successor: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        transfer: z.int().readonly(),
        vcpus: z.int().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getLinodeTypeRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        typeId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The available Linode types, including pricing and specifications for each. Use them when [creating](https://techdocs.akamai.com/linode-api/reference/post-linode-instance) or [resizing](https://techdocs.akamai.com/linode-api/reference/post-resize-linode-instance) Linodes.
 */
export const getLinodeTypeResponseSchema = z.object({
    addons: z.object({
        backups: z.object({
            price: z.object({
                hourly: z.number(),
                monthly: z.number()
            }),
            region_prices: z.array(z.object({
                hourly: z.number(),
                id: z.string(),
                monthly: z.number()
            }))
        }).readonly()
    }).readonly(),
    class: z.enum([
        'nanode',
        'standard',
        'dedicated',
        'premium',
        'gpu',
        'accelerated',
        'highmem'
    ]),
    disk: z.int().readonly(),
    gpus: z.int().readonly(),
    id: z.string().readonly(),
    label: z.string().readonly(),
    memory: z.int().readonly(),
    network_out: z.int().readonly(),
    price: z.object({
        hourly: z.number(),
        monthly: z.number()
    }).readonly(),
    region_prices: z.array(z.object({
        hourly: z.number(),
        id: z.string(),
        monthly: z.number()
    })),
    successor: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    transfer: z.int().readonly(),
    vcpus: z.int().readonly()
});

export const getLkeClustersRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Returns an array of all Kubernetes clusters on your Account.
 */
export const getLkeClustersResponseSchema = z.object({
    data: z.array(z.object({
        apl_enabled: z.boolean(),
        control_plane: z.object({
            audit_logs_enabled: z.boolean().default(false),
            high_availability: z.boolean().default(false)
        }),
        created: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        k8s_version: z.string(),
        label: z.string().min(1).max(32),
        region: z.string(),
        stack_type: z.enum(['ipv4', 'ipv4-ipv6']),
        subnet_id: z.int(),
        tags: z.array(z.string()),
        tier: z.enum(['standard', 'enterprise']),
        updated: z.iso.datetime().readonly(),
        vpc_id: z.int()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postLkeClusterRequestSchema = z.object({
    body: z.optional(z.object({
        apl_enabled: z.optional(z.boolean()),
        control_plane: z.optional(z.object({
            acl: z.object({
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                enabled: z.boolean(),
                'revision-id': z.string()
            }),
            audit_logs_enabled: z.boolean().default(false),
            high_availability: z.boolean().default(false)
        })),
        k8s_version: z.string(),
        label: z.string().min(1).max(32),
        node_pools: z.array(z.object({
            autoscaler: z.optional(z.object({
                enabled: z.boolean(),
                max: z.int().gte(1).lte(100),
                min: z.int().gte(1).lte(100)
            })),
            count: z.int().gte(1).lte(100),
            disk_encryption: z.optional(z.enum(['enabled', 'disabled'])),
            disks: z.optional(z.array(z.object({
                size: z.int(),
                type: z.enum(['raw', 'ext4'])
            }))),
            k8s_version: z.optional(z.string()),
            label: z.optional(z.string().min(1).max(32).regex(/^[a-z0-9]([-a-z0-9]*[a-z0-9])$/)),
            labels: z.optional(z.record(z.string(), z.string().min(0).max(63).regex(/^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?/))),
            tags: z.optional(z.array(z.string())),
            taints: z.optional(z.array(z.object({
                effect: z.enum([
                    'NoSchedule',
                    'PreferNoSchedule',
                    'NoExecute'
                ]),
                key: z.string().min(1).max(63).regex(/^([A-Za-z0-9][-A-Za-z0-9_.]*)?(\/)?([A-Za-z0-9][-A-Za-z0-9_.]{1,63})?$/),
                value: z.string().min(0).max(63).regex(/^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?/)
            })).min(0)),
            type: z.string(),
            update_strategy: z.optional(z.enum(['rolling_update', 'on_recycle']))
        })),
        region: z.string(),
        stack_type: z.optional(z.enum(['ipv4', 'ipv4-ipv6'])),
        subnet_id: z.optional(z.int()),
        tags: z.optional(z.array(z.string())),
        tier: z.optional(z.enum(['standard', 'enterprise'])),
        vpc_id: z.optional(z.int())
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A Kubernetes cluster.
 */
export const postLkeClusterResponseSchema = z.object({
    apl_enabled: z.boolean(),
    control_plane: z.object({
        audit_logs_enabled: z.boolean().default(false),
        high_availability: z.boolean().default(false)
    }),
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    k8s_version: z.string(),
    label: z.string().min(1).max(32),
    region: z.string(),
    stack_type: z.enum(['ipv4', 'ipv4-ipv6']),
    subnet_id: z.int(),
    tags: z.array(z.string()),
    tier: z.enum(['standard', 'enterprise']),
    updated: z.iso.datetime().readonly(),
    vpc_id: z.int()
});

export const deleteLkeClusterRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteLkeClusterResponseSchema = z.record(z.string(), z.unknown());

export const getLkeClusterRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A Kubernetes cluster.
 */
export const getLkeClusterResponseSchema = z.object({
    apl_enabled: z.boolean(),
    control_plane: z.object({
        audit_logs_enabled: z.boolean().default(false),
        high_availability: z.boolean().default(false)
    }),
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    k8s_version: z.string(),
    label: z.string().min(1).max(32),
    region: z.string(),
    stack_type: z.enum(['ipv4', 'ipv4-ipv6']),
    subnet_id: z.int(),
    tags: z.array(z.string()),
    tier: z.enum(['standard', 'enterprise']),
    updated: z.iso.datetime().readonly(),
    vpc_id: z.int()
});

export const putLkeClusterRequestSchema = z.object({
    body: z.optional(z.object({
        control_plane: z.object({
            acl: z.object({
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                enabled: z.boolean(),
                'revision-id': z.string()
            }),
            audit_logs_enabled: z.boolean().default(false),
            high_availability: z.boolean().default(false)
        }),
        k8s_version: z.string(),
        label: z.string().min(1).max(32),
        tags: z.array(z.string())
    })),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A Kubernetes cluster.
 */
export const putLkeClusterResponseSchema = z.object({
    apl_enabled: z.boolean(),
    control_plane: z.object({
        audit_logs_enabled: z.boolean().default(false),
        high_availability: z.boolean().default(false)
    }),
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    k8s_version: z.string(),
    label: z.string().min(1).max(32),
    region: z.string(),
    stack_type: z.enum(['ipv4', 'ipv4-ipv6']),
    subnet_id: z.int(),
    tags: z.array(z.string()),
    tier: z.enum(['standard', 'enterprise']),
    updated: z.iso.datetime().readonly(),
    vpc_id: z.int()
});

export const getLkeClusterApiEndpointsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns the Kubernetes API server endpoints for this cluster.
 */
export const getLkeClusterApiEndpointsResponseSchema = z.object({
    data: z.array(z.object({
        endpoint: z.string().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const deleteLkeClusterAclRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteLkeClusterAclResponseSchema = z.record(z.string(), z.unknown());

export const getLkeClusterAclRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a single cluster's control plane access control list. The optional field `revision-id` provided will be reflected on GET response when (and only after) the ACL stanza is verified as enforced.
 */
export const getLkeClusterAclResponseSchema = z.object({
    acl: z.optional(z.object({
        addresses: z.object({
            ipv4: z.array(z.string()),
            ipv6: z.array(z.string())
        }),
        enabled: z.boolean(),
        'revision-id': z.string()
    }))
}).and(z.object({
    acl: z.object({
        addresses: z.object({
            ipv4: z.unknown(),
            ipv6: z.unknown()
        }),
        'revision-id': z.unknown()
    })
}));

export const putLkeClusterAclRequestSchema = z.object({
    body: z.optional(z.object({
        acl: z.object({
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            enabled: z.boolean(),
            'revision-id': z.string()
        })
    })),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a single cluster's control plane access control list. The optional field `revision-id` provided will be reflected on GET response when (and only after) the ACL stanza is verified as enforced.
 */
export const putLkeClusterAclResponseSchema = z.object({
    acl: z.optional(z.object({
        addresses: z.object({
            ipv4: z.array(z.string()),
            ipv6: z.array(z.string())
        }),
        enabled: z.boolean(),
        'revision-id': z.string()
    }))
}).and(z.object({
    acl: z.object({
        addresses: z.object({
            ipv4: z.unknown(),
            ipv6: z.unknown()
        }),
        'revision-id': z.unknown()
    })
}));

export const getLkeClusterDashboardRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a Kubernetes Cluster Dashboard URL.
 */
export const getLkeClusterDashboardResponseSchema = z.object({
    url: z.string()
});

export const deleteLkeClusterKubeconfigRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteLkeClusterKubeconfigResponseSchema = z.record(z.string(), z.unknown());

export const getLkeClusterKubeconfigRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns the Base64-encoded Kubeconfig file for this Kubernetes cluster.
 */
export const getLkeClusterKubeconfigResponseSchema = z.object({
    kubeconfig: z.string().readonly()
});

export const deleteLkeClusterNodeRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int(),
        nodeId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Delete successful.
 */
export const deleteLkeClusterNodeResponseSchema = z.record(z.string(), z.unknown());

export const getLkeClusterNodeRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int(),
        nodeId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * __Read-only__ Status information for a Node which is a member of a Kubernetes cluster.
 */
export const getLkeClusterNodeResponseSchema = z.object({
    id: z.string(),
    instance_id: z.union([
        z.int(),
        z.null()
    ]),
    status: z.enum(['ready', 'not_ready'])
}).readonly();

export const postLkeClusterNodeRecycleRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int(),
        nodeId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postLkeClusterNodeRecycleResponseSchema = z.record(z.string(), z.unknown());

export const getLkeClusterPoolsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns all node pools in this Kubernetes cluster.
 */
export const getLkeClusterPoolsResponseSchema = z.object({
    data: z.array(z.object({
        autoscaler: z.object({
            enabled: z.boolean(),
            max: z.int().gte(1).lte(100),
            min: z.int().gte(1).lte(100)
        }),
        count: z.int().gte(1).lte(100),
        disk_encryption: z.enum(['enabled', 'disabled']),
        disks: z.array(z.object({
            size: z.int(),
            type: z.enum(['raw', 'ext4'])
        })),
        id: z.int(),
        k8s_version: z.string(),
        label: z.string().min(1).max(32),
        labels: z.record(z.string(), z.string().min(0).max(63).regex(/^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?/)),
        nodes: z.array(z.object({
            id: z.string(),
            instance_id: z.union([
                z.int(),
                z.null()
            ]),
            status: z.enum(['ready', 'not_ready'])
        }).readonly()),
        tags: z.array(z.string()),
        taints: z.array(z.object({
            effect: z.optional(z.enum([
                'NoSchedule',
                'PreferNoSchedule',
                'NoExecute'
            ])),
            key: z.optional(z.string().min(1).max(63).regex(/^([A-Za-z0-9][-A-Za-z0-9_.]*)?(\/)?([A-Za-z0-9][-A-Za-z0-9_.]{1,63})?$/)),
            value: z.optional(z.string().min(0).max(63).regex(/^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?/))
        })),
        type: z.string(),
        update_strategy: z.enum(['rolling_update', 'on_recycle'])
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postLkeClusterPoolsRequestSchema = z.object({
    body: z.object({
        autoscaler: z.optional(z.object({
            enabled: z.boolean(),
            max: z.int().gte(1).lte(100),
            min: z.int().gte(1).lte(100)
        })),
        count: z.int().gte(1).lte(100),
        disk_encryption: z.optional(z.enum(['enabled', 'disabled'])),
        disks: z.optional(z.array(z.object({
            size: z.int(),
            type: z.enum(['raw', 'ext4'])
        }))),
        k8s_version: z.optional(z.string()),
        label: z.optional(z.string().min(1).max(32).regex(/^[a-z0-9]([-a-z0-9]*[a-z0-9])$/)),
        labels: z.optional(z.record(z.string(), z.string().min(0).max(63).regex(/^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?/))),
        tags: z.optional(z.array(z.string())),
        taints: z.optional(z.array(z.object({
            effect: z.enum([
                'NoSchedule',
                'PreferNoSchedule',
                'NoExecute'
            ]),
            key: z.string().min(1).max(63).regex(/^([A-Za-z0-9][-A-Za-z0-9_.]*)?(\/)?([A-Za-z0-9][-A-Za-z0-9_.]{1,63})?$/),
            value: z.string().min(0).max(63).regex(/^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?/)
        })).min(0)),
        type: z.string(),
        update_strategy: z.optional(z.enum(['rolling_update', 'on_recycle']))
    }),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The set of node pools that are members of the Kubernetes cluster. Node pools consist of a Linode type, the number of Linodes to deploy of that type, and additional status information.
 */
export const postLkeClusterPoolsResponseSchema = z.object({
    autoscaler: z.object({
        enabled: z.boolean(),
        max: z.int().gte(1).lte(100),
        min: z.int().gte(1).lte(100)
    }),
    count: z.int().gte(1).lte(100),
    disk_encryption: z.enum(['enabled', 'disabled']),
    disks: z.array(z.object({
        size: z.int(),
        type: z.enum(['raw', 'ext4'])
    })),
    id: z.int(),
    k8s_version: z.string(),
    label: z.string().min(1).max(32),
    labels: z.record(z.string(), z.string().min(0).max(63).regex(/^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?/)),
    nodes: z.array(z.object({
        id: z.string(),
        instance_id: z.union([
            z.int(),
            z.null()
        ]),
        status: z.enum(['ready', 'not_ready'])
    }).readonly()),
    tags: z.array(z.string()),
    taints: z.array(z.object({
        effect: z.optional(z.enum([
            'NoSchedule',
            'PreferNoSchedule',
            'NoExecute'
        ])),
        key: z.optional(z.string().min(1).max(63).regex(/^([A-Za-z0-9][-A-Za-z0-9_.]*)?(\/)?([A-Za-z0-9][-A-Za-z0-9_.]{1,63})?$/)),
        value: z.optional(z.string().min(0).max(63).regex(/^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?/))
    })),
    type: z.string(),
    update_strategy: z.enum(['rolling_update', 'on_recycle'])
});

export const deleteLkeNodePoolRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int(),
        poolId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteLkeNodePoolResponseSchema = z.record(z.string(), z.unknown());

export const getLkeNodePoolRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int(),
        poolId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The set of node pools that are members of the Kubernetes cluster. Node pools consist of a Linode type, the number of Linodes to deploy of that type, and additional status information.
 */
export const getLkeNodePoolResponseSchema = z.object({
    autoscaler: z.object({
        enabled: z.boolean(),
        max: z.int().gte(1).lte(100),
        min: z.int().gte(1).lte(100)
    }),
    count: z.int().gte(1).lte(100),
    disk_encryption: z.enum(['enabled', 'disabled']),
    disks: z.array(z.object({
        size: z.int(),
        type: z.enum(['raw', 'ext4'])
    })),
    id: z.int(),
    k8s_version: z.string(),
    label: z.string().min(1).max(32),
    labels: z.record(z.string(), z.string().min(0).max(63).regex(/^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?/)),
    nodes: z.array(z.object({
        id: z.string(),
        instance_id: z.union([
            z.int(),
            z.null()
        ]),
        status: z.enum(['ready', 'not_ready'])
    }).readonly()),
    tags: z.array(z.string()),
    taints: z.array(z.object({
        effect: z.optional(z.enum([
            'NoSchedule',
            'PreferNoSchedule',
            'NoExecute'
        ])),
        key: z.optional(z.string().min(1).max(63).regex(/^([A-Za-z0-9][-A-Za-z0-9_.]*)?(\/)?([A-Za-z0-9][-A-Za-z0-9_.]{1,63})?$/)),
        value: z.optional(z.string().min(0).max(63).regex(/^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?/))
    })),
    type: z.string(),
    update_strategy: z.enum(['rolling_update', 'on_recycle'])
});

export const putLkeNodePoolRequestSchema = z.object({
    body: z.optional(z.object({
        autoscaler: z.object({
            enabled: z.boolean(),
            max: z.int().gte(1).lte(100),
            min: z.int().gte(1).lte(100)
        }),
        count: z.int().gte(1).lte(100),
        labels: z.record(z.string(), z.string().min(0).max(63).regex(/^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?/)),
        tags: z.array(z.string()),
        taints: z.array(z.object({
            effect: z.enum([
                'NoSchedule',
                'PreferNoSchedule',
                'NoExecute'
            ]),
            key: z.string().min(1).max(63).regex(/^([A-Za-z0-9][-A-Za-z0-9_.]*)?(\/)?([A-Za-z0-9][-A-Za-z0-9_.]{1,63})?$/),
            value: z.string().min(0).max(63).regex(/^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?/)
        })).min(0)
    })),
    path: z.object({
        clusterId: z.int(),
        poolId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The set of node pools that are members of the Kubernetes cluster. Node pools consist of a Linode type, the number of Linodes to deploy of that type, and additional status information.
 */
export const putLkeNodePoolResponseSchema = z.object({
    autoscaler: z.object({
        enabled: z.boolean(),
        max: z.int().gte(1).lte(100),
        min: z.int().gte(1).lte(100)
    }),
    count: z.int().gte(1).lte(100),
    disk_encryption: z.enum(['enabled', 'disabled']),
    disks: z.array(z.object({
        size: z.int(),
        type: z.enum(['raw', 'ext4'])
    })),
    id: z.int(),
    k8s_version: z.string(),
    label: z.string().min(1).max(32),
    labels: z.record(z.string(), z.string().min(0).max(63).regex(/^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?/)),
    nodes: z.array(z.object({
        id: z.string(),
        instance_id: z.union([
            z.int(),
            z.null()
        ]),
        status: z.enum(['ready', 'not_ready'])
    }).readonly()),
    tags: z.array(z.string()),
    taints: z.array(z.object({
        effect: z.optional(z.enum([
            'NoSchedule',
            'PreferNoSchedule',
            'NoExecute'
        ])),
        key: z.optional(z.string().min(1).max(63).regex(/^([A-Za-z0-9][-A-Za-z0-9_.]*)?(\/)?([A-Za-z0-9][-A-Za-z0-9_.]{1,63})?$/)),
        value: z.optional(z.string().min(0).max(63).regex(/^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?/))
    })),
    type: z.string(),
    update_strategy: z.enum(['rolling_update', 'on_recycle'])
});

export const postLkeClusterPoolRecycleRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int(),
        poolId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postLkeClusterPoolRecycleResponseSchema = z.record(z.string(), z.unknown());

export const postLkeClusterRecycleRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postLkeClusterRecycleResponseSchema = z.record(z.string(), z.unknown());

export const postLkeClusterRegenerateRequestSchema = z.object({
    body: z.optional(z.object({
        kubeconfig: z.boolean().default(false),
        servicetoken: z.boolean().default(false)
    })),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postLkeClusterRegenerateResponseSchema = z.record(z.string(), z.unknown());

export const deleteLkeServiceTokenRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteLkeServiceTokenResponseSchema = z.record(z.string(), z.unknown());

export const getLkeTiersVersionsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tier: z.enum(['standard', 'enterprise'])
    }),
    query: z.optional(z.never())
});

/**
 * __Read-only__ LKE versions for a tier.
 */
export const getLkeTiersVersionsResponseSchema = z.object({
    data: z.array(z.object({
        id: z.string().min(1).readonly(),
        tier: z.enum(['standard', 'enterprise'])
    }).readonly()).min(1).readonly(),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).readonly();

export const getLkeTiersVersionRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tier: z.enum(['standard', 'enterprise']),
        version: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * __Read-only__ LKE version for a tier.
 */
export const getLkeTiersVersionResponseSchema = z.object({
    id: z.string().min(1).readonly(),
    tier: z.enum(['standard', 'enterprise'])
}).readonly();

export const getLkeTypesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A collection of Kubernetes types.
 */
export const getLkeTypesResponseSchema = z.object({
    data: z.array(z.object({
        id: z.string().readonly(),
        label: z.string().readonly(),
        price: z.object({
            hourly: z.number(),
            monthly: z.number()
        }).readonly(),
        region_prices: z.array(z.object({
            hourly: z.number(),
            id: z.string(),
            monthly: z.number()
        })),
        transfer: z.int().gte(0).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getLkeVersionsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * LKE versions for standard tier.
 */
export const getLkeVersionsResponseSchema = z.object({
    data: z.array(z.object({
        id: z.string().min(1).readonly()
    })).min(1).readonly(),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getLkeVersionRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        version: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * LKE version.
 */
export const getLkeVersionResponseSchema = z.object({
    id: z.string().min(1).readonly()
});

export const getLongviewClientsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of Longview Clients.
 */
export const getLongviewClientsResponseSchema = z.object({
    data: z.array(z.object({
        api_key: z.string().readonly(),
        apps: z.object({
            apache: z.boolean().readonly(),
            mysql: z.boolean().readonly(),
            nginx: z.boolean().readonly()
        }).readonly(),
        created: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        install_code: z.string().readonly(),
        label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_]{3,32}/),
        updated: z.iso.datetime().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postLongviewClientRequestSchema = z.object({
    body: z.object({
        api_key: z.string().readonly(),
        apps: z.object({
            apache: z.boolean().readonly(),
            mysql: z.boolean().readonly(),
            nginx: z.boolean().readonly()
        }).readonly(),
        created: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        install_code: z.string().readonly(),
        label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_]{3,32}/),
        updated: z.iso.datetime().readonly()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A LongviewClient is a single monitor set up to track statistics about one of your servers.
 */
export const postLongviewClientResponseSchema = z.object({
    api_key: z.string().readonly(),
    apps: z.object({
        apache: z.boolean().readonly(),
        mysql: z.boolean().readonly(),
        nginx: z.boolean().readonly()
    }).readonly(),
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    install_code: z.string().readonly(),
    label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_]{3,32}/),
    updated: z.iso.datetime().readonly()
});

export const deleteLongviewClientRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clientId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteLongviewClientResponseSchema = z.record(z.string(), z.unknown());

export const getLongviewClientRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clientId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A LongviewClient is a single monitor set up to track statistics about one of your servers.
 */
export const getLongviewClientResponseSchema = z.object({
    api_key: z.string().readonly(),
    apps: z.object({
        apache: z.boolean().readonly(),
        mysql: z.boolean().readonly(),
        nginx: z.boolean().readonly()
    }).readonly(),
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    install_code: z.string().readonly(),
    label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_]{3,32}/),
    updated: z.iso.datetime().readonly()
});

export const putLongviewClientRequestSchema = z.object({
    body: z.object({
        api_key: z.string().readonly(),
        apps: z.object({
            apache: z.boolean().readonly(),
            mysql: z.boolean().readonly(),
            nginx: z.boolean().readonly()
        }).readonly(),
        created: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        install_code: z.string().readonly(),
        label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_]{3,32}/),
        updated: z.iso.datetime().readonly()
    }),
    path: z.object({
        clientId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A LongviewClient is a single monitor set up to track statistics about one of your servers.
 */
export const putLongviewClientResponseSchema = z.object({
    api_key: z.string().readonly(),
    apps: z.object({
        apache: z.boolean().readonly(),
        mysql: z.boolean().readonly(),
        nginx: z.boolean().readonly()
    }).readonly(),
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    install_code: z.string().readonly(),
    label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_]{3,32}/),
    updated: z.iso.datetime().readonly()
});

export const getLongviewPlanRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A Longview Subscription represents a tier of Longview service you can subscribe to.
 */
export const getLongviewPlanResponseSchema = z.object({
    clients_included: z.int().readonly(),
    id: z.enum([
        'longview-3',
        'longview-10',
        'longview-40',
        'longview-100'
    ]),
    label: z.string().readonly(),
    price: z.object({
        hourly: z.number().readonly(),
        monthly: z.number().readonly()
    }).readonly()
});

export const putLongviewPlanRequestSchema = z.object({
    body: z.object({
        longview_subscription: z.enum([
            'longview-3',
            'longview-10',
            'longview-40',
            'longview-100'
        ])
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A Longview Subscription represents a tier of Longview service you can subscribe to.
 */
export const putLongviewPlanResponseSchema = z.object({
    clients_included: z.int().readonly(),
    id: z.enum([
        'longview-3',
        'longview-10',
        'longview-40',
        'longview-100'
    ]),
    label: z.string().readonly(),
    price: z.object({
        hourly: z.number().readonly(),
        monthly: z.number().readonly()
    }).readonly()
});

export const getLongviewSubscriptionsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of Longview subscriptions.
 */
export const getLongviewSubscriptionsResponseSchema = z.object({
    data: z.array(z.object({
        clients_included: z.int().readonly(),
        id: z.enum([
            'longview-3',
            'longview-10',
            'longview-40',
            'longview-100'
        ]),
        label: z.string().readonly(),
        price: z.object({
            hourly: z.number().readonly(),
            monthly: z.number().readonly()
        }).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getLongviewSubscriptionRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        subscriptionId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A Longview Subscription represents a tier of Longview service you can subscribe to.
 */
export const getLongviewSubscriptionResponseSchema = z.object({
    clients_included: z.int().readonly(),
    id: z.enum([
        'longview-3',
        'longview-10',
        'longview-40',
        'longview-100'
    ]),
    label: z.string().readonly(),
    price: z.object({
        hourly: z.number().readonly(),
        monthly: z.number().readonly()
    }).readonly()
});

export const getLongviewTypesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A collection of Longview types.
 */
export const getLongviewTypesResponseSchema = z.object({
    data: z.array(z.object({
        id: z.string().readonly(),
        label: z.string().readonly(),
        price: z.object({
            hourly: z.number(),
            monthly: z.number()
        }).readonly(),
        region_prices: z.array(z.object({
            hourly: z.number(),
            id: z.string(),
            monthly: z.number()
        })),
        transfer: z.int().gte(0).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getMaintenancePoliciesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of maintenance policy objects.
 */
export const getMaintenancePoliciesResponseSchema = z.object({
    data: z.array(z.object({
        description: z.string(),
        is_default: z.boolean(),
        label: z.string(),
        notification_period_sec: z.int(),
        slug: z.string(),
        type: z.enum(['migrate', 'power_off_on'])
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getManagedContactsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of ManagedContacts.
 */
export const getManagedContactsResponseSchema = z.object({
    data: z.array(z.object({
        email: z.email(),
        group: z.union([
            z.string().min(2).max(50),
            z.null()
        ]),
        id: z.int().readonly(),
        name: z.string().min(2).max(64).regex(/[a-zA-Z0-9-_ ]{2,64}/),
        phone: z.object({
            primary: z.union([
                z.string(),
                z.null()
            ]),
            secondary: z.union([
                z.string(),
                z.null()
            ])
        }),
        updated: z.iso.datetime().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postManagedContactRequestSchema = z.object({
    body: z.optional(z.object({
        email: z.email(),
        group: z.union([
            z.string().min(2).max(50),
            z.null()
        ]),
        id: z.int().readonly(),
        name: z.string().min(2).max(64).regex(/[a-zA-Z0-9-_ ]{2,64}/),
        phone: z.object({
            primary: z.union([
                z.string(),
                z.null()
            ]),
            secondary: z.union([
                z.string(),
                z.null()
            ])
        }),
        updated: z.iso.datetime().readonly()
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Information about someone Linode's special forces may contact in case an issue is detected with a manager service.
 */
export const postManagedContactResponseSchema = z.object({
    email: z.email(),
    group: z.union([
        z.string().min(2).max(50),
        z.null()
    ]),
    id: z.int().readonly(),
    name: z.string().min(2).max(64).regex(/[a-zA-Z0-9-_ ]{2,64}/),
    phone: z.object({
        primary: z.union([
            z.string(),
            z.null()
        ]),
        secondary: z.union([
            z.string(),
            z.null()
        ])
    }),
    updated: z.iso.datetime().readonly()
});

export const deleteManagedContactRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        contactId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteManagedContactResponseSchema = z.record(z.string(), z.unknown());

export const getManagedContactRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        contactId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Information about someone Linode's special forces may contact in case an issue is detected with a manager service.
 */
export const getManagedContactResponseSchema = z.object({
    email: z.email(),
    group: z.union([
        z.string().min(2).max(50),
        z.null()
    ]),
    id: z.int().readonly(),
    name: z.string().min(2).max(64).regex(/[a-zA-Z0-9-_ ]{2,64}/),
    phone: z.object({
        primary: z.union([
            z.string(),
            z.null()
        ]),
        secondary: z.union([
            z.string(),
            z.null()
        ])
    }),
    updated: z.iso.datetime().readonly()
});

export const putManagedContactRequestSchema = z.object({
    body: z.object({
        email: z.email(),
        group: z.union([
            z.string().min(2).max(50),
            z.null()
        ]),
        id: z.int().readonly(),
        name: z.string().min(2).max(64).regex(/[a-zA-Z0-9-_ ]{2,64}/),
        phone: z.object({
            primary: z.union([
                z.string(),
                z.null()
            ]),
            secondary: z.union([
                z.string(),
                z.null()
            ])
        }),
        updated: z.iso.datetime().readonly()
    }),
    path: z.object({
        contactId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Information about someone Linode's special forces may contact in case an issue is detected with a manager service.
 */
export const putManagedContactResponseSchema = z.object({
    email: z.email(),
    group: z.union([
        z.string().min(2).max(50),
        z.null()
    ]),
    id: z.int().readonly(),
    name: z.string().min(2).max(64).regex(/[a-zA-Z0-9-_ ]{2,64}/),
    phone: z.object({
        primary: z.union([
            z.string(),
            z.null()
        ]),
        secondary: z.union([
            z.string(),
            z.null()
        ])
    }),
    updated: z.iso.datetime().readonly()
});

export const getManagedCredentialsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of ManagedCredentials.
 */
export const getManagedCredentialsResponseSchema = z.object({
    data: z.array(z.object({
        id: z.int().readonly(),
        label: z.string().min(2).max(75).regex(/[a-zA-Z0-9-_ \.]{2,75}/),
        last_decrypted: z.iso.datetime().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postManagedCredentialRequestSchema = z.object({
    body: z.optional(z.object({
        id: z.int().readonly(),
        label: z.string().min(2).max(75).regex(/[a-zA-Z0-9-_ \.]{2,75}/),
        last_decrypted: z.iso.datetime().readonly()
    }).and(z.object({
        password: z.string(),
        username: z.string().min(0).max(5000)
    }))),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A securely stored Credential that allows Linode's special forces to access a Managed server to respond to Issues.
 */
export const postManagedCredentialResponseSchema = z.object({
    id: z.int().readonly(),
    label: z.string().min(2).max(75).regex(/[a-zA-Z0-9-_ \.]{2,75}/),
    last_decrypted: z.iso.datetime().readonly()
});

export const getManagedSshKeyRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A unique SSH public key that allows Linode's special forces to access a Managed server to respond to Issues.
 */
export const getManagedSshKeyResponseSchema = z.object({
    ssh_key: z.string().readonly()
});

export const getManagedCredentialRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        credentialId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A securely stored Credential that allows Linode's special forces to access a Managed server to respond to Issues.
 */
export const getManagedCredentialResponseSchema = z.object({
    id: z.int().readonly(),
    label: z.string().min(2).max(75).regex(/[a-zA-Z0-9-_ \.]{2,75}/),
    last_decrypted: z.iso.datetime().readonly()
});

export const putManagedCredentialRequestSchema = z.object({
    body: z.object({
        id: z.int().readonly(),
        label: z.string().min(2).max(75).regex(/[a-zA-Z0-9-_ \.]{2,75}/),
        last_decrypted: z.iso.datetime().readonly()
    }),
    path: z.object({
        credentialId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A securely stored Credential that allows Linode's special forces to access a Managed server to respond to Issues.
 */
export const putManagedCredentialResponseSchema = z.object({
    id: z.int().readonly(),
    label: z.string().min(2).max(75).regex(/[a-zA-Z0-9-_ \.]{2,75}/),
    last_decrypted: z.iso.datetime().readonly()
});

export const postManagedCredentialRevokeRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        credentialId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postManagedCredentialRevokeResponseSchema = z.record(z.string(), z.unknown());

export const postManagedCredentialUsernamePasswordRequestSchema = z.object({
    body: z.optional(z.object({
        password: z.string(),
        username: z.optional(z.string().min(0).max(5000))
    })),
    path: z.object({
        credentialId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postManagedCredentialUsernamePasswordResponseSchema = z.record(z.string(), z.unknown());

export const getManagedIssuesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of open or ongoing Managed Issues.
 */
export const getManagedIssuesResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        entity: z.object({
            id: z.int().readonly(),
            label: z.string().readonly(),
            type: z.enum(['ticket']),
            url: z.string().readonly()
        }).readonly(),
        id: z.int().readonly(),
        services: z.array(z.int()).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getManagedIssueRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        issueId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * An Issue that was detected with a service Linode is managing.
 */
export const getManagedIssueResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    entity: z.object({
        id: z.int().readonly(),
        label: z.string().readonly(),
        type: z.enum(['ticket']),
        url: z.string().readonly()
    }).readonly(),
    id: z.int().readonly(),
    services: z.array(z.int()).readonly()
});

export const getManagedLinodeSettingsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of Managed settings for your Linodes.
 */
export const getManagedLinodeSettingsResponseSchema = z.object({
    data: z.array(z.object({
        group: z.string().readonly(),
        id: z.int().readonly(),
        label: z.string().readonly(),
        ssh: z.object({
            access: z.boolean().default(true),
            ip: z.string().default('any'),
            port: z.union([
                z.int().gte(1).lte(65535),
                z.null()
            ]).default(null),
            user: z.union([
                z.string().min(0).max(32),
                z.null()
            ]).default(null)
        })
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getManagedLinodeSettingRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Settings for a specific Linode related to Managed Services. There is one ManagedLinodeSettings object for each Linode on your Account.
 */
export const getManagedLinodeSettingResponseSchema = z.object({
    group: z.string().readonly(),
    id: z.int().readonly(),
    label: z.string().readonly(),
    ssh: z.object({
        access: z.boolean().default(true),
        ip: z.string().default('any'),
        port: z.union([
            z.int().gte(1).lte(65535),
            z.null()
        ]).default(null),
        user: z.union([
            z.string().min(0).max(32),
            z.null()
        ]).default(null)
    })
});

export const putManagedLinodeSettingRequestSchema = z.object({
    body: z.object({
        group: z.string().readonly(),
        id: z.int().readonly(),
        label: z.string().readonly(),
        ssh: z.object({
            access: z.boolean().default(true),
            ip: z.string().default('any'),
            port: z.union([
                z.int().gte(1).lte(65535),
                z.null()
            ]).default(null),
            user: z.union([
                z.string().min(0).max(32),
                z.null()
            ]).default(null)
        })
    }),
    path: z.object({
        linodeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Settings for a specific Linode related to Managed Services. There is one ManagedLinodeSettings object for each Linode on your Account.
 */
export const putManagedLinodeSettingResponseSchema = z.object({
    group: z.string().readonly(),
    id: z.int().readonly(),
    label: z.string().readonly(),
    ssh: z.object({
        access: z.boolean().default(true),
        ip: z.string().default('any'),
        port: z.union([
            z.int().gte(1).lte(65535),
            z.null()
        ]).default(null),
        user: z.union([
            z.string().min(0).max(32),
            z.null()
        ]).default(null)
    })
});

export const getManagedServicesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A paginated list of Managed Services.
 */
export const getManagedServicesResponseSchema = z.object({
    data: z.array(z.object({
        address: z.string().min(3).max(100),
        body: z.union([
            z.string().min(0).max(100),
            z.null()
        ]),
        consultation_group: z.string().min(0).max(50),
        created: z.iso.datetime().readonly(),
        credentials: z.array(z.int()),
        id: z.int().readonly(),
        label: z.string().min(3).max(64).regex(/[a-zA-Z0-9-_ \.]{3,64}/),
        notes: z.union([
            z.string(),
            z.null()
        ]),
        region: z.union([
            z.string(),
            z.null()
        ]),
        service_type: z.enum(['url', 'tcp']),
        status: z.enum([
            'disabled',
            'pending',
            'ok',
            'problem'
        ]),
        timeout: z.int().gte(1).lte(255),
        updated: z.iso.datetime().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postManagedServiceRequestSchema = z.object({
    body: z.optional(z.object({
        address: z.string().min(3).max(100),
        body: z.union([
            z.string().min(0).max(100),
            z.null()
        ]),
        consultation_group: z.string().min(0).max(50),
        created: z.iso.datetime().readonly(),
        credentials: z.array(z.int()),
        id: z.int().readonly(),
        label: z.string().min(3).max(64).regex(/[a-zA-Z0-9-_ \.]{3,64}/),
        notes: z.union([
            z.string(),
            z.null()
        ]),
        region: z.union([
            z.string(),
            z.null()
        ]),
        service_type: z.enum(['url', 'tcp']),
        status: z.enum([
            'disabled',
            'pending',
            'ok',
            'problem'
        ]),
        timeout: z.int().gte(1).lte(255),
        updated: z.iso.datetime().readonly()
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A service that Linode is monitoring as part of your Managed services. If issues are detected with this service, a ManagedIssue will be opened and, optionally, Linode special forces will attempt to resolve the Issue.
 */
export const postManagedServiceResponseSchema = z.object({
    address: z.string().min(3).max(100),
    body: z.union([
        z.string().min(0).max(100),
        z.null()
    ]),
    consultation_group: z.string().min(0).max(50),
    created: z.iso.datetime().readonly(),
    credentials: z.array(z.int()),
    id: z.int().readonly(),
    label: z.string().min(3).max(64).regex(/[a-zA-Z0-9-_ \.]{3,64}/),
    notes: z.union([
        z.string(),
        z.null()
    ]),
    region: z.union([
        z.string(),
        z.null()
    ]),
    service_type: z.enum(['url', 'tcp']),
    status: z.enum([
        'disabled',
        'pending',
        'ok',
        'problem'
    ]),
    timeout: z.int().gte(1).lte(255),
    updated: z.iso.datetime().readonly()
});

export const deleteManagedServiceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        serviceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteManagedServiceResponseSchema = z.record(z.string(), z.unknown());

export const getManagedServiceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        serviceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A service that Linode is monitoring as part of your Managed services. If issues are detected with this service, a ManagedIssue will be opened and, optionally, Linode special forces will attempt to resolve the Issue.
 */
export const getManagedServiceResponseSchema = z.object({
    address: z.string().min(3).max(100),
    body: z.union([
        z.string().min(0).max(100),
        z.null()
    ]),
    consultation_group: z.string().min(0).max(50),
    created: z.iso.datetime().readonly(),
    credentials: z.array(z.int()),
    id: z.int().readonly(),
    label: z.string().min(3).max(64).regex(/[a-zA-Z0-9-_ \.]{3,64}/),
    notes: z.union([
        z.string(),
        z.null()
    ]),
    region: z.union([
        z.string(),
        z.null()
    ]),
    service_type: z.enum(['url', 'tcp']),
    status: z.enum([
        'disabled',
        'pending',
        'ok',
        'problem'
    ]),
    timeout: z.int().gte(1).lte(255),
    updated: z.iso.datetime().readonly()
});

export const putManagedServiceRequestSchema = z.object({
    body: z.object({
        address: z.string().min(3).max(100),
        body: z.union([
            z.string().min(0).max(100),
            z.null()
        ]),
        consultation_group: z.string().min(0).max(50),
        created: z.iso.datetime().readonly(),
        credentials: z.array(z.int()),
        id: z.int().readonly(),
        label: z.string().min(3).max(64).regex(/[a-zA-Z0-9-_ \.]{3,64}/),
        notes: z.union([
            z.string(),
            z.null()
        ]),
        region: z.union([
            z.string(),
            z.null()
        ]),
        service_type: z.enum(['url', 'tcp']),
        status: z.enum([
            'disabled',
            'pending',
            'ok',
            'problem'
        ]),
        timeout: z.int().gte(1).lte(255),
        updated: z.iso.datetime().readonly()
    }),
    path: z.object({
        serviceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A service that Linode is monitoring as part of your Managed services. If issues are detected with this service, a ManagedIssue will be opened and, optionally, Linode special forces will attempt to resolve the Issue.
 */
export const putManagedServiceResponseSchema = z.object({
    address: z.string().min(3).max(100),
    body: z.union([
        z.string().min(0).max(100),
        z.null()
    ]),
    consultation_group: z.string().min(0).max(50),
    created: z.iso.datetime().readonly(),
    credentials: z.array(z.int()),
    id: z.int().readonly(),
    label: z.string().min(3).max(64).regex(/[a-zA-Z0-9-_ \.]{3,64}/),
    notes: z.union([
        z.string(),
        z.null()
    ]),
    region: z.union([
        z.string(),
        z.null()
    ]),
    service_type: z.enum(['url', 'tcp']),
    status: z.enum([
        'disabled',
        'pending',
        'ok',
        'problem'
    ]),
    timeout: z.int().gte(1).lte(255),
    updated: z.iso.datetime().readonly()
});

export const postDisableManagedServiceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        serviceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A service that Linode is monitoring as part of your Managed services. If issues are detected with this service, a ManagedIssue will be opened and, optionally, Linode special forces will attempt to resolve the Issue.
 */
export const postDisableManagedServiceResponseSchema = z.object({
    address: z.string().min(3).max(100),
    body: z.union([
        z.string().min(0).max(100),
        z.null()
    ]),
    consultation_group: z.string().min(0).max(50),
    created: z.iso.datetime().readonly(),
    credentials: z.array(z.int()),
    id: z.int().readonly(),
    label: z.string().min(3).max(64).regex(/[a-zA-Z0-9-_ \.]{3,64}/),
    notes: z.union([
        z.string(),
        z.null()
    ]),
    region: z.union([
        z.string(),
        z.null()
    ]),
    service_type: z.enum(['url', 'tcp']),
    status: z.enum([
        'disabled',
        'pending',
        'ok',
        'problem'
    ]),
    timeout: z.int().gte(1).lte(255),
    updated: z.iso.datetime().readonly()
});

export const postEnableManagedServiceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        serviceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A service that Linode is monitoring as part of your Managed services. If issues are detected with this service, a ManagedIssue will be opened and, optionally, Linode special forces will attempt to resolve the Issue.
 */
export const postEnableManagedServiceResponseSchema = z.object({
    address: z.string().min(3).max(100),
    body: z.union([
        z.string().min(0).max(100),
        z.null()
    ]),
    consultation_group: z.string().min(0).max(50),
    created: z.iso.datetime().readonly(),
    credentials: z.array(z.int()),
    id: z.int().readonly(),
    label: z.string().min(3).max(64).regex(/[a-zA-Z0-9-_ \.]{3,64}/),
    notes: z.union([
        z.string(),
        z.null()
    ]),
    region: z.union([
        z.string(),
        z.null()
    ]),
    service_type: z.enum(['url', 'tcp']),
    status: z.enum([
        'disabled',
        'pending',
        'ok',
        'problem'
    ]),
    timeout: z.int().gte(1).lte(255),
    updated: z.iso.datetime().readonly()
});

export const getManagedStatsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A list of Managed Stats from the last 24 hours.
 */
export const getManagedStatsResponseSchema = z.object({
    data: z.union([
        z.object({
            cpu: z.array(z.object({
                x: z.int().readonly(),
                y: z.int().readonly()
            })),
            disk: z.array(z.object({
                x: z.int().readonly(),
                y: z.int().readonly()
            })),
            net_in: z.array(z.object({
                x: z.int().readonly(),
                y: z.int().readonly()
            })),
            net_out: z.array(z.object({
                x: z.int().readonly(),
                y: z.int().readonly()
            })),
            swap: z.array(z.object({
                x: z.int().readonly(),
                y: z.int().readonly()
            }))
        }),
        z.array(z.string()).readonly()
    ])
});

export const getAlertChannelsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of alerts channels.
 */
export const getAlertChannelsResponseSchema = z.object({
    data: z.array(z.object({
        alerts: z.array(z.object({
            id: z.int(),
            label: z.string(),
            type: z.string(),
            url: z.string()
        })),
        channel_type: z.enum(['email']),
        content: z.object({
            email: z.object({
                email_addresses: z.array(z.string())
            })
        }),
        created: z.iso.datetime(),
        created_by: z.string(),
        id: z.int(),
        label: z.string(),
        type: z.enum(['system', 'user']),
        updated: z.iso.datetime(),
        updated_by: z.string()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getAlertDefinitionsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of all alert definitions.
 */
export const getAlertDefinitionsResponseSchema = z.object({
    data: z.array(z.object({
        alert_channels: z.array(z.object({
            id: z.int(),
            label: z.string(),
            type: z.enum(['email']),
            url: z.string()
        })),
        class: z.enum(['shared', 'dedicated']),
        created: z.iso.datetime(),
        created_by: z.string(),
        description: z.string(),
        entity_ids: z.array(z.string()),
        has_more_resources: z.boolean(),
        id: z.int(),
        label: z.string(),
        rule_criteria: z.object({
            rules: z.array(z.object({
                aggregate_function: z.enum([
                    'avg',
                    'sum',
                    'min',
                    'max'
                ]),
                dimension_filters: z.array(z.object({
                    dimension_label: z.string(),
                    label: z.string(),
                    operator: z.enum([
                        'eq',
                        'neq',
                        'startswith',
                        'endswith'
                    ]),
                    value: z.string()
                })),
                label: z.string(),
                metric: z.string(),
                operator: z.enum([
                    'eq',
                    'gt',
                    'lt',
                    'gte',
                    'lte'
                ]),
                threshold: z.number(),
                unit: z.enum([
                    'number',
                    'byte',
                    'second',
                    'percent',
                    'bit_per_second',
                    'millisecond',
                    'KB',
                    'MB',
                    'GB'
                ])
            }))
        }),
        service_type: z.string(),
        severity: z.union([
            z.literal(0),
            z.literal(1),
            z.literal(2),
            z.literal(3)
        ]),
        status: z.enum([
            'enabled',
            'disabled',
            'in progress',
            'failed'
        ]),
        trigger_conditions: z.object({
            criteria_condition: z.enum(['ALL']),
            evaluation_period_seconds: z.int(),
            polling_interval_seconds: z.int(),
            trigger_occurrences: z.int()
        }),
        type: z.enum(['user', 'system']),
        updated: z.iso.datetime(),
        updated_by: z.string()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getDashboardsAllRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of dashboards.
 */
export const getDashboardsAllResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime(),
        id: z.int(),
        label: z.string(),
        service_type: z.string(),
        type: z.enum(['standard']),
        updated: z.iso.datetime(),
        widgets: z.array(z.object({
            aggregate_function: z.enum([
                'min',
                'max',
                'avg',
                'sum',
                'rate'
            ]),
            chart_type: z.enum(['line', 'area']),
            color: z.string(),
            label: z.string(),
            metric: z.string(),
            size: z.enum(['6', '12']),
            unit: z.enum([
                '%',
                'Bytes',
                'sec',
                'bps',
                'msec',
                'Bps',
                'KB',
                'MB',
                'GB',
                'rate',
                'percentile',
                'ratio',
                'OPS',
                'IOPS'
            ]),
            y_label: z.string()
        }))
    }))
}).and(z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}));

export const getDashboardsByIdRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        dashboardId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a dashboard.
 */
export const getDashboardsByIdResponseSchema = z.object({
    created: z.iso.datetime(),
    id: z.int(),
    label: z.string(),
    service_type: z.string(),
    type: z.enum(['standard']),
    updated: z.iso.datetime(),
    widgets: z.array(z.object({
        aggregate_function: z.enum([
            'min',
            'max',
            'avg',
            'sum',
            'rate'
        ]),
        chart_type: z.enum(['line', 'area']),
        color: z.string(),
        label: z.string(),
        metric: z.string(),
        size: z.enum(['6', '12']),
        unit: z.enum([
            '%',
            'Bytes',
            'sec',
            'bps',
            'msec',
            'Bps',
            'KB',
            'MB',
            'GB',
            'rate',
            'percentile',
            'ratio',
            'OPS',
            'IOPS'
        ]),
        y_label: z.string()
    }))
});

export const getMonitorServicesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of metric definitions.
 */
export const getMonitorServicesResponseSchema = z.object({
    data: z.array(z.object({
        label: z.string(),
        service_type: z.string()
    })),
    page: z.int(),
    pages: z.int(),
    results: z.int()
});

export const getMonitorServicesForServiceTypeRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        serviceType: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of metric definitions.
 */
export const getMonitorServicesForServiceTypeResponseSchema = z.object({
    data: z.array(z.object({
        label: z.string(),
        service_type: z.string()
    })),
    page: z.int(),
    pages: z.int(),
    results: z.int()
});

export const getAlertDefinitionsForServiceTypeRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        serviceType: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of alert definitions for the specified service type.
 */
export const getAlertDefinitionsForServiceTypeResponseSchema = z.object({
    data: z.array(z.object({
        alert_channels: z.array(z.object({
            id: z.int(),
            label: z.string(),
            type: z.enum(['email']),
            url: z.string()
        })),
        class: z.enum(['shared', 'dedicated']),
        created: z.iso.datetime(),
        created_by: z.string(),
        description: z.string(),
        entity_ids: z.array(z.string()),
        has_more_resources: z.boolean(),
        id: z.int(),
        label: z.string(),
        rule_criteria: z.object({
            rules: z.array(z.object({
                aggregate_function: z.enum([
                    'avg',
                    'sum',
                    'min',
                    'max'
                ]),
                dimension_filters: z.array(z.object({
                    dimension_label: z.string(),
                    label: z.string(),
                    operator: z.enum([
                        'eq',
                        'neq',
                        'startswith',
                        'endswith'
                    ]),
                    value: z.string()
                })),
                label: z.string(),
                metric: z.string(),
                operator: z.enum([
                    'eq',
                    'gt',
                    'lt',
                    'gte',
                    'lte'
                ]),
                threshold: z.number(),
                unit: z.enum([
                    'number',
                    'byte',
                    'second',
                    'percent',
                    'bit_per_second',
                    'millisecond',
                    'KB',
                    'MB',
                    'GB'
                ])
            }))
        }),
        service_type: z.string(),
        severity: z.union([
            z.literal(0),
            z.literal(1),
            z.literal(2),
            z.literal(3)
        ]),
        status: z.enum([
            'enabled',
            'disabled',
            'in progress',
            'failed'
        ]),
        trigger_conditions: z.object({
            criteria_condition: z.enum(['ALL']),
            evaluation_period_seconds: z.int(),
            polling_interval_seconds: z.int(),
            trigger_occurrences: z.int()
        }),
        type: z.enum(['user', 'system']),
        updated: z.iso.datetime(),
        updated_by: z.string()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postAlertDefinitionForServiceTypeRequestSchema = z.object({
    body: z.object({
        channel_ids: z.array(z.int()),
        description: z.optional(z.string()),
        entity_ids: z.optional(z.array(z.string())),
        label: z.string(),
        rule_criteria: z.object({
            rules: z.array(z.object({
                aggregate_function: z.enum([
                    'avg',
                    'sum',
                    'min',
                    'max'
                ]),
                dimension_filters: z.array(z.object({
                    dimension_label: z.string(),
                    operator: z.enum([
                        'eq',
                        'neq',
                        'startswith',
                        'endswith'
                    ]),
                    value: z.string()
                })),
                metric: z.string(),
                operator: z.enum([
                    'eq',
                    'gt',
                    'lt',
                    'gte',
                    'lte'
                ]),
                threshold: z.number()
            }))
        }),
        severity: z.union([
            z.literal(0),
            z.literal(1),
            z.literal(2),
            z.literal(3)
        ]),
        trigger_conditions: z.object({
            criteria_condition: z.enum(['ALL']),
            evaluation_period_seconds: z.int(),
            polling_interval_seconds: z.int(),
            trigger_occurrences: z.int()
        })
    }),
    path: z.object({
        serviceType: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The alert definition is created.
 */
export const postAlertDefinitionForServiceTypeResponseSchema = z.object({
    alert_channels: z.array(z.object({
        id: z.int(),
        label: z.string(),
        type: z.enum(['email']),
        url: z.string()
    })),
    class: z.enum(['shared', 'dedicated']),
    created: z.iso.datetime(),
    created_by: z.string(),
    description: z.string(),
    entity_ids: z.array(z.string()),
    has_more_resources: z.boolean(),
    id: z.int(),
    label: z.string(),
    rule_criteria: z.object({
        rules: z.array(z.object({
            aggregate_function: z.enum([
                'avg',
                'sum',
                'min',
                'max'
            ]),
            dimension_filters: z.array(z.object({
                dimension_label: z.string(),
                label: z.string(),
                operator: z.enum([
                    'eq',
                    'neq',
                    'startswith',
                    'endswith'
                ]),
                value: z.string()
            })),
            label: z.string(),
            metric: z.string(),
            operator: z.enum([
                'eq',
                'gt',
                'lt',
                'gte',
                'lte'
            ]),
            threshold: z.number(),
            unit: z.enum([
                'number',
                'byte',
                'second',
                'percent',
                'bit_per_second',
                'millisecond',
                'KB',
                'MB',
                'GB'
            ])
        }))
    }),
    service_type: z.string(),
    severity: z.union([
        z.literal(0),
        z.literal(1),
        z.literal(2),
        z.literal(3)
    ]),
    status: z.enum([
        'enabled',
        'disabled',
        'in progress',
        'failed'
    ]),
    trigger_conditions: z.object({
        criteria_condition: z.enum(['ALL']),
        evaluation_period_seconds: z.int(),
        polling_interval_seconds: z.int(),
        trigger_occurrences: z.int()
    }),
    type: z.enum(['user', 'system']),
    updated: z.iso.datetime(),
    updated_by: z.string()
});

export const deleteAlertDefinitionRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        serviceType: z.string(),
        alertId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteAlertDefinitionResponseSchema = z.record(z.string(), z.unknown());

export const getAlertDefinitionRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        serviceType: z.string(),
        alertId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns the specified alert definition.
 */
export const getAlertDefinitionResponseSchema = z.object({
    alert_channels: z.array(z.object({
        id: z.int(),
        label: z.string(),
        type: z.enum(['email']),
        url: z.string()
    })),
    class: z.enum(['shared', 'dedicated']),
    created: z.iso.datetime(),
    created_by: z.string(),
    description: z.string(),
    entity_ids: z.array(z.string()),
    has_more_resources: z.boolean(),
    id: z.int(),
    label: z.string(),
    rule_criteria: z.object({
        rules: z.array(z.object({
            aggregate_function: z.enum([
                'avg',
                'sum',
                'min',
                'max'
            ]),
            dimension_filters: z.array(z.object({
                dimension_label: z.string(),
                label: z.string(),
                operator: z.enum([
                    'eq',
                    'neq',
                    'startswith',
                    'endswith'
                ]),
                value: z.string()
            })),
            label: z.string(),
            metric: z.string(),
            operator: z.enum([
                'eq',
                'gt',
                'lt',
                'gte',
                'lte'
            ]),
            threshold: z.number(),
            unit: z.enum([
                'number',
                'byte',
                'second',
                'percent',
                'bit_per_second',
                'millisecond',
                'KB',
                'MB',
                'GB'
            ])
        }))
    }),
    service_type: z.string(),
    severity: z.union([
        z.literal(0),
        z.literal(1),
        z.literal(2),
        z.literal(3)
    ]),
    status: z.enum([
        'enabled',
        'disabled',
        'in progress',
        'failed'
    ]),
    trigger_conditions: z.object({
        criteria_condition: z.enum(['ALL']),
        evaluation_period_seconds: z.int(),
        polling_interval_seconds: z.int(),
        trigger_occurrences: z.int()
    }),
    type: z.enum(['user', 'system']),
    updated: z.iso.datetime(),
    updated_by: z.string()
});

export const putAlertDefinitionRequestSchema = z.object({
    body: z.object({
        channel_ids: z.array(z.int()),
        description: z.string(),
        entity_ids: z.array(z.string()),
        label: z.string(),
        rule_criteria: z.object({
            rules: z.array(z.object({
                aggregate_function: z.enum([
                    'avg',
                    'sum',
                    'min',
                    'max'
                ]),
                dimension_filters: z.array(z.object({
                    dimension_label: z.string(),
                    operator: z.enum([
                        'eq',
                        'neq',
                        'startswith',
                        'endswith'
                    ]),
                    value: z.string()
                })),
                metric: z.string(),
                operator: z.enum([
                    'eq',
                    'gt',
                    'lt',
                    'gte',
                    'lte'
                ]),
                threshold: z.number()
            }))
        }),
        severity: z.union([
            z.literal(0),
            z.literal(1),
            z.literal(2),
            z.literal(3)
        ]),
        status: z.enum(['enabled', 'disabled']),
        trigger_conditions: z.object({
            criteria_condition: z.enum(['ALL']),
            evaluation_period_seconds: z.int(),
            polling_interval_seconds: z.int(),
            trigger_occurrences: z.int()
        })
    }),
    path: z.object({
        serviceType: z.string(),
        alertId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The alert definition is updated.
 */
export const putAlertDefinitionResponseSchema = z.object({
    alert_channels: z.array(z.object({
        id: z.int(),
        label: z.string(),
        type: z.enum(['email']),
        url: z.string()
    })),
    class: z.enum(['shared', 'dedicated']),
    created: z.iso.datetime(),
    created_by: z.string(),
    description: z.string(),
    entity_ids: z.array(z.string()),
    has_more_resources: z.boolean(),
    id: z.int(),
    label: z.string(),
    rule_criteria: z.object({
        rules: z.array(z.object({
            aggregate_function: z.enum([
                'avg',
                'sum',
                'min',
                'max'
            ]),
            dimension_filters: z.array(z.object({
                dimension_label: z.string(),
                label: z.string(),
                operator: z.enum([
                    'eq',
                    'neq',
                    'startswith',
                    'endswith'
                ]),
                value: z.string()
            })),
            label: z.string(),
            metric: z.string(),
            operator: z.enum([
                'eq',
                'gt',
                'lt',
                'gte',
                'lte'
            ]),
            threshold: z.number(),
            unit: z.enum([
                'number',
                'byte',
                'second',
                'percent',
                'bit_per_second',
                'millisecond',
                'KB',
                'MB',
                'GB'
            ])
        }))
    }),
    service_type: z.string(),
    severity: z.union([
        z.literal(0),
        z.literal(1),
        z.literal(2),
        z.literal(3)
    ]),
    status: z.enum([
        'enabled',
        'disabled',
        'in progress',
        'failed'
    ]),
    trigger_conditions: z.object({
        criteria_condition: z.enum(['ALL']),
        evaluation_period_seconds: z.int(),
        polling_interval_seconds: z.int(),
        trigger_occurrences: z.int()
    }),
    type: z.enum(['user', 'system']),
    updated: z.iso.datetime(),
    updated_by: z.string()
});

export const getDashboardsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        serviceType: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of dashboards.
 */
export const getDashboardsResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime(),
        id: z.int(),
        label: z.string(),
        service_type: z.string(),
        type: z.enum(['standard']),
        updated: z.iso.datetime(),
        widgets: z.array(z.object({
            aggregate_function: z.enum([
                'min',
                'max',
                'avg',
                'sum',
                'rate',
                'increase'
            ]),
            chart_type: z.enum(['line', 'area']),
            color: z.string(),
            label: z.string(),
            metric: z.string(),
            size: z.enum(['6', '12']),
            unit: z.enum([
                '%',
                'Bytes',
                'sec',
                'bps',
                'msec',
                'Bps',
                'KB',
                'MB',
                'GB',
                'rate',
                'percentile',
                'ratio',
                'OPS',
                'IOPS'
            ]),
            y_label: z.string()
        }))
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getMonitorInformationRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        serviceType: z.string()
    }),
    query: z.optional(z.never()),
    headers: z.optional(z.object({
        'X-Filter': z.optional(z.union([
            z.object({
                is_alertable: z.optional(z.boolean())
            }),
            z.object({
                metric_type: z.optional(z.enum([
                    'counter',
                    'histogram',
                    'gauge',
                    'summary'
                ]))
            }),
            z.object({
                '+and': z.optional(z.array(z.object({
                    is_alertable: z.boolean(),
                    metric_type: z.enum([
                        'counter',
                        'histogram',
                        'gauge',
                        'summary'
                    ])
                })))
            }),
            z.object({
                '+or': z.optional(z.array(z.object({
                    is_alertable: z.boolean(),
                    metric_type: z.enum([
                        'counter',
                        'histogram',
                        'gauge',
                        'summary'
                    ])
                })))
            })
        ]))
    }))
});

/**
 * Returns a paginated list of metric information.
 */
export const getMonitorInformationResponseSchema = z.object({
    data: z.array(z.object({
        available_aggregate_functions: z.array(z.enum([
            'min',
            'max',
            'avg',
            'sum',
            'rate',
            'increase'
        ])),
        dimensions: z.array(z.object({
            dimension_label: z.string(),
            label: z.string(),
            values: z.array(z.string())
        })),
        is_alertable: z.boolean(),
        label: z.string(),
        metric: z.string(),
        metric_type: z.enum([
            'counter',
            'histogram',
            'gauge',
            'summary'
        ]),
        scrape_interval: z.string(),
        unit: z.enum([
            '%',
            'Bytes',
            'sec',
            'bps',
            'msec',
            'Bps',
            'KB',
            'MB',
            'GB',
            'rate',
            'percentile',
            'ratio',
            'OPS',
            'IOPS'
        ])
    })),
    page: z.int(),
    pages: z.int(),
    results: z.int()
});

export const postReadMetricRequestSchema = z.object({
    body: z.union([
        z.object({
            entity_ids: z.array(z.int()).min(1),
            filters: z.optional(z.array(z.object({
                dimension_label: z.string(),
                operator: z.enum([
                    'eq',
                    'neq',
                    'startswith',
                    'endswith'
                ]),
                value: z.string()
            }))),
            group_by: z.optional(z.array(z.string())),
            metrics: z.array(z.object({
                aggregate_function: z.enum([
                    'min',
                    'max',
                    'avg',
                    'sum'
                ]),
                name: z.string()
            })).min(1),
            time_granularity: z.optional(z.object({
                unit: z.enum([
                    'sec',
                    'min',
                    'hr',
                    'days'
                ]),
                value: z.int()
            }))
        }).and(z.object({
            relative_time_duration: z.object({
                unit: z.enum([
                    'sec',
                    'min',
                    'hr',
                    'days'
                ]),
                value: z.int()
            })
        })),
        z.object({
            entity_ids: z.array(z.int()).min(1),
            filters: z.optional(z.array(z.object({
                dimension_label: z.string(),
                operator: z.enum([
                    'eq',
                    'neq',
                    'startswith',
                    'endswith'
                ]),
                value: z.string()
            }))),
            group_by: z.optional(z.array(z.string())),
            metrics: z.array(z.object({
                aggregate_function: z.enum([
                    'min',
                    'max',
                    'avg',
                    'sum'
                ]),
                name: z.string()
            })).min(1),
            time_granularity: z.optional(z.object({
                unit: z.enum([
                    'sec',
                    'min',
                    'hr',
                    'days'
                ]),
                value: z.int()
            }))
        }).and(z.object({
            absolute_time_duration: z.object({
                end: z.iso.datetime(),
                start: z.iso.datetime()
            })
        }))
    ]),
    path: z.object({
        serviceType: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Metrics returned.
 */
export const postReadMetricResponseSchema = z.object({
    data: z.object({
        result: z.array(z.object({
            metric: z.record(z.string(), z.string()),
            values: z.array(z.array(z.union([z.int(), z.string()]))).min(1)
        })).min(1),
        resultType: z.enum(['matrix'])
    }),
    isPartial: z.boolean(),
    stats: z.object({
        executionTimeMsec: z.int().gte(0),
        seriesFetched: z.string().min(1)
    }),
    status: z.string()
});

export const postGetTokenRequestSchema = z.object({
    body: z.object({
        entity_ids: z.array(z.int()).min(1).max(100)
    }),
    path: z.object({
        serviceType: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The response provides the token.
 */
export const postGetTokenResponseSchema = z.object({
    token: z.string()
});

export const getNetworkTransferPricesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A collection of network transfer prices.
 */
export const getNetworkTransferPricesResponseSchema = z.object({
    data: z.array(z.object({
        id: z.string().readonly(),
        label: z.string().readonly(),
        price: z.object({
            hourly: z.number(),
            monthly: z.union([
                z.number(),
                z.null()
            ])
        }).readonly(),
        region_prices: z.array(z.object({
            hourly: z.number(),
            id: z.string(),
            monthly: z.union([
                z.number(),
                z.null()
            ])
        })),
        transfer: z.int().gte(0).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getFirewallsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns an array of Firewalls.
 */
export const getFirewallsResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        entities: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            parent_entity: z.union([
                z.object({
                    id: z.int(),
                    label: z.string(),
                    parent_entity: z.union([
                        z.string().readonly(),
                        z.null()
                    ]).readonly(),
                    type: z.enum(['linode']),
                    url: z.string()
                }).readonly(),
                z.null()
            ]).readonly(),
            type: z.enum([
                'linode',
                'linode_interface',
                'nodebalancer'
            ]),
            url: z.string().readonly()
        })).readonly(),
        id: z.int().readonly(),
        label: z.string().min(3).max(32).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
        rules: z.object({
            fingerprint: z.string().readonly(),
            inbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            inbound_policy: z.enum(['ACCEPT', 'DROP']),
            outbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            outbound_policy: z.enum(['ACCEPT', 'DROP']),
            version: z.int().readonly()
        }),
        status: z.enum([
            'enabled',
            'disabled',
            'deleted'
        ]),
        tags: z.array(z.string()),
        updated: z.iso.datetime().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postFirewallsRequestSchema = z.object({
    body: z.optional(z.object({
        created: z.iso.datetime().readonly(),
        entities: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            parent_entity: z.union([
                z.object({
                    id: z.int(),
                    label: z.string(),
                    parent_entity: z.union([
                        z.string().readonly(),
                        z.null()
                    ]).readonly(),
                    type: z.enum(['linode']),
                    url: z.string()
                }).readonly(),
                z.null()
            ]).readonly(),
            type: z.enum([
                'linode',
                'linode_interface',
                'nodebalancer'
            ]),
            url: z.string().readonly()
        })).readonly(),
        id: z.int().readonly(),
        label: z.string().min(3).max(32).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
        rules: z.object({
            fingerprint: z.string().readonly(),
            inbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            inbound_policy: z.enum(['ACCEPT', 'DROP']),
            outbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            outbound_policy: z.enum(['ACCEPT', 'DROP']),
            version: z.int().readonly()
        }),
        status: z.enum([
            'enabled',
            'disabled',
            'deleted'
        ]),
        tags: z.array(z.string()),
        updated: z.iso.datetime().readonly()
    }).and(z.object({
        devices: z.optional(z.object({
            linode_interfaces: z.array(z.int()),
            linodes: z.array(z.int()),
            nodebalancers: z.array(z.int())
        })),
        rules: z.object({
            inbound: z.optional(z.unknown()),
            outbound: z.optional(z.unknown())
        }),
        label: z.string().min(3).max(32).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/)
    }))),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A resource that controls incoming and outgoing network traffic to a compute service. Only one enabled Firewall can be attached to a particular service at any given time. [Create a firewall device](https://techdocs.akamai.com/linode-api/reference/post-firewall-device) to assign a Firewall to a service. Currently, Firewalls can assigned to Linode compute instances and NodeBalancers.
 */
export const postFirewallsResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    entities: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        parent_entity: z.union([
            z.object({
                id: z.int(),
                label: z.string(),
                parent_entity: z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly(),
                type: z.enum(['linode']),
                url: z.string()
            }).readonly(),
            z.null()
        ]).readonly(),
        type: z.enum([
            'linode',
            'linode_interface',
            'nodebalancer'
        ]),
        url: z.string().readonly()
    })).readonly(),
    id: z.int().readonly(),
    label: z.string().min(3).max(32).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
    rules: z.object({
        fingerprint: z.string().readonly(),
        inbound: z.array(z.object({
            action: z.enum(['ACCEPT', 'DROP']),
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            description: z.string().min(1).max(100),
            label: z.string().min(3).max(32),
            ports: z.union([
                z.string(),
                z.null()
            ]),
            protocol: z.enum([
                'TCP',
                'UDP',
                'ICMP',
                'IPENCAP'
            ])
        })),
        inbound_policy: z.enum(['ACCEPT', 'DROP']),
        outbound: z.array(z.object({
            action: z.enum(['ACCEPT', 'DROP']),
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            description: z.string().min(1).max(100),
            label: z.string().min(3).max(32),
            ports: z.union([
                z.string(),
                z.null()
            ]),
            protocol: z.enum([
                'TCP',
                'UDP',
                'ICMP',
                'IPENCAP'
            ])
        })),
        outbound_policy: z.enum(['ACCEPT', 'DROP']),
        version: z.int().readonly()
    }),
    status: z.enum([
        'enabled',
        'disabled',
        'deleted'
    ]),
    tags: z.array(z.string()),
    updated: z.iso.datetime().readonly()
});

export const getFirewallSettingsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Default firewalls.
 */
export const getFirewallSettingsResponseSchema = z.object({
    default_firewall_ids: z.object({
        linode: z.int(),
        nodebalancer: z.int(),
        public_interface: z.int(),
        vpc_interface: z.int()
    })
});

export const putFirewallSettingsRequestSchema = z.object({
    body: z.object({
        default_firewall_ids: z.object({
            linode: z.int(),
            nodebalancer: z.int(),
            public_interface: z.int(),
            vpc_interface: z.int()
        })
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Default firewalls.
 */
export const putFirewallSettingsResponseSchema = z.object({
    default_firewall_ids: z.object({
        linode: z.int(),
        nodebalancer: z.int(),
        public_interface: z.int(),
        vpc_interface: z.int()
    })
});

export const getFirewallTemplatesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of firewall templates.
 */
export const getFirewallTemplatesResponseSchema = z.object({
    data: z.array(z.object({
        rules: z.object({
            inbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            inbound_policy: z.enum(['ACCEPT', 'DROP']),
            outbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            outbound_policy: z.enum(['ACCEPT', 'DROP'])
        }),
        slug: z.enum(['vpc', 'public'])
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getFirewallTemplateRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        slug: z.enum(['vpc', 'public'])
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A list of firewall templates and their `rules`.
 */
export const getFirewallTemplateResponseSchema = z.object({
    rules: z.object({
        inbound: z.array(z.object({
            action: z.enum(['ACCEPT', 'DROP']),
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            description: z.string().min(1).max(100),
            label: z.string().min(3).max(32),
            ports: z.union([
                z.string(),
                z.null()
            ]),
            protocol: z.enum([
                'TCP',
                'UDP',
                'ICMP',
                'IPENCAP'
            ])
        })),
        inbound_policy: z.enum(['ACCEPT', 'DROP']),
        outbound: z.array(z.object({
            action: z.enum(['ACCEPT', 'DROP']),
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            description: z.string().min(1).max(100),
            label: z.string().min(3).max(32),
            ports: z.union([
                z.string(),
                z.null()
            ]),
            protocol: z.enum([
                'TCP',
                'UDP',
                'ICMP',
                'IPENCAP'
            ])
        })),
        outbound_policy: z.enum(['ACCEPT', 'DROP'])
    }),
    slug: z.enum(['vpc', 'public'])
});

export const deleteFirewallRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        firewallId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteFirewallResponseSchema = z.record(z.string(), z.unknown());

export const getFirewallRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        firewallId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A resource that controls incoming and outgoing network traffic to a compute service. Only one enabled Firewall can be attached to a particular service at any given time. [Create a firewall device](https://techdocs.akamai.com/linode-api/reference/post-firewall-device) to assign a Firewall to a service. Currently, Firewalls can assigned to Linode compute instances and NodeBalancers.
 */
export const getFirewallResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    entities: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        parent_entity: z.union([
            z.object({
                id: z.int(),
                label: z.string(),
                parent_entity: z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly(),
                type: z.enum(['linode']),
                url: z.string()
            }).readonly(),
            z.null()
        ]).readonly(),
        type: z.enum([
            'linode',
            'linode_interface',
            'nodebalancer'
        ]),
        url: z.string().readonly()
    })).readonly(),
    id: z.int().readonly(),
    label: z.string().min(3).max(32).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
    rules: z.object({
        fingerprint: z.string().readonly(),
        inbound: z.array(z.object({
            action: z.enum(['ACCEPT', 'DROP']),
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            description: z.string().min(1).max(100),
            label: z.string().min(3).max(32),
            ports: z.union([
                z.string(),
                z.null()
            ]),
            protocol: z.enum([
                'TCP',
                'UDP',
                'ICMP',
                'IPENCAP'
            ])
        })),
        inbound_policy: z.enum(['ACCEPT', 'DROP']),
        outbound: z.array(z.object({
            action: z.enum(['ACCEPT', 'DROP']),
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            description: z.string().min(1).max(100),
            label: z.string().min(3).max(32),
            ports: z.union([
                z.string(),
                z.null()
            ]),
            protocol: z.enum([
                'TCP',
                'UDP',
                'ICMP',
                'IPENCAP'
            ])
        })),
        outbound_policy: z.enum(['ACCEPT', 'DROP']),
        version: z.int().readonly()
    }),
    status: z.enum([
        'enabled',
        'disabled',
        'deleted'
    ]),
    tags: z.array(z.string()),
    updated: z.iso.datetime().readonly()
});

export const putFirewallRequestSchema = z.object({
    body: z.optional(z.object({
        label: z.string().min(3).max(32).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
        status: z.enum(['enabled', 'disabled']),
        tags: z.array(z.string())
    })),
    path: z.object({
        firewallId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A resource that controls incoming and outgoing network traffic to a compute service. Only one enabled Firewall can be attached to a particular service at any given time. [Create a firewall device](https://techdocs.akamai.com/linode-api/reference/post-firewall-device) to assign a Firewall to a service. Currently, Firewalls can assigned to Linode compute instances and NodeBalancers.
 */
export const putFirewallResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    entities: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        parent_entity: z.union([
            z.object({
                id: z.int(),
                label: z.string(),
                parent_entity: z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly(),
                type: z.enum(['linode']),
                url: z.string()
            }).readonly(),
            z.null()
        ]).readonly(),
        type: z.enum([
            'linode',
            'linode_interface',
            'nodebalancer'
        ]),
        url: z.string().readonly()
    })).readonly(),
    id: z.int().readonly(),
    label: z.string().min(3).max(32).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
    rules: z.object({
        fingerprint: z.string().readonly(),
        inbound: z.array(z.object({
            action: z.enum(['ACCEPT', 'DROP']),
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            description: z.string().min(1).max(100),
            label: z.string().min(3).max(32),
            ports: z.union([
                z.string(),
                z.null()
            ]),
            protocol: z.enum([
                'TCP',
                'UDP',
                'ICMP',
                'IPENCAP'
            ])
        })),
        inbound_policy: z.enum(['ACCEPT', 'DROP']),
        outbound: z.array(z.object({
            action: z.enum(['ACCEPT', 'DROP']),
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            description: z.string().min(1).max(100),
            label: z.string().min(3).max(32),
            ports: z.union([
                z.string(),
                z.null()
            ]),
            protocol: z.enum([
                'TCP',
                'UDP',
                'ICMP',
                'IPENCAP'
            ])
        })),
        outbound_policy: z.enum(['ACCEPT', 'DROP']),
        version: z.int().readonly()
    }),
    status: z.enum([
        'enabled',
        'disabled',
        'deleted'
    ]),
    tags: z.array(z.string()),
    updated: z.iso.datetime().readonly()
});

export const getFirewallDevicesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        firewallId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of Firewall Devices.
 */
export const getFirewallDevicesResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        entity: z.object({
            id: z.int(),
            label: z.string().readonly(),
            parent_entity: z.union([
                z.object({
                    id: z.int(),
                    label: z.string(),
                    parent_entity: z.union([
                        z.string().readonly(),
                        z.null()
                    ]).readonly(),
                    type: z.enum(['linode']),
                    url: z.string()
                }).readonly(),
                z.null()
            ]).readonly(),
            type: z.enum([
                'linode',
                'nodebalancer',
                'linode_interface'
            ]),
            url: z.string().readonly()
        }),
        id: z.int(),
        updated: z.iso.datetime().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postFirewallDeviceRequestSchema = z.object({
    body: z.optional(z.object({
        id: z.int(),
        label: z.string().readonly(),
        parent_entity: z.union([
            z.object({
                id: z.int(),
                label: z.string(),
                parent_entity: z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly(),
                type: z.enum(['linode']),
                url: z.string()
            }).readonly(),
            z.null()
        ]).readonly(),
        type: z.enum([
            'linode',
            'nodebalancer',
            'linode_interface'
        ]),
        url: z.string().readonly()
    })),
    path: z.object({
        firewallId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Associates a firewall with a Linode, a Linode interface, or a NodeBalancer service.
 */
export const postFirewallDeviceResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    entity: z.object({
        id: z.int(),
        label: z.string().readonly(),
        parent_entity: z.union([
            z.object({
                id: z.int(),
                label: z.string(),
                parent_entity: z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly(),
                type: z.enum(['linode']),
                url: z.string()
            }).readonly(),
            z.null()
        ]).readonly(),
        type: z.enum([
            'linode',
            'nodebalancer',
            'linode_interface'
        ]),
        url: z.string().readonly()
    }),
    id: z.int(),
    updated: z.iso.datetime().readonly()
});

export const deleteFirewallDeviceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        firewallId: z.int(),
        deviceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteFirewallDeviceResponseSchema = z.record(z.string(), z.unknown());

export const getFirewallDeviceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        firewallId: z.int(),
        deviceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Associates a firewall with a Linode, a Linode interface, or a NodeBalancer service.
 */
export const getFirewallDeviceResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    entity: z.object({
        id: z.int(),
        label: z.string().readonly(),
        parent_entity: z.union([
            z.object({
                id: z.int(),
                label: z.string(),
                parent_entity: z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly(),
                type: z.enum(['linode']),
                url: z.string()
            }).readonly(),
            z.null()
        ]).readonly(),
        type: z.enum([
            'linode',
            'nodebalancer',
            'linode_interface'
        ]),
        url: z.string().readonly()
    }),
    id: z.int(),
    updated: z.iso.datetime().readonly()
});

export const getFirewallRuleVersionsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        firewallId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A resource that controls incoming and outgoing network traffic to a compute service. Only one enabled Firewall can be attached to a particular service at any given time. [Create a firewall device](https://techdocs.akamai.com/linode-api/reference/post-firewall-device) to assign a Firewall to a service. Currently, Firewalls can assigned to Linode compute instances and NodeBalancers.
 */
export const getFirewallRuleVersionsResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    entities: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        parent_entity: z.union([
            z.object({
                id: z.int(),
                label: z.string(),
                parent_entity: z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly(),
                type: z.enum(['linode']),
                url: z.string()
            }).readonly(),
            z.null()
        ]).readonly(),
        type: z.enum([
            'linode',
            'linode_interface',
            'nodebalancer'
        ]),
        url: z.string().readonly()
    })).readonly(),
    id: z.int().readonly(),
    label: z.string().min(3).max(32).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
    rules: z.object({
        fingerprint: z.string().readonly(),
        inbound: z.array(z.object({
            action: z.enum(['ACCEPT', 'DROP']),
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            description: z.string().min(1).max(100),
            label: z.string().min(3).max(32),
            ports: z.union([
                z.string(),
                z.null()
            ]),
            protocol: z.enum([
                'TCP',
                'UDP',
                'ICMP',
                'IPENCAP'
            ])
        })),
        inbound_policy: z.enum(['ACCEPT', 'DROP']),
        outbound: z.array(z.object({
            action: z.enum(['ACCEPT', 'DROP']),
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            description: z.string().min(1).max(100),
            label: z.string().min(3).max(32),
            ports: z.union([
                z.string(),
                z.null()
            ]),
            protocol: z.enum([
                'TCP',
                'UDP',
                'ICMP',
                'IPENCAP'
            ])
        })),
        outbound_policy: z.enum(['ACCEPT', 'DROP']),
        version: z.int().readonly()
    }),
    status: z.enum([
        'enabled',
        'disabled',
        'deleted'
    ]),
    tags: z.array(z.string()),
    updated: z.iso.datetime().readonly()
});

export const getFirewallRuleVersionRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        firewallId: z.int(),
        version: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A resource that controls incoming and outgoing network traffic to a compute service. Only one enabled Firewall can be attached to a particular service at any given time. [Create a firewall device](https://techdocs.akamai.com/linode-api/reference/post-firewall-device) to assign a Firewall to a service. Currently, Firewalls can assigned to Linode compute instances and NodeBalancers.
 */
export const getFirewallRuleVersionResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    entities: z.array(z.object({
        id: z.int(),
        label: z.string().readonly(),
        parent_entity: z.union([
            z.object({
                id: z.int(),
                label: z.string(),
                parent_entity: z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly(),
                type: z.enum(['linode']),
                url: z.string()
            }).readonly(),
            z.null()
        ]).readonly(),
        type: z.enum([
            'linode',
            'linode_interface',
            'nodebalancer'
        ]),
        url: z.string().readonly()
    })).readonly(),
    id: z.int().readonly(),
    label: z.string().min(3).max(32).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
    rules: z.object({
        fingerprint: z.string().readonly(),
        inbound: z.array(z.object({
            action: z.enum(['ACCEPT', 'DROP']),
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            description: z.string().min(1).max(100),
            label: z.string().min(3).max(32),
            ports: z.union([
                z.string(),
                z.null()
            ]),
            protocol: z.enum([
                'TCP',
                'UDP',
                'ICMP',
                'IPENCAP'
            ])
        })),
        inbound_policy: z.enum(['ACCEPT', 'DROP']),
        outbound: z.array(z.object({
            action: z.enum(['ACCEPT', 'DROP']),
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            description: z.string().min(1).max(100),
            label: z.string().min(3).max(32),
            ports: z.union([
                z.string(),
                z.null()
            ]),
            protocol: z.enum([
                'TCP',
                'UDP',
                'ICMP',
                'IPENCAP'
            ])
        })),
        outbound_policy: z.enum(['ACCEPT', 'DROP']),
        version: z.int().readonly()
    }),
    status: z.enum([
        'enabled',
        'disabled',
        'deleted'
    ]),
    tags: z.array(z.string()),
    updated: z.iso.datetime().readonly()
});

export const getFirewallRulesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        firewallId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The inbound and outbound access rules to apply to the Firewall.
 *
 * A Firewall may have up to 25 rules across its inbound and outbound rulesets.
 *
 * Multiple rules are applied in order. If two rules conflict, the first rule takes precedence. For example, if the first rule accepts inbound traffic from an address, and the second rule drops inbound traffic the same address, the first rule applies and inbound traffic from that address is accepted.
 */
export const getFirewallRulesResponseSchema = z.object({
    fingerprint: z.string().readonly(),
    inbound: z.array(z.object({
        action: z.enum(['ACCEPT', 'DROP']),
        addresses: z.object({
            ipv4: z.array(z.string()),
            ipv6: z.array(z.string())
        }),
        description: z.string().min(1).max(100),
        label: z.string().min(3).max(32),
        ports: z.union([
            z.string(),
            z.null()
        ]),
        protocol: z.enum([
            'TCP',
            'UDP',
            'ICMP',
            'IPENCAP'
        ])
    })),
    inbound_policy: z.enum(['ACCEPT', 'DROP']),
    outbound: z.array(z.object({
        action: z.enum(['ACCEPT', 'DROP']),
        addresses: z.object({
            ipv4: z.array(z.string()),
            ipv6: z.array(z.string())
        }),
        description: z.string().min(1).max(100),
        label: z.string().min(3).max(32),
        ports: z.union([
            z.string(),
            z.null()
        ]),
        protocol: z.enum([
            'TCP',
            'UDP',
            'ICMP',
            'IPENCAP'
        ])
    })),
    outbound_policy: z.enum(['ACCEPT', 'DROP']),
    version: z.int().readonly()
});

export const putFirewallRulesRequestSchema = z.object({
    body: z.optional(z.object({
        fingerprint: z.string().readonly(),
        inbound: z.array(z.object({
            action: z.enum(['ACCEPT', 'DROP']),
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            description: z.string().min(1).max(100),
            label: z.string().min(3).max(32),
            ports: z.union([
                z.string(),
                z.null()
            ]),
            protocol: z.enum([
                'TCP',
                'UDP',
                'ICMP',
                'IPENCAP'
            ])
        })),
        inbound_policy: z.enum(['ACCEPT', 'DROP']),
        outbound: z.array(z.object({
            action: z.enum(['ACCEPT', 'DROP']),
            addresses: z.object({
                ipv4: z.array(z.string()),
                ipv6: z.array(z.string())
            }),
            description: z.string().min(1).max(100),
            label: z.string().min(3).max(32),
            ports: z.union([
                z.string(),
                z.null()
            ]),
            protocol: z.enum([
                'TCP',
                'UDP',
                'ICMP',
                'IPENCAP'
            ])
        })),
        outbound_policy: z.enum(['ACCEPT', 'DROP']),
        version: z.int().readonly()
    }).and(z.object({
        inbound: z.optional(z.unknown()),
        outbound: z.optional(z.unknown())
    }))),
    path: z.object({
        firewallId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The inbound and outbound access rules to apply to the Firewall.
 *
 * A Firewall may have up to 25 rules across its inbound and outbound rulesets.
 *
 * Multiple rules are applied in order. If two rules conflict, the first rule takes precedence. For example, if the first rule accepts inbound traffic from an address, and the second rule drops inbound traffic the same address, the first rule applies and inbound traffic from that address is accepted.
 */
export const putFirewallRulesResponseSchema = z.object({
    fingerprint: z.string().readonly(),
    inbound: z.array(z.object({
        action: z.enum(['ACCEPT', 'DROP']),
        addresses: z.object({
            ipv4: z.array(z.string()),
            ipv6: z.array(z.string())
        }),
        description: z.string().min(1).max(100),
        label: z.string().min(3).max(32),
        ports: z.union([
            z.string(),
            z.null()
        ]),
        protocol: z.enum([
            'TCP',
            'UDP',
            'ICMP',
            'IPENCAP'
        ])
    })),
    inbound_policy: z.enum(['ACCEPT', 'DROP']),
    outbound: z.array(z.object({
        action: z.enum(['ACCEPT', 'DROP']),
        addresses: z.object({
            ipv4: z.array(z.string()),
            ipv6: z.array(z.string())
        }),
        description: z.string().min(1).max(100),
        label: z.string().min(3).max(32),
        ports: z.union([
            z.string(),
            z.null()
        ]),
        protocol: z.enum([
            'TCP',
            'UDP',
            'ICMP',
            'IPENCAP'
        ])
    })),
    outbound_policy: z.enum(['ACCEPT', 'DROP']),
    version: z.int().readonly()
});

export const getIpsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        skip_ipv6_rdns: z.optional(z.boolean()).default(false)
    }))
});

/**
 * The response data for the [List IP addresses](https://techdocs.akamai.com/linode-api/reference/get-ips) operation.
 */
export const getIpsResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.array(z.object({
        address: z.string().readonly(),
        gateway: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        interface_id: z.union([
            z.int().readonly(),
            z.null()
        ]).readonly(),
        linode_id: z.int().readonly(),
        prefix: z.int().readonly(),
        public: z.boolean().readonly(),
        rdns: z.union([
            z.string(),
            z.null()
        ]),
        region: z.string().readonly(),
        subnet_mask: z.string().readonly(),
        type: z.enum([
            'ipv4',
            'ipv6',
            'ipv6/pool',
            'ipv6/range'
        ]),
        vpc_nat_1_1: z.object({
            address: z.ipv4(),
            subnet_id: z.int(),
            vpc_id: z.int().readonly()
        })
    }))
}));

export const postAllocateIpRequestSchema = z.object({
    body: z.object({
        linode_id: z.int(),
        public: z.boolean(),
        type: z.enum(['ipv4'])
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * An IP address that exists in Linode's system, either IPv4 or IPv6.
 */
export const postAllocateIpResponseSchema = z.object({
    address: z.string().readonly(),
    gateway: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    interface_id: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    linode_id: z.int().readonly(),
    prefix: z.int().readonly(),
    public: z.boolean().readonly(),
    rdns: z.union([
        z.string(),
        z.null()
    ]),
    region: z.string().readonly(),
    subnet_mask: z.string().readonly(),
    type: z.enum([
        'ipv4',
        'ipv6',
        'ipv6/pool',
        'ipv6/range'
    ]),
    vpc_nat_1_1: z.object({
        address: z.ipv4(),
        subnet_id: z.int(),
        vpc_id: z.int().readonly()
    })
});

export const postAssignIpsRequestSchema = z.object({
    body: z.object({
        assignments: z.array(z.object({
            address: z.string(),
            linode_id: z.int()
        })),
        region: z.string()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postAssignIpsResponseSchema = z.record(z.string(), z.unknown());

export const postShareIpsRequestSchema = z.object({
    body: z.object({
        ips: z.array(z.string()),
        linode_id: z.int()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postShareIpsResponseSchema = z.record(z.string(), z.unknown());

export const getIpRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        address: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * An IP address that exists in Linode's system, either IPv4 or IPv6.
 */
export const getIpResponseSchema = z.object({
    address: z.string().readonly(),
    gateway: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    interface_id: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    linode_id: z.int().readonly(),
    prefix: z.int().readonly(),
    public: z.boolean().readonly(),
    rdns: z.union([
        z.string(),
        z.null()
    ]),
    region: z.string().readonly(),
    subnet_mask: z.string().readonly(),
    type: z.enum([
        'ipv4',
        'ipv6',
        'ipv6/pool',
        'ipv6/range'
    ]),
    vpc_nat_1_1: z.object({
        address: z.ipv4(),
        subnet_id: z.int(),
        vpc_id: z.int().readonly()
    })
});

export const putIpRequestSchema = z.object({
    body: z.object({
        rdns: z.union([
            z.string(),
            z.null()
        ])
    }),
    path: z.object({
        address: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * An IP address that exists in Linode's system, either IPv4 or IPv6.
 */
export const putIpResponseSchema = z.object({
    address: z.string().readonly(),
    gateway: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    interface_id: z.union([
        z.int().readonly(),
        z.null()
    ]).readonly(),
    linode_id: z.int().readonly(),
    prefix: z.int().readonly(),
    public: z.boolean().readonly(),
    rdns: z.union([
        z.string(),
        z.null()
    ]),
    region: z.string().readonly(),
    subnet_mask: z.string().readonly(),
    type: z.enum([
        'ipv4',
        'ipv6',
        'ipv6/pool',
        'ipv6/range'
    ]),
    vpc_nat_1_1: z.object({
        address: z.ipv4(),
        subnet_id: z.int(),
        vpc_id: z.int().readonly()
    })
});

export const postAssignIpv4sRequestSchema = z.object({
    body: z.object({
        assignments: z.array(z.object({
            address: z.string(),
            linode_id: z.int()
        })),
        region: z.string()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postAssignIpv4sResponseSchema = z.record(z.string(), z.unknown());

export const postShareIpv4sRequestSchema = z.object({
    body: z.object({
        ips: z.array(z.string()),
        linode_id: z.int()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postShareIpv4sResponseSchema = z.record(z.string(), z.unknown());

export const getIpv6PoolsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * The IPv6 pools on your Account.
 */
export const getIpv6PoolsResponseSchema = z.object({
    data: z.array(z.object({
        prefix: z.int(),
        range: z.string().readonly(),
        region: z.string().readonly(),
        route_target: z.union([
            z.string(),
            z.null()
        ])
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getIpv6RangesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * The IPv6 ranges on your Account.
 */
export const getIpv6RangesResponseSchema = z.object({
    data: z.array(z.object({
        prefix: z.int(),
        range: z.string().readonly(),
        region: z.string().readonly(),
        route_target: z.string()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postIpv6RangeRequestSchema = z.object({
    body: z.object({
        linode_id: z.optional(z.int()),
        prefix_length: z.union([z.literal(56), z.literal(64)]),
        route_target: z.optional(z.ipv6())
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * IPv6 range created successfully.
 */
export const postIpv6RangeResponseSchema = z.object({
    range: z.string(),
    route_target: z.ipv6()
});

export const deleteIpv6RangeRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        range: z.ipv6()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteIpv6RangeResponseSchema = z.record(z.string(), z.unknown());

export const getIpv6RangeRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        range: z.ipv6()
    }),
    query: z.optional(z.never())
});

/**
 * An object representing an IPv6 range.
 */
export const getIpv6RangeResponseSchema = z.object({
    is_bgp: z.boolean().readonly(),
    linodes: z.array(z.int()).readonly(),
    prefix: z.int(),
    range: z.string().readonly(),
    region: z.string().readonly()
});

export const getVlansRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * The VLANs available on this Account.
 */
export const getVlansResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        label: z.string().readonly(),
        linodes: z.array(z.int()).readonly(),
        region: z.string().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const deleteVlanRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        label: z.string(),
        regionId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteVlanResponseSchema = z.record(z.string(), z.unknown());

export const getNodeBalancersRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of NodeBalancers.
 */
export const getNodeBalancersResponseSchema = z.object({
    data: z.array(z.object({
        client_conn_throttle: z.int().gte(0).lte(20),
        created: z.iso.datetime().readonly(),
        hostname: z.string().readonly(),
        id: z.int().readonly(),
        ipv4: z.string().readonly(),
        ipv6: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_]{3,32}/),
        lke_cluster: z.union([
            z.object({
                id: z.string(),
                label: z.string(),
                type: z.string().readonly(),
                url: z.string()
            }).readonly(),
            z.null()
        ]).readonly(),
        region: z.string().readonly(),
        tags: z.array(z.string()),
        transfer: z.object({
            in: z.union([
                z.number().readonly(),
                z.null()
            ]).readonly(),
            out: z.union([
                z.number().readonly(),
                z.null()
            ]).readonly(),
            total: z.union([
                z.number().readonly(),
                z.null()
            ]).readonly()
        }).readonly(),
        type: z.enum(['common', 'premium']),
        updated: z.iso.datetime().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postNodeBalancerRequestSchema = z.object({
    body: z.object({
        client_conn_throttle: z.optional(z.int().gte(0).lte(20)),
        configs: z.optional(z.array(z.union([
            z.object({
                algorithm: z.optional(z.enum([
                    'roundrobin',
                    'leastconn',
                    'ring_hash'
                ])),
                check: z.optional(z.enum([
                    'none',
                    'connection',
                    'http',
                    'http_body'
                ])),
                check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
                check_body: z.optional(z.string()),
                check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
                check_passive: z.optional(z.boolean().readonly()),
                check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
                check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
                cipher_suite: z.optional(z.string().readonly()),
                id: z.optional(z.int().readonly()),
                nodebalancer_id: z.optional(z.int().readonly()),
                nodes: z.array(z.object({
                    address: z.optional(z.string()),
                    config_id: z.optional(z.int().readonly()),
                    id: z.optional(z.int().readonly()),
                    label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
                    mode: z.optional(z.enum(['none'])),
                    nodebalancer_id: z.optional(z.int().readonly()),
                    status: z.optional(z.enum([
                        'unknown',
                        'UP',
                        'DOWN'
                    ])),
                    subnet_id: z.optional(z.int()),
                    weight: z.optional(z.int().gte(1).lte(255))
                })),
                nodes_status: z.optional(z.object({
                    down: z.int().readonly(),
                    up: z.int().readonly()
                }).readonly()),
                port: z.optional(z.int().gte(1).lte(65535)).default(80),
                protocol: z.optional(z.enum(['udp'])),
                proxy_protocol: z.optional(z.string().readonly()),
                ssl_cert: z.optional(z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly()),
                ssl_commonname: z.optional(z.string().readonly()),
                ssl_fingerprint: z.optional(z.string().readonly()),
                ssl_key: z.optional(z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly()),
                stickiness: z.optional(z.enum([
                    'none',
                    'session',
                    'source_ip'
                ])),
                udp_check_port: z.optional(z.int().gte(1).lte(65535)).default(80),
                udp_session_timeout: z.optional(z.int().gte(1).lte(300).readonly()).default(16)
            }),
            z.object({
                algorithm: z.optional(z.enum([
                    'roundrobin',
                    'leastconn',
                    'source'
                ])),
                check: z.optional(z.enum([
                    'none',
                    'connection',
                    'http',
                    'http_body'
                ])),
                check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
                check_body: z.optional(z.string()),
                check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
                check_passive: z.optional(z.boolean()).default(true),
                check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
                check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
                cipher_suite: z.optional(z.string().readonly()),
                id: z.optional(z.int().readonly()),
                nodebalancer_id: z.optional(z.int().readonly()),
                nodes: z.array(z.object({
                    address: z.optional(z.string()),
                    config_id: z.optional(z.int().readonly()),
                    id: z.optional(z.int().readonly()),
                    label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
                    mode: z.optional(z.enum([
                        'accept',
                        'reject',
                        'drain',
                        'backup'
                    ])),
                    nodebalancer_id: z.optional(z.int().readonly()),
                    status: z.optional(z.enum([
                        'unknown',
                        'UP',
                        'DOWN'
                    ])),
                    subnet_id: z.optional(z.int()),
                    weight: z.optional(z.int().gte(1).lte(255))
                })),
                nodes_status: z.optional(z.object({
                    down: z.int().readonly(),
                    up: z.int().readonly()
                }).readonly()),
                port: z.optional(z.int().gte(1).lte(65535)).default(80),
                protocol: z.optional(z.enum(['tcp'])),
                proxy_protocol: z.optional(z.enum([
                    'none',
                    'v1',
                    'v2'
                ])),
                ssl_cert: z.optional(z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly()),
                ssl_commonname: z.optional(z.string().readonly()),
                ssl_fingerprint: z.optional(z.string().readonly()),
                ssl_key: z.optional(z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly()),
                stickiness: z.optional(z.enum(['none', 'table']))
            }),
            z.object({
                algorithm: z.optional(z.enum([
                    'roundrobin',
                    'leastconn',
                    'source'
                ])),
                check: z.optional(z.enum([
                    'none',
                    'connection',
                    'http',
                    'http_body'
                ])),
                check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
                check_body: z.optional(z.string()),
                check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
                check_passive: z.optional(z.boolean()).default(true),
                check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
                check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
                cipher_suite: z.optional(z.string().readonly()),
                id: z.optional(z.int().readonly()),
                nodebalancer_id: z.optional(z.int().readonly()),
                nodes: z.array(z.object({
                    address: z.optional(z.string()),
                    config_id: z.optional(z.int().readonly()),
                    id: z.optional(z.int().readonly()),
                    label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
                    mode: z.optional(z.enum([
                        'accept',
                        'reject',
                        'drain',
                        'backup'
                    ])),
                    nodebalancer_id: z.optional(z.int().readonly()),
                    status: z.optional(z.enum([
                        'unknown',
                        'UP',
                        'DOWN'
                    ])),
                    subnet_id: z.optional(z.int()),
                    weight: z.optional(z.int().gte(1).lte(255))
                })),
                nodes_status: z.optional(z.object({
                    down: z.int().readonly(),
                    up: z.int().readonly()
                }).readonly()),
                port: z.optional(z.int().gte(1).lte(65535)).default(80),
                protocol: z.optional(z.enum(['http'])),
                proxy_protocol: z.optional(z.string().readonly()).default('none'),
                ssl_cert: z.optional(z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly()),
                ssl_commonname: z.optional(z.string().readonly()),
                ssl_fingerprint: z.optional(z.string().readonly()),
                ssl_key: z.optional(z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly()),
                stickiness: z.optional(z.enum([
                    'none',
                    'table',
                    'http_cookie'
                ]))
            }),
            z.object({
                algorithm: z.optional(z.enum([
                    'roundrobin',
                    'leastconn',
                    'source'
                ])),
                check: z.optional(z.enum([
                    'none',
                    'connection',
                    'http',
                    'http_body'
                ])),
                check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
                check_body: z.optional(z.string()),
                check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
                check_passive: z.optional(z.boolean()).default(true),
                check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
                check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
                cipher_suite: z.optional(z.enum(['recommended', 'legacy'])),
                id: z.optional(z.int().readonly()),
                nodebalancer_id: z.optional(z.int().readonly()),
                nodes: z.array(z.object({
                    address: z.optional(z.string()),
                    config_id: z.optional(z.int().readonly()),
                    id: z.optional(z.int().readonly()),
                    label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
                    mode: z.optional(z.enum([
                        'accept',
                        'reject',
                        'drain',
                        'backup'
                    ])),
                    nodebalancer_id: z.optional(z.int().readonly()),
                    status: z.optional(z.enum([
                        'unknown',
                        'UP',
                        'DOWN'
                    ])),
                    subnet_id: z.optional(z.int()),
                    weight: z.optional(z.int().gte(1).lte(255))
                })),
                nodes_status: z.optional(z.object({
                    down: z.int().readonly(),
                    up: z.int().readonly()
                }).readonly()),
                port: z.optional(z.int().gte(1).lte(65535)).default(80),
                protocol: z.optional(z.enum(['https'])),
                proxy_protocol: z.optional(z.string().readonly()).default('none'),
                ssl_cert: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                ssl_commonname: z.optional(z.string().readonly()),
                ssl_fingerprint: z.optional(z.string().readonly()),
                ssl_key: z.optional(z.union([
                    z.string(),
                    z.null()
                ])),
                stickiness: z.optional(z.enum([
                    'none',
                    'table',
                    'http_cookie'
                ]))
            })
        ]))),
        firewall_id: z.optional(z.int()),
        label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_]{3,32}/)),
        region: z.string(),
        tags: z.optional(z.array(z.string())),
        vpcs: z.optional(z.array(z.object({
            id: z.optional(z.int().readonly()),
            ipv4_range: z.optional(z.string()),
            ipv4_range_auto_assign: z.optional(z.union([
                z.boolean().default(false),
                z.null()
            ])).default(false),
            nodebalancer_id: z.optional(z.int().readonly()),
            subnet_id: z.int(),
            vpc_id: z.optional(z.union([
                z.int().readonly(),
                z.null()
            ]).readonly())
        })))
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * NodeBalancer
 *
 * Linode's load balancing solution. Can handle multiple ports, SSL termination, and any number of backends. NodeBalancer ports are configured with NodeBalancer configs, and each config is given one or more NodeBalancer nodes that accepts traffic.  The traffic should be routed to the NodeBalancer's IP address, for the NodeBalancer to handle routing individual requests to backends.
 */
export const postNodeBalancerResponseSchema = z.object({
    client_conn_throttle: z.int().gte(0).lte(20),
    created: z.iso.datetime().readonly(),
    hostname: z.string().readonly(),
    id: z.int().readonly(),
    ipv4: z.string().readonly(),
    ipv6: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_]{3,32}/),
    lke_cluster: z.union([
        z.object({
            id: z.string(),
            label: z.string(),
            type: z.string().readonly(),
            url: z.string()
        }).readonly(),
        z.null()
    ]).readonly(),
    region: z.string().readonly(),
    tags: z.array(z.string()),
    transfer: z.object({
        in: z.union([
            z.number().readonly(),
            z.null()
        ]).readonly(),
        out: z.union([
            z.number().readonly(),
            z.null()
        ]).readonly(),
        total: z.union([
            z.number().readonly(),
            z.null()
        ]).readonly()
    }).readonly(),
    type: z.enum(['common', 'premium']),
    updated: z.iso.datetime().readonly()
});

export const getNodeBalancerTypesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A collection of NodeBalancer types.
 */
export const getNodeBalancerTypesResponseSchema = z.object({
    data: z.array(z.object({
        id: z.string().readonly(),
        label: z.string().readonly(),
        price: z.object({
            hourly: z.number(),
            monthly: z.number()
        }).readonly(),
        region_prices: z.array(z.object({
            hourly: z.number(),
            id: z.string(),
            monthly: z.number()
        })),
        transfer: z.int().gte(0).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const deleteNodeBalancerRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        nodeBalancerId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteNodeBalancerResponseSchema = z.record(z.string(), z.unknown());

export const getNodeBalancerRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        nodeBalancerId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * NodeBalancer
 *
 * Linode's load balancing solution. Can handle multiple ports, SSL termination, and any number of backends. NodeBalancer ports are configured with NodeBalancer configs, and each config is given one or more NodeBalancer nodes that accepts traffic.  The traffic should be routed to the NodeBalancer's IP address, for the NodeBalancer to handle routing individual requests to backends.
 */
export const getNodeBalancerResponseSchema = z.object({
    client_conn_throttle: z.int().gte(0).lte(20),
    created: z.iso.datetime().readonly(),
    hostname: z.string().readonly(),
    id: z.int().readonly(),
    ipv4: z.string().readonly(),
    ipv6: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_]{3,32}/),
    lke_cluster: z.union([
        z.object({
            id: z.string(),
            label: z.string(),
            type: z.string().readonly(),
            url: z.string()
        }).readonly(),
        z.null()
    ]).readonly(),
    region: z.string().readonly(),
    tags: z.array(z.string()),
    transfer: z.object({
        in: z.union([
            z.number().readonly(),
            z.null()
        ]).readonly(),
        out: z.union([
            z.number().readonly(),
            z.null()
        ]).readonly(),
        total: z.union([
            z.number().readonly(),
            z.null()
        ]).readonly()
    }).readonly(),
    type: z.enum(['common', 'premium']),
    updated: z.iso.datetime().readonly()
});

export const putNodeBalancerRequestSchema = z.object({
    body: z.object({
        client_conn_throttle: z.int().gte(0).lte(20),
        created: z.iso.datetime().readonly(),
        hostname: z.string().readonly(),
        id: z.int().readonly(),
        ipv4: z.string().readonly(),
        ipv6: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_]{3,32}/),
        lke_cluster: z.union([
            z.object({
                id: z.string(),
                label: z.string(),
                type: z.string().readonly(),
                url: z.string()
            }).readonly(),
            z.null()
        ]).readonly(),
        region: z.string().readonly(),
        tags: z.array(z.string()),
        transfer: z.object({
            in: z.union([
                z.number().readonly(),
                z.null()
            ]).readonly(),
            out: z.union([
                z.number().readonly(),
                z.null()
            ]).readonly(),
            total: z.union([
                z.number().readonly(),
                z.null()
            ]).readonly()
        }).readonly(),
        type: z.enum(['common', 'premium']),
        updated: z.iso.datetime().readonly()
    }),
    path: z.object({
        nodeBalancerId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * NodeBalancer
 *
 * Linode's load balancing solution. Can handle multiple ports, SSL termination, and any number of backends. NodeBalancer ports are configured with NodeBalancer configs, and each config is given one or more NodeBalancer nodes that accepts traffic.  The traffic should be routed to the NodeBalancer's IP address, for the NodeBalancer to handle routing individual requests to backends.
 */
export const putNodeBalancerResponseSchema = z.object({
    client_conn_throttle: z.int().gte(0).lte(20),
    created: z.iso.datetime().readonly(),
    hostname: z.string().readonly(),
    id: z.int().readonly(),
    ipv4: z.string().readonly(),
    ipv6: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_]{3,32}/),
    lke_cluster: z.union([
        z.object({
            id: z.string(),
            label: z.string(),
            type: z.string().readonly(),
            url: z.string()
        }).readonly(),
        z.null()
    ]).readonly(),
    region: z.string().readonly(),
    tags: z.array(z.string()),
    transfer: z.object({
        in: z.union([
            z.number().readonly(),
            z.null()
        ]).readonly(),
        out: z.union([
            z.number().readonly(),
            z.null()
        ]).readonly(),
        total: z.union([
            z.number().readonly(),
            z.null()
        ]).readonly()
    }).readonly(),
    type: z.enum(['common', 'premium']),
    updated: z.iso.datetime().readonly()
});

export const getNodeBalancerConfigsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        nodeBalancerId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * NodeBalancer `config` options for each protocol.
 */
export const getNodeBalancerConfigsResponseSchema = z.union([
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'ring_hash'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean().readonly()),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['udp'])),
        proxy_protocol: z.optional(z.string().readonly()),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'session',
            'source_ip'
        ])),
        udp_check_port: z.optional(z.int().gte(1).lte(65535)).default(80),
        udp_session_timeout: z.optional(z.int().gte(1).lte(300).readonly()).default(16)
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['tcp'])),
        proxy_protocol: z.optional(z.enum([
            'none',
            'v1',
            'v2'
        ])),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['http'])),
        proxy_protocol: z.optional(z.string().readonly()).default('none'),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
        cipher_suite: z.optional(z.enum(['recommended', 'legacy'])),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['https'])),
        proxy_protocol: z.optional(z.string().readonly()).default('none'),
        ssl_cert: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    })
]);

export const postNodeBalancerConfigRequestSchema = z.object({
    body: z.optional(z.intersection(z.union([
        z.object({
            algorithm: z.optional(z.enum([
                'roundrobin',
                'leastconn',
                'ring_hash'
            ])),
            check: z.optional(z.enum([
                'none',
                'connection',
                'http',
                'http_body'
            ])),
            check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
            check_body: z.optional(z.string()),
            check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
            check_passive: z.optional(z.boolean().readonly()),
            check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
            check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
            cipher_suite: z.optional(z.string().readonly()),
            id: z.optional(z.int().readonly()),
            nodebalancer_id: z.optional(z.int().readonly()),
            nodes: z.array(z.object({
                address: z.optional(z.string()),
                config_id: z.optional(z.int().readonly()),
                id: z.optional(z.int().readonly()),
                label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
                mode: z.optional(z.enum(['none'])),
                nodebalancer_id: z.optional(z.int().readonly()),
                status: z.optional(z.enum([
                    'unknown',
                    'UP',
                    'DOWN'
                ])),
                subnet_id: z.optional(z.int()),
                weight: z.optional(z.int().gte(1).lte(255))
            })),
            nodes_status: z.optional(z.object({
                down: z.int().readonly(),
                up: z.int().readonly()
            }).readonly()),
            port: z.optional(z.int().gte(1).lte(65535)).default(80),
            protocol: z.optional(z.enum(['udp'])),
            proxy_protocol: z.optional(z.string().readonly()),
            ssl_cert: z.optional(z.union([
                z.string().readonly(),
                z.null()
            ]).readonly()),
            ssl_commonname: z.optional(z.string().readonly()),
            ssl_fingerprint: z.optional(z.string().readonly()),
            ssl_key: z.optional(z.union([
                z.string().readonly(),
                z.null()
            ]).readonly()),
            stickiness: z.optional(z.enum([
                'none',
                'session',
                'source_ip'
            ])),
            udp_check_port: z.optional(z.int().gte(1).lte(65535)).default(80),
            udp_session_timeout: z.optional(z.int().gte(1).lte(300).readonly()).default(16)
        }),
        z.object({
            algorithm: z.optional(z.enum([
                'roundrobin',
                'leastconn',
                'source'
            ])),
            check: z.optional(z.enum([
                'none',
                'connection',
                'http',
                'http_body'
            ])),
            check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
            check_body: z.optional(z.string()),
            check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
            check_passive: z.optional(z.boolean()).default(true),
            check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
            check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
            cipher_suite: z.optional(z.string().readonly()),
            id: z.optional(z.int().readonly()),
            nodebalancer_id: z.optional(z.int().readonly()),
            nodes: z.array(z.object({
                address: z.optional(z.string()),
                config_id: z.optional(z.int().readonly()),
                id: z.optional(z.int().readonly()),
                label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
                mode: z.optional(z.enum([
                    'accept',
                    'reject',
                    'drain',
                    'backup'
                ])),
                nodebalancer_id: z.optional(z.int().readonly()),
                status: z.optional(z.enum([
                    'unknown',
                    'UP',
                    'DOWN'
                ])),
                subnet_id: z.optional(z.int()),
                weight: z.optional(z.int().gte(1).lte(255))
            })),
            nodes_status: z.optional(z.object({
                down: z.int().readonly(),
                up: z.int().readonly()
            }).readonly()),
            port: z.optional(z.int().gte(1).lte(65535)).default(80),
            protocol: z.optional(z.enum(['tcp'])),
            proxy_protocol: z.optional(z.enum([
                'none',
                'v1',
                'v2'
            ])),
            ssl_cert: z.optional(z.union([
                z.string().readonly(),
                z.null()
            ]).readonly()),
            ssl_commonname: z.optional(z.string().readonly()),
            ssl_fingerprint: z.optional(z.string().readonly()),
            ssl_key: z.optional(z.union([
                z.string().readonly(),
                z.null()
            ]).readonly()),
            stickiness: z.optional(z.enum(['none', 'table']))
        }),
        z.object({
            algorithm: z.optional(z.enum([
                'roundrobin',
                'leastconn',
                'source'
            ])),
            check: z.optional(z.enum([
                'none',
                'connection',
                'http',
                'http_body'
            ])),
            check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
            check_body: z.optional(z.string()),
            check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
            check_passive: z.optional(z.boolean()).default(true),
            check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
            check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
            cipher_suite: z.optional(z.string().readonly()),
            id: z.optional(z.int().readonly()),
            nodebalancer_id: z.optional(z.int().readonly()),
            nodes: z.array(z.object({
                address: z.optional(z.string()),
                config_id: z.optional(z.int().readonly()),
                id: z.optional(z.int().readonly()),
                label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
                mode: z.optional(z.enum([
                    'accept',
                    'reject',
                    'drain',
                    'backup'
                ])),
                nodebalancer_id: z.optional(z.int().readonly()),
                status: z.optional(z.enum([
                    'unknown',
                    'UP',
                    'DOWN'
                ])),
                subnet_id: z.optional(z.int()),
                weight: z.optional(z.int().gte(1).lte(255))
            })),
            nodes_status: z.optional(z.object({
                down: z.int().readonly(),
                up: z.int().readonly()
            }).readonly()),
            port: z.optional(z.int().gte(1).lte(65535)).default(80),
            protocol: z.optional(z.enum(['http'])),
            proxy_protocol: z.optional(z.string().readonly()).default('none'),
            ssl_cert: z.optional(z.union([
                z.string().readonly(),
                z.null()
            ]).readonly()),
            ssl_commonname: z.optional(z.string().readonly()),
            ssl_fingerprint: z.optional(z.string().readonly()),
            ssl_key: z.optional(z.union([
                z.string().readonly(),
                z.null()
            ]).readonly()),
            stickiness: z.optional(z.enum([
                'none',
                'table',
                'http_cookie'
            ]))
        }),
        z.object({
            algorithm: z.optional(z.enum([
                'roundrobin',
                'leastconn',
                'source'
            ])),
            check: z.optional(z.enum([
                'none',
                'connection',
                'http',
                'http_body'
            ])),
            check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
            check_body: z.optional(z.string()),
            check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
            check_passive: z.optional(z.boolean()).default(true),
            check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
            check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
            cipher_suite: z.optional(z.enum(['recommended', 'legacy'])),
            id: z.optional(z.int().readonly()),
            nodebalancer_id: z.optional(z.int().readonly()),
            nodes: z.array(z.object({
                address: z.optional(z.string()),
                config_id: z.optional(z.int().readonly()),
                id: z.optional(z.int().readonly()),
                label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
                mode: z.optional(z.enum([
                    'accept',
                    'reject',
                    'drain',
                    'backup'
                ])),
                nodebalancer_id: z.optional(z.int().readonly()),
                status: z.optional(z.enum([
                    'unknown',
                    'UP',
                    'DOWN'
                ])),
                subnet_id: z.optional(z.int()),
                weight: z.optional(z.int().gte(1).lte(255))
            })),
            nodes_status: z.optional(z.object({
                down: z.int().readonly(),
                up: z.int().readonly()
            }).readonly()),
            port: z.optional(z.int().gte(1).lte(65535)).default(80),
            protocol: z.optional(z.enum(['https'])),
            proxy_protocol: z.optional(z.string().readonly()).default('none'),
            ssl_cert: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            ssl_commonname: z.optional(z.string().readonly()),
            ssl_fingerprint: z.optional(z.string().readonly()),
            ssl_key: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            stickiness: z.optional(z.enum([
                'none',
                'table',
                'http_cookie'
            ]))
        })
    ]), z.object({
        nodes: z.array(z.object({
            address: z.string(),
            id: z.int(),
            label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/),
            mode: z.enum([
                'accept',
                'reject',
                'drain',
                'backup'
            ]),
            subnet_id: z.int(),
            weight: z.int().gte(1).lte(255)
        }))
    }))),
    path: z.object({
        nodeBalancerId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * NodeBalancer `config` options for each protocol.
 */
export const postNodeBalancerConfigResponseSchema = z.union([
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'ring_hash'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean().readonly()),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['udp'])),
        proxy_protocol: z.optional(z.string().readonly()),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'session',
            'source_ip'
        ])),
        udp_check_port: z.optional(z.int().gte(1).lte(65535)).default(80),
        udp_session_timeout: z.optional(z.int().gte(1).lte(300).readonly()).default(16)
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['tcp'])),
        proxy_protocol: z.optional(z.enum([
            'none',
            'v1',
            'v2'
        ])),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['http'])),
        proxy_protocol: z.optional(z.string().readonly()).default('none'),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
        cipher_suite: z.optional(z.enum(['recommended', 'legacy'])),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['https'])),
        proxy_protocol: z.optional(z.string().readonly()).default('none'),
        ssl_cert: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    })
]);

export const deleteNodeBalancerConfigRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        nodeBalancerId: z.int(),
        configId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteNodeBalancerConfigResponseSchema = z.record(z.string(), z.unknown());

export const getNodeBalancerConfigRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        nodeBalancerId: z.int(),
        configId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * NodeBalancer `config` options for each protocol.
 */
export const getNodeBalancerConfigResponseSchema = z.union([
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'ring_hash'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean().readonly()),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['udp'])),
        proxy_protocol: z.optional(z.string().readonly()),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'session',
            'source_ip'
        ])),
        udp_check_port: z.optional(z.int().gte(1).lte(65535)).default(80),
        udp_session_timeout: z.optional(z.int().gte(1).lte(300).readonly()).default(16)
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['tcp'])),
        proxy_protocol: z.optional(z.enum([
            'none',
            'v1',
            'v2'
        ])),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['http'])),
        proxy_protocol: z.optional(z.string().readonly()).default('none'),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
        cipher_suite: z.optional(z.enum(['recommended', 'legacy'])),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['https'])),
        proxy_protocol: z.optional(z.string().readonly()).default('none'),
        ssl_cert: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    })
]);

export const putNodeBalancerConfigRequestSchema = z.object({
    body: z.union([
        z.object({
            algorithm: z.enum([
                'roundrobin',
                'leastconn',
                'ring_hash'
            ]),
            check: z.enum([
                'none',
                'connection',
                'http',
                'http_body'
            ]),
            check_attempts: z.int().gte(1).lte(30).default(3),
            check_body: z.string(),
            check_interval: z.int().gte(2).lte(3600).default(5),
            check_passive: z.boolean().readonly(),
            check_path: z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/),
            check_timeout: z.int().gte(1).lte(30).default(30),
            cipher_suite: z.string().readonly(),
            id: z.int().readonly(),
            nodebalancer_id: z.int().readonly(),
            nodes_status: z.object({
                down: z.int().readonly(),
                up: z.int().readonly()
            }).readonly(),
            port: z.int().gte(1).lte(65535).default(80),
            protocol: z.enum(['udp']),
            proxy_protocol: z.string().readonly(),
            ssl_cert: z.union([
                z.string().readonly(),
                z.null()
            ]).readonly(),
            ssl_commonname: z.string().readonly(),
            ssl_fingerprint: z.string().readonly(),
            ssl_key: z.union([
                z.string().readonly(),
                z.null()
            ]).readonly(),
            stickiness: z.enum([
                'none',
                'session',
                'source_ip'
            ]),
            udp_check_port: z.int().gte(1).lte(65535).default(80),
            udp_session_timeout: z.int().gte(1).lte(300).readonly().default(16)
        }),
        z.object({
            algorithm: z.enum([
                'roundrobin',
                'leastconn',
                'source'
            ]),
            check: z.enum([
                'none',
                'connection',
                'http',
                'http_body'
            ]),
            check_attempts: z.int().gte(1).lte(30).default(3),
            check_body: z.string(),
            check_interval: z.int().gte(2).lte(3600).default(5),
            check_passive: z.boolean().default(true),
            check_path: z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/),
            check_timeout: z.int().gte(1).lte(30).default(30),
            cipher_suite: z.string().readonly(),
            id: z.int().readonly(),
            nodebalancer_id: z.int().readonly(),
            nodes_status: z.object({
                down: z.int().readonly(),
                up: z.int().readonly()
            }).readonly(),
            port: z.int().gte(1).lte(65535).default(80),
            protocol: z.enum(['tcp']),
            proxy_protocol: z.enum([
                'none',
                'v1',
                'v2'
            ]),
            ssl_cert: z.union([
                z.string().readonly(),
                z.null()
            ]).readonly(),
            ssl_commonname: z.string().readonly(),
            ssl_fingerprint: z.string().readonly(),
            ssl_key: z.union([
                z.string().readonly(),
                z.null()
            ]).readonly(),
            stickiness: z.enum(['none', 'table'])
        }),
        z.object({
            algorithm: z.enum([
                'roundrobin',
                'leastconn',
                'source'
            ]),
            check: z.enum([
                'none',
                'connection',
                'http',
                'http_body'
            ]),
            check_attempts: z.int().gte(1).lte(30).default(3),
            check_body: z.string(),
            check_interval: z.int().gte(2).lte(3600).default(5),
            check_passive: z.boolean().default(true),
            check_path: z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/),
            check_timeout: z.int().gte(1).lte(30).default(3),
            cipher_suite: z.string().readonly(),
            id: z.int().readonly(),
            nodebalancer_id: z.int().readonly(),
            nodes_status: z.object({
                down: z.int().readonly(),
                up: z.int().readonly()
            }).readonly(),
            port: z.int().gte(1).lte(65535).default(80),
            protocol: z.enum(['http']),
            proxy_protocol: z.string().readonly().default('none'),
            ssl_cert: z.union([
                z.string().readonly(),
                z.null()
            ]).readonly(),
            ssl_commonname: z.string().readonly(),
            ssl_fingerprint: z.string().readonly(),
            ssl_key: z.union([
                z.string().readonly(),
                z.null()
            ]).readonly(),
            stickiness: z.enum([
                'none',
                'table',
                'http_cookie'
            ])
        }),
        z.object({
            algorithm: z.enum([
                'roundrobin',
                'leastconn',
                'source'
            ]),
            check: z.enum([
                'none',
                'connection',
                'http',
                'http_body'
            ]),
            check_attempts: z.int().gte(1).lte(30).default(3),
            check_body: z.string(),
            check_interval: z.int().gte(2).lte(3600).default(5),
            check_passive: z.boolean().default(true),
            check_path: z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/),
            check_timeout: z.int().gte(1).lte(30).default(3),
            cipher_suite: z.enum(['recommended', 'legacy']),
            id: z.int().readonly(),
            nodebalancer_id: z.int().readonly(),
            nodes_status: z.object({
                down: z.int().readonly(),
                up: z.int().readonly()
            }).readonly(),
            port: z.int().gte(1).lte(65535).default(80),
            protocol: z.enum(['https']),
            proxy_protocol: z.string().readonly().default('none'),
            ssl_cert: z.union([
                z.string(),
                z.null()
            ]),
            ssl_commonname: z.string().readonly(),
            ssl_fingerprint: z.string().readonly(),
            ssl_key: z.union([
                z.string(),
                z.null()
            ]),
            stickiness: z.enum([
                'none',
                'table',
                'http_cookie'
            ])
        })
    ]),
    path: z.object({
        nodeBalancerId: z.int(),
        configId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * NodeBalancer `config` options for each protocol.
 */
export const putNodeBalancerConfigResponseSchema = z.union([
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'ring_hash'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean().readonly()),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['udp'])),
        proxy_protocol: z.optional(z.string().readonly()),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'session',
            'source_ip'
        ])),
        udp_check_port: z.optional(z.int().gte(1).lte(65535)).default(80),
        udp_session_timeout: z.optional(z.int().gte(1).lte(300).readonly()).default(16)
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['tcp'])),
        proxy_protocol: z.optional(z.enum([
            'none',
            'v1',
            'v2'
        ])),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['http'])),
        proxy_protocol: z.optional(z.string().readonly()).default('none'),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
        cipher_suite: z.optional(z.enum(['recommended', 'legacy'])),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['https'])),
        proxy_protocol: z.optional(z.string().readonly()).default('none'),
        ssl_cert: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    })
]);

export const getNodeBalancerConfigNodesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        nodeBalancerId: z.int(),
        configId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of NodeBalancer nodes.
 */
export const getNodeBalancerConfigNodesResponseSchema = z.object({
    data: z.array(z.union([z.object({
            address: z.optional(z.string()),
            config_id: z.optional(z.int().readonly()),
            id: z.optional(z.int().readonly()),
            label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
            mode: z.optional(z.enum([
                'accept',
                'reject',
                'drain',
                'backup'
            ])),
            nodebalancer_id: z.optional(z.int().readonly()),
            status: z.optional(z.enum([
                'Unknown',
                'UP',
                'DOWN'
            ])),
            vpc_config_id: z.optional(z.union([
                z.int().readonly(),
                z.null()
            ]).readonly()),
            weight: z.optional(z.int().gte(1).lte(255))
        }), z.object({
            address: z.optional(z.string()),
            config_id: z.optional(z.int().readonly()),
            id: z.optional(z.int().readonly()),
            label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
            mode: z.optional(z.enum(['none'])),
            nodebalancer_id: z.optional(z.int().readonly()),
            status: z.optional(z.enum([
                'Unknown',
                'UP',
                'DOWN'
            ])),
            vpc_config_id: z.optional(z.union([
                z.int().readonly(),
                z.null()
            ]).readonly()),
            weight: z.optional(z.int().gte(1).lte(255))
        })])),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postNodeBalancerNodeRequestSchema = z.object({
    body: z.union([
        z.object({
            address: z.optional(z.string()),
            config_id: z.optional(z.int().readonly()),
            id: z.optional(z.int().readonly()),
            label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
            mode: z.optional(z.enum(['none'])),
            nodebalancer_id: z.optional(z.int().readonly()),
            status: z.optional(z.enum([
                'unknown',
                'UP',
                'DOWN'
            ])),
            subnet_id: z.optional(z.int()),
            weight: z.optional(z.int().gte(1).lte(255))
        }),
        z.object({
            address: z.optional(z.string()),
            config_id: z.optional(z.int().readonly()),
            id: z.optional(z.int().readonly()),
            label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
            mode: z.optional(z.enum([
                'accept',
                'reject',
                'drain',
                'backup'
            ])),
            nodebalancer_id: z.optional(z.int().readonly()),
            status: z.optional(z.enum([
                'unknown',
                'UP',
                'DOWN'
            ])),
            subnet_id: z.optional(z.int()),
            weight: z.optional(z.int().gte(1).lte(255))
        })
    ]),
    path: z.object({
        nodeBalancerId: z.int(),
        configId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A NodeBalancer node represents a single backend serving requests for a single port on a NodeBalancer. Nodes are tied to NodeBalancer configurations, and serve traffic over their private IPv4 address, IPv6 address, or VPC IPv4 address. If the same Linode is serving traffic for more than one port on the same NodeBalancer, one NodeBalancer node is required for each config (port) it should serve requests on.  For example, if you have four backends, and each should respond to both HTTP and HTTPS requests, you will need two NodeBalancer configs (port 80 and port 443) and four backends each, one for each of the Linodes serving requests for that port.
 */
export const postNodeBalancerNodeResponseSchema = z.union([
    z.object({
        address: z.optional(z.string()),
        config_id: z.optional(z.int().readonly()),
        id: z.optional(z.int().readonly()),
        label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
        mode: z.optional(z.enum([
            'accept',
            'reject',
            'drain',
            'backup'
        ])),
        nodebalancer_id: z.optional(z.int().readonly()),
        status: z.optional(z.enum([
            'Unknown',
            'UP',
            'DOWN'
        ])),
        vpc_config_id: z.optional(z.union([
            z.int().readonly(),
            z.null()
        ]).readonly()),
        weight: z.optional(z.int().gte(1).lte(255))
    }),
    z.object({
        address: z.optional(z.string()),
        config_id: z.optional(z.int().readonly()),
        id: z.optional(z.int().readonly()),
        label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
        mode: z.optional(z.enum(['none'])),
        nodebalancer_id: z.optional(z.int().readonly()),
        status: z.optional(z.enum([
            'Unknown',
            'UP',
            'DOWN'
        ])),
        vpc_config_id: z.optional(z.union([
            z.int().readonly(),
            z.null()
        ]).readonly()),
        weight: z.optional(z.int().gte(1).lte(255))
    })
]);

export const deleteNodeBalancerConfigNodeRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        nodeBalancerId: z.int(),
        configId: z.int(),
        nodeId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteNodeBalancerConfigNodeResponseSchema = z.record(z.string(), z.unknown());

export const getNodeBalancerNodeRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        nodeBalancerId: z.int(),
        configId: z.int(),
        nodeId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A NodeBalancer node represents a single backend serving requests for a single port on a NodeBalancer. Nodes are tied to NodeBalancer configurations, and serve traffic over their private IPv4 address, IPv6 address, or VPC IPv4 address. If the same Linode is serving traffic for more than one port on the same NodeBalancer, one NodeBalancer node is required for each config (port) it should serve requests on.  For example, if you have four backends, and each should respond to both HTTP and HTTPS requests, you will need two NodeBalancer configs (port 80 and port 443) and four backends each, one for each of the Linodes serving requests for that port.
 */
export const getNodeBalancerNodeResponseSchema = z.union([
    z.object({
        address: z.optional(z.string()),
        config_id: z.optional(z.int().readonly()),
        id: z.optional(z.int().readonly()),
        label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
        mode: z.optional(z.enum([
            'accept',
            'reject',
            'drain',
            'backup'
        ])),
        nodebalancer_id: z.optional(z.int().readonly()),
        status: z.optional(z.enum([
            'Unknown',
            'UP',
            'DOWN'
        ])),
        vpc_config_id: z.optional(z.union([
            z.int().readonly(),
            z.null()
        ]).readonly()),
        weight: z.optional(z.int().gte(1).lte(255))
    }),
    z.object({
        address: z.optional(z.string()),
        config_id: z.optional(z.int().readonly()),
        id: z.optional(z.int().readonly()),
        label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
        mode: z.optional(z.enum(['none'])),
        nodebalancer_id: z.optional(z.int().readonly()),
        status: z.optional(z.enum([
            'Unknown',
            'UP',
            'DOWN'
        ])),
        vpc_config_id: z.optional(z.union([
            z.int().readonly(),
            z.null()
        ]).readonly()),
        weight: z.optional(z.int().gte(1).lte(255))
    })
]);

export const putNodeBalancerNodeRequestSchema = z.object({
    body: z.union([
        z.object({
            address: z.optional(z.string()),
            config_id: z.optional(z.int().readonly()),
            id: z.optional(z.int().readonly()),
            label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
            mode: z.optional(z.enum(['none'])),
            nodebalancer_id: z.optional(z.int().readonly()),
            status: z.optional(z.enum([
                'unknown',
                'UP',
                'DOWN'
            ])),
            subnet_id: z.optional(z.int()),
            weight: z.optional(z.int().gte(1).lte(255))
        }),
        z.object({
            address: z.optional(z.string()),
            config_id: z.optional(z.int().readonly()),
            id: z.optional(z.int().readonly()),
            label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
            mode: z.optional(z.enum([
                'accept',
                'reject',
                'drain',
                'backup'
            ])),
            nodebalancer_id: z.optional(z.int().readonly()),
            status: z.optional(z.enum([
                'unknown',
                'UP',
                'DOWN'
            ])),
            subnet_id: z.optional(z.int()),
            weight: z.optional(z.int().gte(1).lte(255))
        })
    ]),
    path: z.object({
        nodeBalancerId: z.int(),
        configId: z.int(),
        nodeId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A NodeBalancer node represents a single backend serving requests for a single port on a NodeBalancer. Nodes are tied to NodeBalancer configurations, and serve traffic over their private IPv4 address, IPv6 address, or VPC IPv4 address. If the same Linode is serving traffic for more than one port on the same NodeBalancer, one NodeBalancer node is required for each config (port) it should serve requests on.  For example, if you have four backends, and each should respond to both HTTP and HTTPS requests, you will need two NodeBalancer configs (port 80 and port 443) and four backends each, one for each of the Linodes serving requests for that port.
 */
export const putNodeBalancerNodeResponseSchema = z.union([
    z.object({
        address: z.optional(z.string()),
        config_id: z.optional(z.int().readonly()),
        id: z.optional(z.int().readonly()),
        label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
        mode: z.optional(z.enum([
            'accept',
            'reject',
            'drain',
            'backup'
        ])),
        nodebalancer_id: z.optional(z.int().readonly()),
        status: z.optional(z.enum([
            'Unknown',
            'UP',
            'DOWN'
        ])),
        vpc_config_id: z.optional(z.union([
            z.int().readonly(),
            z.null()
        ]).readonly()),
        weight: z.optional(z.int().gte(1).lte(255))
    }),
    z.object({
        address: z.optional(z.string()),
        config_id: z.optional(z.int().readonly()),
        id: z.optional(z.int().readonly()),
        label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
        mode: z.optional(z.enum(['none'])),
        nodebalancer_id: z.optional(z.int().readonly()),
        status: z.optional(z.enum([
            'Unknown',
            'UP',
            'DOWN'
        ])),
        vpc_config_id: z.optional(z.union([
            z.int().readonly(),
            z.null()
        ]).readonly()),
        weight: z.optional(z.int().gte(1).lte(255))
    })
]);

export const postRebuildNodeBalancerConfigRequestSchema = z.object({
    body: z.intersection(z.union([
        z.object({
            algorithm: z.optional(z.enum([
                'roundrobin',
                'leastconn',
                'ring_hash'
            ])),
            check: z.optional(z.enum([
                'none',
                'connection',
                'http',
                'http_body'
            ])),
            check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
            check_body: z.optional(z.string()),
            check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
            check_passive: z.optional(z.boolean().readonly()),
            check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
            check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
            cipher_suite: z.optional(z.string().readonly()),
            id: z.optional(z.int().readonly()),
            nodebalancer_id: z.optional(z.int().readonly()),
            nodes: z.array(z.object({
                address: z.optional(z.string()),
                config_id: z.optional(z.int().readonly()),
                id: z.optional(z.int().readonly()),
                label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
                mode: z.optional(z.enum(['none'])),
                nodebalancer_id: z.optional(z.int().readonly()),
                status: z.optional(z.enum([
                    'unknown',
                    'UP',
                    'DOWN'
                ])),
                subnet_id: z.optional(z.int()),
                weight: z.optional(z.int().gte(1).lte(255))
            })),
            nodes_status: z.optional(z.object({
                down: z.int().readonly(),
                up: z.int().readonly()
            }).readonly()),
            port: z.optional(z.int().gte(1).lte(65535)).default(80),
            protocol: z.optional(z.enum(['udp'])),
            proxy_protocol: z.optional(z.string().readonly()),
            ssl_cert: z.optional(z.union([
                z.string().readonly(),
                z.null()
            ]).readonly()),
            ssl_commonname: z.optional(z.string().readonly()),
            ssl_fingerprint: z.optional(z.string().readonly()),
            ssl_key: z.optional(z.union([
                z.string().readonly(),
                z.null()
            ]).readonly()),
            stickiness: z.optional(z.enum([
                'none',
                'session',
                'source_ip'
            ])),
            udp_check_port: z.optional(z.int().gte(1).lte(65535)).default(80),
            udp_session_timeout: z.optional(z.int().gte(1).lte(300).readonly()).default(16)
        }),
        z.object({
            algorithm: z.optional(z.enum([
                'roundrobin',
                'leastconn',
                'source'
            ])),
            check: z.optional(z.enum([
                'none',
                'connection',
                'http',
                'http_body'
            ])),
            check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
            check_body: z.optional(z.string()),
            check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
            check_passive: z.optional(z.boolean()).default(true),
            check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
            check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
            cipher_suite: z.optional(z.string().readonly()),
            id: z.optional(z.int().readonly()),
            nodebalancer_id: z.optional(z.int().readonly()),
            nodes: z.array(z.object({
                address: z.optional(z.string()),
                config_id: z.optional(z.int().readonly()),
                id: z.optional(z.int().readonly()),
                label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
                mode: z.optional(z.enum([
                    'accept',
                    'reject',
                    'drain',
                    'backup'
                ])),
                nodebalancer_id: z.optional(z.int().readonly()),
                status: z.optional(z.enum([
                    'unknown',
                    'UP',
                    'DOWN'
                ])),
                subnet_id: z.optional(z.int()),
                weight: z.optional(z.int().gte(1).lte(255))
            })),
            nodes_status: z.optional(z.object({
                down: z.int().readonly(),
                up: z.int().readonly()
            }).readonly()),
            port: z.optional(z.int().gte(1).lte(65535)).default(80),
            protocol: z.optional(z.enum(['tcp'])),
            proxy_protocol: z.optional(z.enum([
                'none',
                'v1',
                'v2'
            ])),
            ssl_cert: z.optional(z.union([
                z.string().readonly(),
                z.null()
            ]).readonly()),
            ssl_commonname: z.optional(z.string().readonly()),
            ssl_fingerprint: z.optional(z.string().readonly()),
            ssl_key: z.optional(z.union([
                z.string().readonly(),
                z.null()
            ]).readonly()),
            stickiness: z.optional(z.enum(['none', 'table']))
        }),
        z.object({
            algorithm: z.optional(z.enum([
                'roundrobin',
                'leastconn',
                'source'
            ])),
            check: z.optional(z.enum([
                'none',
                'connection',
                'http',
                'http_body'
            ])),
            check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
            check_body: z.optional(z.string()),
            check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
            check_passive: z.optional(z.boolean()).default(true),
            check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
            check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
            cipher_suite: z.optional(z.string().readonly()),
            id: z.optional(z.int().readonly()),
            nodebalancer_id: z.optional(z.int().readonly()),
            nodes: z.array(z.object({
                address: z.optional(z.string()),
                config_id: z.optional(z.int().readonly()),
                id: z.optional(z.int().readonly()),
                label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
                mode: z.optional(z.enum([
                    'accept',
                    'reject',
                    'drain',
                    'backup'
                ])),
                nodebalancer_id: z.optional(z.int().readonly()),
                status: z.optional(z.enum([
                    'unknown',
                    'UP',
                    'DOWN'
                ])),
                subnet_id: z.optional(z.int()),
                weight: z.optional(z.int().gte(1).lte(255))
            })),
            nodes_status: z.optional(z.object({
                down: z.int().readonly(),
                up: z.int().readonly()
            }).readonly()),
            port: z.optional(z.int().gte(1).lte(65535)).default(80),
            protocol: z.optional(z.enum(['http'])),
            proxy_protocol: z.optional(z.string().readonly()).default('none'),
            ssl_cert: z.optional(z.union([
                z.string().readonly(),
                z.null()
            ]).readonly()),
            ssl_commonname: z.optional(z.string().readonly()),
            ssl_fingerprint: z.optional(z.string().readonly()),
            ssl_key: z.optional(z.union([
                z.string().readonly(),
                z.null()
            ]).readonly()),
            stickiness: z.optional(z.enum([
                'none',
                'table',
                'http_cookie'
            ]))
        }),
        z.object({
            algorithm: z.optional(z.enum([
                'roundrobin',
                'leastconn',
                'source'
            ])),
            check: z.optional(z.enum([
                'none',
                'connection',
                'http',
                'http_body'
            ])),
            check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
            check_body: z.optional(z.string()),
            check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
            check_passive: z.optional(z.boolean()).default(true),
            check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
            check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
            cipher_suite: z.optional(z.enum(['recommended', 'legacy'])),
            id: z.optional(z.int().readonly()),
            nodebalancer_id: z.optional(z.int().readonly()),
            nodes: z.array(z.object({
                address: z.optional(z.string()),
                config_id: z.optional(z.int().readonly()),
                id: z.optional(z.int().readonly()),
                label: z.optional(z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/)),
                mode: z.optional(z.enum([
                    'accept',
                    'reject',
                    'drain',
                    'backup'
                ])),
                nodebalancer_id: z.optional(z.int().readonly()),
                status: z.optional(z.enum([
                    'unknown',
                    'UP',
                    'DOWN'
                ])),
                subnet_id: z.optional(z.int()),
                weight: z.optional(z.int().gte(1).lte(255))
            })),
            nodes_status: z.optional(z.object({
                down: z.int().readonly(),
                up: z.int().readonly()
            }).readonly()),
            port: z.optional(z.int().gte(1).lte(65535)).default(80),
            protocol: z.optional(z.enum(['https'])),
            proxy_protocol: z.optional(z.string().readonly()).default('none'),
            ssl_cert: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            ssl_commonname: z.optional(z.string().readonly()),
            ssl_fingerprint: z.optional(z.string().readonly()),
            ssl_key: z.optional(z.union([
                z.string(),
                z.null()
            ])),
            stickiness: z.optional(z.enum([
                'none',
                'table',
                'http_cookie'
            ]))
        })
    ]), z.object({
        nodes: z.array(z.object({
            address: z.string(),
            id: z.int(),
            label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_.]{3,32}/),
            mode: z.enum([
                'accept',
                'reject',
                'drain',
                'backup'
            ]),
            subnet_id: z.int(),
            weight: z.int().gte(1).lte(255)
        }))
    })),
    path: z.object({
        nodeBalancerId: z.int(),
        configId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * NodeBalancer `config` options for each protocol.
 */
export const postRebuildNodeBalancerConfigResponseSchema = z.union([
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'ring_hash'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean().readonly()),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['udp'])),
        proxy_protocol: z.optional(z.string().readonly()),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'session',
            'source_ip'
        ])),
        udp_check_port: z.optional(z.int().gte(1).lte(65535)).default(80),
        udp_session_timeout: z.optional(z.int().gte(1).lte(300).readonly()).default(16)
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(30),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['tcp'])),
        proxy_protocol: z.optional(z.enum([
            'none',
            'v1',
            'v2'
        ])),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
        cipher_suite: z.optional(z.string().readonly()),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['http'])),
        proxy_protocol: z.optional(z.string().readonly()).default('none'),
        ssl_cert: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    }),
    z.object({
        algorithm: z.optional(z.enum([
            'roundrobin',
            'leastconn',
            'source'
        ])),
        check: z.optional(z.enum([
            'none',
            'connection',
            'http',
            'http_body'
        ])),
        check_attempts: z.optional(z.int().gte(1).lte(30)).default(3),
        check_body: z.optional(z.string()),
        check_interval: z.optional(z.int().gte(2).lte(3600)).default(5),
        check_passive: z.optional(z.boolean()).default(true),
        check_path: z.optional(z.string().regex(/^[a-zA-Z0-9\/\-%?&=.]*$/)),
        check_timeout: z.optional(z.int().gte(1).lte(30)).default(3),
        cipher_suite: z.optional(z.enum(['recommended', 'legacy'])),
        id: z.optional(z.int().readonly()),
        nodebalancer_id: z.optional(z.int().readonly()),
        nodes_status: z.optional(z.object({
            down: z.int().readonly(),
            up: z.int().readonly()
        }).readonly()),
        port: z.optional(z.int().gte(1).lte(65535)).default(80),
        protocol: z.optional(z.enum(['https'])),
        proxy_protocol: z.optional(z.string().readonly()).default('none'),
        ssl_cert: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        ssl_commonname: z.optional(z.string().readonly()),
        ssl_fingerprint: z.optional(z.string().readonly()),
        ssl_key: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        stickiness: z.optional(z.enum([
            'none',
            'table',
            'http_cookie'
        ]))
    })
]);

export const getNodeBalancerFirewallsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        nodeBalancerId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of Firewalls assigned to this NodeBalancer.
 */
export const getNodeBalancerFirewallsResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        entities: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            parent_entity: z.union([
                z.object({
                    id: z.int(),
                    label: z.string(),
                    parent_entity: z.union([
                        z.string().readonly(),
                        z.null()
                    ]).readonly(),
                    type: z.enum(['linode']),
                    url: z.string()
                }).readonly(),
                z.null()
            ]).readonly(),
            type: z.enum([
                'linode',
                'linode_interface',
                'nodebalancer'
            ]),
            url: z.string().readonly()
        })).readonly(),
        id: z.int().readonly(),
        label: z.string().min(3).max(32).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
        rules: z.object({
            fingerprint: z.string().readonly(),
            inbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            inbound_policy: z.enum(['ACCEPT', 'DROP']),
            outbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            outbound_policy: z.enum(['ACCEPT', 'DROP']),
            version: z.int().readonly()
        }),
        status: z.enum([
            'enabled',
            'disabled',
            'deleted'
        ]),
        tags: z.array(z.string()),
        updated: z.iso.datetime().readonly()
    }))
}));

export const putNodeBalancerFirewallsRequestSchema = z.object({
    body: z.object({
        firewall_ids: z.array(z.int()).min(0)
    }),
    path: z.object({
        nodeBalancerId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of Firewalls assigned to this NodeBalancer.
 */
export const putNodeBalancerFirewallsResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        entities: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            parent_entity: z.union([
                z.object({
                    id: z.int(),
                    label: z.string(),
                    parent_entity: z.union([
                        z.string().readonly(),
                        z.null()
                    ]).readonly(),
                    type: z.enum(['linode']),
                    url: z.string()
                }).readonly(),
                z.null()
            ]).readonly(),
            type: z.enum([
                'linode',
                'linode_interface',
                'nodebalancer'
            ]),
            url: z.string().readonly()
        })).readonly(),
        id: z.int().readonly(),
        label: z.string().min(3).max(32).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
        rules: z.object({
            fingerprint: z.string().readonly(),
            inbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            inbound_policy: z.enum(['ACCEPT', 'DROP']),
            outbound: z.array(z.object({
                action: z.enum(['ACCEPT', 'DROP']),
                addresses: z.object({
                    ipv4: z.array(z.string()),
                    ipv6: z.array(z.string())
                }),
                description: z.string().min(1).max(100),
                label: z.string().min(3).max(32),
                ports: z.union([
                    z.string(),
                    z.null()
                ]),
                protocol: z.enum([
                    'TCP',
                    'UDP',
                    'ICMP',
                    'IPENCAP'
                ])
            })),
            outbound_policy: z.enum(['ACCEPT', 'DROP']),
            version: z.int().readonly()
        }),
        status: z.enum([
            'enabled',
            'disabled',
            'deleted'
        ]),
        tags: z.array(z.string()),
        updated: z.iso.datetime().readonly()
    }))
}));

export const getNodeBalancerStatsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        nodeBalancerId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Stats for this NodeBalancer.
 */
export const getNodeBalancerStatsResponseSchema = z.object({
    data: z.object({
        connections: z.array(z.number()),
        traffic: z.object({
            in: z.array(z.number()),
            out: z.array(z.number())
        })
    }),
    title: z.string()
});

export const getNodeBalancerVpcsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        nodeBalancerId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of NodeBalancer VPC configurations.
 */
export const getNodeBalancerVpcsResponseSchema = z.object({
    data: z.array(z.object({
        id: z.optional(z.int().readonly()),
        ipv4_range: z.optional(z.string()),
        ipv4_range_auto_assign: z.optional(z.union([
            z.boolean().default(false),
            z.null()
        ])).default(false),
        nodebalancer_id: z.optional(z.int().readonly()),
        subnet_id: z.int(),
        vpc_id: z.optional(z.union([
            z.int().readonly(),
            z.null()
        ]).readonly())
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getNodeBalancerVpcConfigRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        nodeBalancerId: z.int(),
        nodeBalancerVpcConfigId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * You can have only one VPC in a NodeBalancer configuration. If any of your backend nodes are VPC Linodes, specify the VPC subnet and CIDR range. NodeBalancer routes traffic to backend VPC nodes through this subnet. Once the NodeBalancer is created, its VPC cannot be changed.
 */
export const getNodeBalancerVpcConfigResponseSchema = z.object({
    id: z.optional(z.int().readonly()),
    ipv4_range: z.optional(z.string()),
    ipv4_range_auto_assign: z.optional(z.union([
        z.boolean().default(false),
        z.null()
    ])).default(false),
    nodebalancer_id: z.optional(z.int().readonly()),
    subnet_id: z.int(),
    vpc_id: z.optional(z.union([
        z.int().readonly(),
        z.null()
    ]).readonly())
});

export const getObjectStorageBucketsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A paginated list of buckets you own.
 */
export const getObjectStorageBucketsResponseSchema = z.object({
    data: z.array(z.object({
        cluster: z.string(),
        created: z.iso.datetime(),
        endpoint_type: z.enum([
            'E0',
            'E1',
            'E2',
            'E3'
        ]),
        hostname: z.string(),
        label: z.string(),
        objects: z.int(),
        region: z.string(),
        s3_endpoint: z.string(),
        size: z.int()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postObjectStorageBucketRequestSchema = z.object({
    body: z.optional(z.object({
        acl: z.optional(z.enum([
            'private',
            'public-read',
            'authenticated-read',
            'public-read-write'
        ])),
        cors_enabled: z.optional(z.boolean()),
        endpoint_type: z.optional(z.enum([
            'E0',
            'E1',
            'E2',
            'E3'
        ])),
        label: z.string().regex(/^(?=.{3,63}$)[a-z0-9]+(?:-[a-z0-9]+)*(?:[.][a-z0-9]+(?:-[a-z0-9]+)*)*$/),
        region: z.optional(z.string()),
        s3_endpoint: z.optional(z.string())
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * An Object Storage bucket.
 */
export const postObjectStorageBucketResponseSchema = z.object({
    cluster: z.string(),
    created: z.iso.datetime(),
    endpoint_type: z.enum([
        'E0',
        'E1',
        'E2',
        'E3'
    ]),
    hostname: z.string(),
    label: z.string(),
    objects: z.int(),
    region: z.string(),
    s3_endpoint: z.string(),
    size: z.int()
});

export const getObjectStorageBucketinClusterRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        regionId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * A paginated list of buckets on your account in this region.
 */
export const getObjectStorageBucketinClusterResponseSchema = z.object({
    data: z.array(z.object({
        cluster: z.string(),
        created: z.iso.datetime(),
        endpoint_type: z.enum([
            'E0',
            'E1',
            'E2',
            'E3'
        ]),
        hostname: z.string(),
        label: z.string(),
        objects: z.int(),
        region: z.string(),
        s3_endpoint: z.string(),
        size: z.int()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const deleteObjectStorageBucketRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        regionId: z.string(),
        bucket: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteObjectStorageBucketResponseSchema = z.record(z.string(), z.unknown());

export const getObjectStorageBucketRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        regionId: z.string(),
        bucket: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * An Object Storage bucket.
 */
export const getObjectStorageBucketResponseSchema = z.object({
    cluster: z.string(),
    created: z.iso.datetime(),
    endpoint_type: z.enum([
        'E0',
        'E1',
        'E2',
        'E3'
    ]),
    hostname: z.string(),
    label: z.string(),
    objects: z.int(),
    region: z.string(),
    s3_endpoint: z.string(),
    size: z.int()
});

export const getObjectStorageBucketAccessRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        regionId: z.string(),
        bucket: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Access settings for the specific bucket.
 */
export const getObjectStorageBucketAccessResponseSchema = z.object({
    acl: z.enum([
        'private',
        'public-read',
        'authenticated-read',
        'public-read-write',
        'custom'
    ]),
    acl_xml: z.string(),
    cors_enabled: z.union([
        z.boolean(),
        z.null()
    ]),
    cors_xml: z.union([
        z.string(),
        z.null()
    ])
});

export const postObjectStorageBucketAccessRequestSchema = z.object({
    body: z.optional(z.object({
        acl: z.enum([
            'private',
            'public-read',
            'authenticated-read',
            'public-read-write',
            'custom'
        ]),
        cors_enabled: z.boolean()
    })),
    path: z.object({
        regionId: z.string(),
        bucket: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postObjectStorageBucketAccessResponseSchema = z.record(z.string(), z.unknown());

export const putStorageBucketAccessRequestSchema = z.object({
    body: z.optional(z.object({
        acl: z.enum([
            'private',
            'public-read',
            'authenticated-read',
            'public-read-write',
            'custom'
        ]),
        cors_enabled: z.boolean()
    })),
    path: z.object({
        regionId: z.string(),
        bucket: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const putStorageBucketAccessResponseSchema = z.record(z.string(), z.unknown());

export const getObjectStorageBucketAclRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        regionId: z.string(),
        bucket: z.string()
    }),
    query: z.object({
        name: z.string()
    })
});

/**
 * The Object's canned ACL and policy.
 */
export const getObjectStorageBucketAclResponseSchema = z.object({
    acl: z.enum([
        'private',
        'public-read',
        'authenticated-read',
        'public-read-write',
        'custom'
    ]),
    acl_xml: z.string()
});

export const putObjectStorageBucketAclRequestSchema = z.object({
    body: z.optional(z.object({
        acl: z.enum([
            'private',
            'public-read',
            'authenticated-read',
            'public-read-write',
            'custom'
        ]),
        name: z.string()
    })),
    path: z.object({
        regionId: z.string(),
        bucket: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const putObjectStorageBucketAclResponseSchema = z.record(z.string(), z.unknown());

export const getObjectStorageBucketContentRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        regionId: z.string(),
        bucket: z.string()
    }),
    query: z.optional(z.object({
        marker: z.optional(z.string()),
        delimiter: z.optional(z.string()),
        prefix: z.optional(z.string()),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * One page of the requested bucket's contents.
 */
export const getObjectStorageBucketContentResponseSchema = z.object({
    data: z.array(z.object({
        etag: z.string(),
        last_modified: z.iso.datetime(),
        name: z.string(),
        owner: z.string(),
        size: z.int()
    })),
    is_truncated: z.boolean(),
    next_marker: z.union([
        z.string(),
        z.null()
    ])
});

export const postObjectStorageObjectUrlRequestSchema = z.object({
    body: z.optional(z.object({
        content_type: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        expires_in: z.optional(z.union([
            z.int().gte(360).lte(86400).default(3600),
            z.null()
        ])).default(3600),
        method: z.string().default('GET'),
        name: z.string()
    })),
    path: z.object({
        regionId: z.string(),
        bucket: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The URL with which to access your object.
 */
export const postObjectStorageObjectUrlResponseSchema = z.object({
    url: z.string()
});

export const deleteObjectStorageSslRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        regionId: z.string(),
        bucket: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteObjectStorageSslResponseSchema = z.record(z.string(), z.unknown());

export const getObjectStorageSslRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        regionId: z.string(),
        bucket: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * If this Object Storage bucket has a corresponding TLS/SSL Certificate.
 */
export const getObjectStorageSslResponseSchema = z.object({
    ssl: z.boolean().readonly()
});

export const postObjectStorageSslRequestSchema = z.object({
    body: z.optional(z.object({
        certificate: z.string(),
        private_key: z.string()
    })),
    path: z.object({
        regionId: z.string(),
        bucket: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * If this Object Storage bucket has a corresponding TLS/SSL Certificate.
 */
export const postObjectStorageSslResponseSchema = z.object({
    ssl: z.boolean().readonly()
});

export const postCancelObjectStorageRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postCancelObjectStorageResponseSchema = z.record(z.string(), z.unknown());

export const getObjectStorageClustersRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A paginated list of available clusters.
 */
export const getObjectStorageClustersResponseSchema = z.object({
    data: z.array(z.object({
        domain: z.string(),
        id: z.string(),
        region: z.string(),
        static_site_domain: z.string(),
        status: z.enum(['available', 'unavailable'])
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getObjectStorageClusterRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        clusterId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * An Object Storage Cluster.
 */
export const getObjectStorageClusterResponseSchema = z.object({
    domain: z.string(),
    id: z.string(),
    region: z.string(),
    static_site_domain: z.string(),
    status: z.enum(['available', 'unavailable'])
});

export const getObjectStorageEndpointsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A paginated list of endpoints you can access.
 */
export const getObjectStorageEndpointsResponseSchema = z.object({
    data: z.array(z.object({
        endpoint_type: z.enum([
            'E0',
            'E1',
            'E2',
            'E3'
        ]),
        region: z.string(),
        s3_endpoint: z.union([
            z.string(),
            z.null()
        ])
    }))
}).and(z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}));

export const getObjectStorageKeysRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A paginated list of Object Storage Keys.
 */
export const getObjectStorageKeysResponseSchema = z.object({
    data: z.array(z.object({
        access_key: z.string(),
        bucket_access: z.array(z.object({
            bucket_name: z.string(),
            cluster: z.string(),
            permissions: z.enum(['read_write', 'read_only']),
            region: z.string()
        })),
        id: z.int(),
        label: z.string(),
        limited: z.boolean(),
        regions: z.array(z.object({
            endpoint_type: z.enum([
                'E0',
                'E1',
                'E2',
                'E3'
            ]),
            id: z.string(),
            s3_endpoint: z.string()
        })),
        secret_key: z.string()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postObjectStorageKeysRequestSchema = z.object({
    body: z.optional(z.union([
        z.object({
            bucket_access: z.array(z.union([z.object({
                    bucket_name: z.string(),
                    permissions: z.enum(['read_write', 'read_only']),
                    region: z.string()
                }), z.object({
                    bucket_name: z.string(),
                    cluster: z.string(),
                    permissions: z.enum(['read_write', 'read_only'])
                })])),
            label: z.string()
        }),
        z.object({
            label: z.string(),
            regions: z.array(z.string())
        })
    ])),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The settings necessary to create a new Object Storage access key.
 */
export const postObjectStorageKeysResponseSchema = z.object({
    access_key: z.string().readonly(),
    bucket_access: z.array(z.object({
        bucket_name: z.string(),
        cluster: z.string(),
        permissions: z.enum(['read_write', 'read_only']),
        region: z.string()
    })),
    id: z.int().readonly(),
    label: z.string(),
    limited: z.boolean().readonly(),
    regions: z.array(z.object({
        endpoint_type: z.enum([
            'E0',
            'E1',
            'E2',
            'E3'
        ]),
        id: z.string(),
        s3_endpoint: z.string()
    })),
    secret_key: z.string().readonly()
});

export const deleteObjectStorageKeyRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        keyId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteObjectStorageKeyResponseSchema = z.record(z.string(), z.unknown());

export const getObjectStorageKeyRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        keyId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A key used to validate requests to an S3 API.
 */
export const getObjectStorageKeyResponseSchema = z.object({
    access_key: z.string(),
    bucket_access: z.array(z.object({
        bucket_name: z.string(),
        cluster: z.string(),
        permissions: z.enum(['read_write', 'read_only']),
        region: z.string()
    })),
    id: z.int(),
    label: z.string(),
    limited: z.boolean(),
    regions: z.array(z.object({
        endpoint_type: z.enum([
            'E0',
            'E1',
            'E2',
            'E3'
        ]),
        id: z.string(),
        s3_endpoint: z.string()
    })),
    secret_key: z.string()
});

export const putObjectStorageKeyRequestSchema = z.object({
    body: z.optional(z.object({
        label: z.string(),
        regions: z.array(z.string())
    })),
    path: z.object({
        keyId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * An updated Object Storage key used for authentication.
 */
export const putObjectStorageKeyResponseSchema = z.object({
    access_key: z.string(),
    id: z.int(),
    label: z.string(),
    limited: z.boolean(),
    regions: z.array(z.object({
        endpoint_type: z.enum([
            'E0',
            'E1',
            'E2',
            'E3'
        ]),
        id: z.string(),
        s3_endpoint: z.string()
    })),
    secret_key: z.string()
});

export const getObjectStorageQuotasRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A paginated list of Object Storage-related quotas applied to your account.
 */
export const getObjectStorageQuotasResponseSchema = z.object({
    data: z.array(z.object({
        description: z.string(),
        endpoint_type: z.enum([
            'E0',
            'E1',
            'E2',
            'E3'
        ]),
        quota_id: z.string(),
        quota_limit: z.int(),
        quota_name: z.enum([
            'Number of Objects',
            'Number of Buckets',
            'Total Capacity'
        ]),
        resource_metric: z.enum([
            'bucket',
            'object',
            'byte'
        ]),
        s3_endpoint: z.string()
    }))
}).and(z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}));

export const getObjectStorageQuotaRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        objQuotaId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The current Object Storage-related quotas on your account.
 */
export const getObjectStorageQuotaResponseSchema = z.object({
    description: z.string(),
    endpoint_type: z.enum([
        'E0',
        'E1',
        'E2',
        'E3'
    ]),
    quota_id: z.string(),
    quota_limit: z.int(),
    quota_name: z.enum([
        'Number of Objects',
        'Number of Buckets',
        'Total Capacity'
    ]),
    resource_metric: z.enum([
        'bucket',
        'object',
        'byte'
    ]),
    s3_endpoint: z.string()
});

export const getObjectStorageQuotaUsageRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        objQuotaId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * Usage data for a specific Object Storage-related quota on your account.
 */
export const getObjectStorageQuotaUsageResponseSchema = z.object({
    quota_limit: z.int(),
    usage: z.union([
        z.int(),
        z.null()
    ])
});

export const getObjectStorageTransferRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Returns the amount of outbound data transfer used by your account's Object Storage buckets.
 */
export const getObjectStorageTransferResponseSchema = z.object({
    used: z.int().readonly()
});

export const getObjectStorageTypesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A collection of Object Storage types.
 */
export const getObjectStorageTypesResponseSchema = z.object({
    data: z.array(z.object({
        id: z.string().readonly(),
        label: z.string().readonly(),
        price: z.object({
            hourly: z.number(),
            monthly: z.number()
        }).readonly(),
        region_prices: z.array(z.object({
            hourly: z.number(),
            id: z.string(),
            monthly: z.number()
        })),
        transfer: z.int().gte(0).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getPlacementGroupsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns an array of all placement groups on your Account.
 */
export const getPlacementGroupsResponseSchema = z.object({
    data: z.array(z.object({
        id: z.int(),
        is_compliant: z.boolean(),
        label: z.string().min(1),
        members: z.array(z.object({
            is_compliant: z.boolean(),
            linode_id: z.int().readonly()
        })),
        migrations: z.union([
            z.object({
                inbound: z.array(z.object({
                    linode_id: z.int().readonly()
                })),
                outbound: z.array(z.object({
                    linode_id: z.int().readonly()
                }))
            }),
            z.null()
        ]),
        placement_group_policy: z.enum(['strict', 'flexible']),
        placement_group_type: z.enum(['anti_affinity:local']),
        region: z.string().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postPlacementGroupRequestSchema = z.object({
    body: z.object({
        label: z.string().min(1),
        placement_group_policy: z.enum(['strict', 'flexible']),
        placement_group_type: z.enum(['anti_affinity:local']),
        region: z.string()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A new placement group is being created.
 */
export const postPlacementGroupResponseSchema = z.object({
    id: z.int(),
    is_compliant: z.boolean(),
    label: z.string().min(1),
    members: z.array(z.object({
        is_compliant: z.boolean(),
        linode_id: z.int().readonly()
    })),
    placement_group_policy: z.enum(['strict', 'flexible']),
    placement_group_type: z.enum(['anti_affinity:local']),
    region: z.string().readonly()
});

export const deletePlacementGroupRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        groupId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deletePlacementGroupResponseSchema = z.record(z.string(), z.unknown());

export const getPlacementGroupRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        groupId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Returns a single placement group object.
 */
export const getPlacementGroupResponseSchema = z.object({
    id: z.int(),
    is_compliant: z.boolean(),
    label: z.string().min(1),
    members: z.array(z.object({
        is_compliant: z.boolean(),
        linode_id: z.int().readonly()
    })),
    migrations: z.union([
        z.object({
            inbound: z.array(z.object({
                linode_id: z.int().readonly()
            })),
            outbound: z.array(z.object({
                linode_id: z.int().readonly()
            }))
        }),
        z.null()
    ]),
    placement_group_policy: z.enum(['strict', 'flexible']),
    placement_group_type: z.enum(['anti_affinity:local']),
    region: z.string().readonly()
});

export const putPlacementGroupRequestSchema = z.object({
    body: z.object({
        label: z.string().min(1)
    }),
    path: z.object({
        groupId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The updated placement group.
 */
export const putPlacementGroupResponseSchema = z.object({
    id: z.int(),
    is_compliant: z.boolean(),
    label: z.string().min(1),
    members: z.array(z.object({
        is_compliant: z.boolean(),
        linode_id: z.int().readonly()
    })),
    placement_group_policy: z.enum(['strict', 'flexible']),
    placement_group_type: z.enum(['anti_affinity:local']),
    region: z.string().readonly()
});

export const postGroupAddLinodeRequestSchema = z.object({
    body: z.object({
        linodes: z.array(z.int())
    }),
    path: z.object({
        groupId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The Linode was added successfully.
 */
export const postGroupAddLinodeResponseSchema = z.object({
    id: z.int(),
    is_compliant: z.boolean(),
    label: z.string().min(1),
    members: z.array(z.object({
        is_compliant: z.boolean(),
        linode_id: z.int().readonly()
    })),
    placement_group_policy: z.enum(['strict', 'flexible']),
    placement_group_type: z.enum(['anti_affinity:local']),
    region: z.string().readonly()
});

export const postGroupUnassignRequestSchema = z.object({
    body: z.object({
        linodes: z.array(z.int())
    }),
    path: z.object({
        groupId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The Linode was removed successfully.
 */
export const postGroupUnassignResponseSchema = z.object({
    id: z.int(),
    is_compliant: z.boolean(),
    label: z.string().min(1),
    members: z.array(z.object({
        is_compliant: z.boolean(),
        linode_id: z.int().readonly()
    })),
    placement_group_policy: z.enum(['strict', 'flexible']),
    placement_group_type: z.enum(['anti_affinity:local']),
    region: z.string().readonly()
});

export const getProfileRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A profile represents your user in our system. This is where you can change information about your user. This information is available to any OAuth client regardless of requested scopes, and you can use it to populate user information in third-party applications.
 */
export const getProfileResponseSchema = z.object({
    authentication_type: z.enum(['password', 'github']),
    authorized_keys: z.union([
        z.array(z.string()),
        z.null()
    ]),
    email: z.email(),
    email_notifications: z.boolean(),
    ip_whitelist_enabled: z.boolean(),
    lish_auth_method: z.enum([
        'password_keys',
        'keys_only',
        'disabled'
    ]),
    referrals: z.object({
        code: z.string().readonly(),
        completed: z.int().readonly(),
        credit: z.int().readonly(),
        pending: z.int().readonly(),
        total: z.int().readonly(),
        url: z.string().readonly()
    }).readonly(),
    restricted: z.boolean(),
    timezone: z.string(),
    two_factor_auth: z.boolean(),
    uid: z.int().readonly(),
    username: z.string().readonly(),
    verified_phone_number: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const putProfileRequestSchema = z.object({
    body: z.object({
        authentication_type: z.enum(['password', 'github']),
        authorized_keys: z.union([
            z.array(z.string()),
            z.null()
        ]),
        email: z.email(),
        email_notifications: z.boolean(),
        ip_whitelist_enabled: z.boolean(),
        lish_auth_method: z.enum([
            'password_keys',
            'keys_only',
            'disabled'
        ]),
        referrals: z.object({
            code: z.string().readonly(),
            completed: z.int().readonly(),
            credit: z.int().readonly(),
            pending: z.int().readonly(),
            total: z.int().readonly(),
            url: z.string().readonly()
        }).readonly(),
        restricted: z.boolean(),
        timezone: z.string(),
        two_factor_auth: z.boolean(),
        uid: z.int().readonly(),
        username: z.string().readonly(),
        verified_phone_number: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A profile represents your user in our system. This is where you can change information about your user. This information is available to any OAuth client regardless of requested scopes, and you can use it to populate user information in third-party applications.
 */
export const putProfileResponseSchema = z.object({
    authentication_type: z.enum(['password', 'github']),
    authorized_keys: z.union([
        z.array(z.string()),
        z.null()
    ]),
    email: z.email(),
    email_notifications: z.boolean(),
    ip_whitelist_enabled: z.boolean(),
    lish_auth_method: z.enum([
        'password_keys',
        'keys_only',
        'disabled'
    ]),
    referrals: z.object({
        code: z.string().readonly(),
        completed: z.int().readonly(),
        credit: z.int().readonly(),
        pending: z.int().readonly(),
        total: z.int().readonly(),
        url: z.string().readonly()
    }).readonly(),
    restricted: z.boolean(),
    timezone: z.string(),
    two_factor_auth: z.boolean(),
    uid: z.int().readonly(),
    username: z.string().readonly(),
    verified_phone_number: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const getProfileAppsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of apps you've authorized.
 */
export const getProfileAppsResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        expiry: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        id: z.int().readonly(),
        label: z.string().readonly(),
        scopes: z.string().readonly(),
        thumbnail_url: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        website: z.string().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const deleteProfileAppRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        appId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteProfileAppResponseSchema = z.record(z.string(), z.unknown());

export const getProfileAppRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        appId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * An application you have authorized access to your Account through OAuth.
 */
export const getProfileAppResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    expiry: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    id: z.int().readonly(),
    label: z.string().readonly(),
    scopes: z.string().readonly(),
    thumbnail_url: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    website: z.string().readonly()
});

export const getDevicesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Returns a paginated list of TrustedDevice objects.
 */
export const getDevicesResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        expiry: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        last_authenticated: z.iso.datetime().readonly(),
        last_remote_addr: z.string().readonly(),
        user_agent: z.string().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const deleteTrustedDeviceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        deviceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteTrustedDeviceResponseSchema = z.record(z.string(), z.unknown());

export const getTrustedDeviceRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        deviceId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A trusted device object represents an active Remember Me session with [login.linode.com](https://login.linode.com).
 */
export const getTrustedDeviceResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    expiry: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    last_authenticated: z.iso.datetime().readonly(),
    last_remote_addr: z.string().readonly(),
    user_agent: z.string().readonly()
});

export const getProfileGrantsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

export const getProfileGrantsResponseSchema = z.union([
    z.object({
        database: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        domain: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        firewall: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        global: z.object({
            account_access: z.enum(['read_only', 'read_write']),
            add_databases: z.boolean(),
            add_domains: z.boolean(),
            add_firewalls: z.boolean(),
            add_images: z.boolean(),
            add_linodes: z.boolean(),
            add_longview: z.boolean(),
            add_nodebalancers: z.boolean(),
            add_stackscripts: z.boolean(),
            add_volumes: z.boolean(),
            add_vpcs: z.boolean(),
            cancel_account: z.boolean(),
            child_account_access: z.union([
                z.boolean(),
                z.null()
            ]),
            longview_subscription: z.boolean()
        }),
        image: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        linode: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        longview: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        nodebalancer: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        stackscript: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        volume: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        })),
        vpc: z.array(z.object({
            id: z.int(),
            label: z.string().readonly(),
            permissions: z.enum(['read_only', 'read_write'])
        }))
    }),
    z.void()
]);

export const getProfileLoginsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * An array of successful account logins from this user during the last 90 days.
 */
export const getProfileLoginsResponseSchema = z.object({
    data: z.array(z.object({
        datetime: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        ip: z.string().readonly(),
        restricted: z.boolean().readonly(),
        status: z.enum(['successful', 'failed']),
        username: z.string().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getProfileLoginRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        loginId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * An object representing a previous successful login for a User.
 */
export const getProfileLoginResponseSchema = z.object({
    datetime: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    ip: z.string().readonly(),
    restricted: z.boolean().readonly(),
    status: z.enum(['successful', 'failed']),
    username: z.string().readonly()
});

export const deleteProfilePhoneNumberRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteProfilePhoneNumberResponseSchema = z.record(z.string(), z.unknown());

export const postProfilePhoneNumberRequestSchema = z.object({
    body: z.optional(z.object({
        iso_code: z.string(),
        phone_number: z.string()
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postProfilePhoneNumberResponseSchema = z.record(z.string(), z.unknown());

export const postProfilePhoneNumberVerifyRequestSchema = z.object({
    body: z.optional(z.object({
        otp_code: z.string()
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postProfilePhoneNumberVerifyResponseSchema = z.record(z.string(), z.unknown());

export const getUserPreferencesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A dictionary of user preferences.
 */
export const getUserPreferencesResponseSchema = z.record(z.string(), z.unknown());

export const putUserPreferencesRequestSchema = z.object({
    body: z.record(z.string(), z.unknown()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * An object of user preferences.
 */
export const putUserPreferencesResponseSchema = z.record(z.string(), z.unknown());

export const getSecurityQuestionsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Security questions and responses object for GET operation.
 */
export const getSecurityQuestionsResponseSchema = z.object({
    security_questions: z.array(z.object({
        id: z.int(),
        question: z.string().readonly(),
        response: z.string().min(3).max(17)
    }))
});

export const postSecurityQuestionsRequestSchema = z.object({
    body: z.optional(z.object({
        security_questions: z.array(z.object({
            question_id: z.int(),
            response: z.string().min(3).max(17),
            security_question: z.string().readonly()
        }))
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Security questions and responses object for POST operation.
 */
export const postSecurityQuestionsResponseSchema = z.object({
    security_questions: z.array(z.object({
        question_id: z.int(),
        response: z.string().min(3).max(17),
        security_question: z.string().readonly()
    }))
});

export const getSshKeysRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of SSH Key objects.
 */
export const getSshKeysResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        label: z.string().min(0).max(64),
        ssh_key: z.string()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postAddSshKeyRequestSchema = z.object({
    body: z.optional(z.object({
        created: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        label: z.string().min(0).max(64),
        ssh_key: z.string()
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A credential object for authenticating a User's secure shell connection to a Linode.
 */
export const postAddSshKeyResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    label: z.string().min(0).max(64),
    ssh_key: z.string()
});

export const deleteSshKeyRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        sshKeyId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteSshKeyResponseSchema = z.record(z.string(), z.unknown());

export const getSshKeyRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        sshKeyId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A credential object for authenticating a User's secure shell connection to a Linode.
 */
export const getSshKeyResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    label: z.string().min(0).max(64),
    ssh_key: z.string()
});

export const putSshKeyRequestSchema = z.object({
    body: z.object({
        label: z.string().min(0).max(64)
    }),
    path: z.object({
        sshKeyId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A credential object for authenticating a User's secure shell connection to a Linode.
 */
export const putSshKeyResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    label: z.string().min(0).max(64),
    ssh_key: z.string()
});

export const postTfaDisableRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postTfaDisableResponseSchema = z.record(z.string(), z.unknown());

export const postTfaEnableRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Secret key generated.
 */
export const postTfaEnableResponseSchema = z.object({
    expiry: z.iso.datetime(),
    secret: z.string()
});

export const postTfaConfirmRequestSchema = z.object({
    body: z.object({
        tfa_code: z.string()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * TFA enabled successfully.
 */
export const postTfaConfirmResponseSchema = z.object({
    scratch: z.string()
});

export const getPersonalAccessTokensRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A paginated list of active tokens.
 */
export const getPersonalAccessTokensResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        expiry: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        label: z.string().min(1).max(100),
        scopes: z.string().readonly(),
        token: z.string().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postPersonalAccessTokenRequestSchema = z.object({
    body: z.object({
        expiry: z.union([
            z.iso.datetime(),
            z.null()
        ]),
        label: z.string().min(1).max(100),
        scopes: z.string()
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A Personal Access Token is a token generated manually to access the API without going through an OAuth login.  Personal Access Tokens can have scopes just like OAuth tokens do, and are commonly used to give access to command-line tools like the Linode CLI, or when writing your own integrations.
 */
export const postPersonalAccessTokenResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    expiry: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    label: z.string().min(1).max(100),
    scopes: z.string().readonly(),
    token: z.string().readonly()
});

export const deletePersonalAccessTokenRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tokenId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deletePersonalAccessTokenResponseSchema = z.record(z.string(), z.unknown());

export const getPersonalAccessTokenRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tokenId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A Personal Access Token is a token generated manually to access the API without going through an OAuth login.  Personal Access Tokens can have scopes just like OAuth tokens do, and are commonly used to give access to command-line tools like the Linode CLI, or when writing your own integrations.
 */
export const getPersonalAccessTokenResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    expiry: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    label: z.string().min(1).max(100),
    scopes: z.string().readonly(),
    token: z.string().readonly()
});

export const putPersonalAccessTokenRequestSchema = z.object({
    body: z.object({
        created: z.iso.datetime().readonly(),
        expiry: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        label: z.string().min(1).max(100),
        scopes: z.string().readonly(),
        token: z.string().readonly()
    }),
    path: z.object({
        tokenId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A Personal Access Token is a token generated manually to access the API without going through an OAuth login.  Personal Access Tokens can have scopes just like OAuth tokens do, and are commonly used to give access to command-line tools like the Linode CLI, or when writing your own integrations.
 */
export const putPersonalAccessTokenResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    expiry: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    label: z.string().min(1).max(100),
    scopes: z.string().readonly(),
    token: z.string().readonly()
});

export const getRegionsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Returns an array of regions.
 */
export const getRegionsResponseSchema = z.object({
    data: z.array(z.object({
        capabilities: z.array(z.string()),
        country: z.string(),
        id: z.string(),
        label: z.string(),
        monitors: z.object({
            alerts: z.array(z.string()),
            metrics: z.array(z.string())
        }),
        placement_group_limits: z.object({
            maximum_linodes_per_flexible_pg: z.union([
                z.int(),
                z.null()
            ]),
            maximum_linodes_per_pg: z.union([
                z.int(),
                z.null()
            ]),
            maximum_pgs_per_customer: z.union([
                z.int(),
                z.null()
            ])
        }),
        resolvers: z.object({
            ipv4: z.string(),
            ipv6: z.string()
        }),
        site_type: z.enum(['core', 'distributed']),
        status: z.enum(['ok', 'outage'])
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getRegionsAvailabilityRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Returns a Region Availability object.
 */
export const getRegionsAvailabilityResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.optional(z.array(z.object({
        available: z.boolean(),
        plan: z.string(),
        region: z.string()
    })))
}));

export const getRegionRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        regionId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * An area where Linode services are available.
 */
export const getRegionResponseSchema = z.object({
    capabilities: z.array(z.string()),
    country: z.string(),
    id: z.string(),
    label: z.string(),
    monitors: z.object({
        alerts: z.array(z.string()),
        metrics: z.array(z.string())
    }),
    placement_group_limits: z.object({
        maximum_linodes_per_flexible_pg: z.union([
            z.int(),
            z.null()
        ]),
        maximum_linodes_per_pg: z.union([
            z.int(),
            z.null()
        ]),
        maximum_pgs_per_customer: z.union([
            z.int(),
            z.null()
        ])
    }),
    resolvers: z.object({
        ipv4: z.string(),
        ipv6: z.string()
    }),
    site_type: z.enum(['core', 'distributed']),
    status: z.enum(['ok', 'outage'])
});

export const getRegionAvailabilityRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        regionId: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The availability data for a single Region.
 */
export const getRegionAvailabilityResponseSchema = z.array(z.object({
    available: z.boolean(),
    plan: z.string(),
    region: z.string()
}));

export const getTicketsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of support tickets.
 */
export const getTicketsResponseSchema = z.object({
    data: z.array(z.object({
        attachments: z.array(z.string()).readonly(),
        closable: z.boolean(),
        closed: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly(),
        description: z.string().min(1).max(65000).readonly(),
        entity: z.union([
            z.object({
                id: z.int().readonly(),
                label: z.string().readonly(),
                type: z.enum([
                    'database',
                    'domain',
                    'firewall',
                    'linode',
                    'lkecluster',
                    'managed_service',
                    'nodebalancer',
                    'vlan',
                    'volume',
                    'vpc'
                ]),
                url: z.string().readonly()
            }).readonly(),
            z.null()
        ]).readonly(),
        gravatar_id: z.string().readonly(),
        id: z.int().readonly(),
        opened: z.iso.datetime().readonly(),
        opened_by: z.string().readonly(),
        severity: z.enum([
            'low',
            'moderate',
            'major'
        ]),
        status: z.enum([
            'closed',
            'new',
            'open'
        ]),
        summary: z.string().min(1).max(64).readonly(),
        updated: z.iso.datetime().readonly(),
        updated_by: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postTicketRequestSchema = z.object({
    body: z.optional(z.object({
        bucket: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        database_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        description: z.string().min(1).max(65000),
        domain_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        firewall_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        linode_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        lkecluster_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        longviewclient_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        managed_issue: z.optional(z.boolean()).default(false),
        nodebalancer_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        region: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        severity: z.optional(z.union([
            z.literal(1),
            z.literal(2),
            z.literal(3)
        ])),
        summary: z.string().min(1).max(64),
        vlan: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        volume_id: z.optional(z.union([
            z.int(),
            z.null()
        ])),
        vpc_id: z.optional(z.union([
            z.int(),
            z.null()
        ]))
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A support ticket opened from your account.
 */
export const postTicketResponseSchema = z.object({
    attachments: z.array(z.string()).readonly(),
    closable: z.boolean(),
    closed: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    description: z.string().min(1).max(65000).readonly(),
    entity: z.union([
        z.object({
            id: z.int().readonly(),
            label: z.string().readonly(),
            type: z.enum([
                'database',
                'domain',
                'firewall',
                'linode',
                'lkecluster',
                'managed_service',
                'nodebalancer',
                'vlan',
                'volume',
                'vpc'
            ]),
            url: z.string().readonly()
        }).readonly(),
        z.null()
    ]).readonly(),
    gravatar_id: z.string().readonly(),
    id: z.int().readonly(),
    opened: z.iso.datetime().readonly(),
    opened_by: z.string().readonly(),
    severity: z.enum([
        'low',
        'moderate',
        'major'
    ]),
    status: z.enum([
        'closed',
        'new',
        'open'
    ]),
    summary: z.string().min(1).max(64).readonly(),
    updated: z.iso.datetime().readonly(),
    updated_by: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const getTicketRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        ticketId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * A support ticket opened from your account.
 */
export const getTicketResponseSchema = z.object({
    attachments: z.array(z.string()).readonly(),
    closable: z.boolean(),
    closed: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly(),
    description: z.string().min(1).max(65000).readonly(),
    entity: z.union([
        z.object({
            id: z.int().readonly(),
            label: z.string().readonly(),
            type: z.enum([
                'database',
                'domain',
                'firewall',
                'linode',
                'lkecluster',
                'managed_service',
                'nodebalancer',
                'vlan',
                'volume',
                'vpc'
            ]),
            url: z.string().readonly()
        }).readonly(),
        z.null()
    ]).readonly(),
    gravatar_id: z.string().readonly(),
    id: z.int().readonly(),
    opened: z.iso.datetime().readonly(),
    opened_by: z.string().readonly(),
    severity: z.enum([
        'low',
        'moderate',
        'major'
    ]),
    status: z.enum([
        'closed',
        'new',
        'open'
    ]),
    summary: z.string().min(1).max(64).readonly(),
    updated: z.iso.datetime().readonly(),
    updated_by: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly()
});

export const postTicketAttachmentRequestSchema = z.object({
    body: z.object({
        file: z.string()
    }),
    path: z.object({
        ticketId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postTicketAttachmentResponseSchema = z.record(z.string(), z.unknown());

export const postCloseTicketRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        ticketId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postCloseTicketResponseSchema = z.record(z.string(), z.unknown());

export const getTicketRepliesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        ticketId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Returns a paginated list of support ticket replies.
 */
export const getTicketRepliesResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        created_by: z.string().readonly(),
        description: z.string().readonly(),
        from_linode: z.boolean().readonly(),
        gravatar_id: z.string().readonly(),
        id: z.int().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postTicketReplyRequestSchema = z.object({
    body: z.object({
        description: z.string().min(1).max(65535)
    }),
    path: z.object({
        ticketId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * An object representing a reply to a support ticket.
 */
export const postTicketReplyResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    created_by: z.string().readonly(),
    description: z.string().readonly(),
    from_linode: z.boolean().readonly(),
    gravatar_id: z.string().readonly(),
    id: z.int().readonly()
});

export const getTagsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of tags.
 */
export const getTagsResponseSchema = z.object({
    data: z.array(z.object({
        label: z.string()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postTagRequestSchema = z.object({
    body: z.optional(z.object({
        domains: z.optional(z.array(z.int())),
        label: z.string().min(3).max(50),
        linodes: z.optional(z.array(z.int())),
        nodebalancers: z.optional(z.array(z.int())),
        volumes: z.optional(z.array(z.int()))
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A tag you've created to apply to objects on your account. Tags are for organizational purposes only.
 */
export const postTagResponseSchema = z.object({
    label: z.string()
});

export const deleteTagRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tagLabel: z.string()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteTagResponseSchema = z.record(z.string(), z.unknown());

export const getTaggedObjectsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        tagLabel: z.string()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of objects, organized by type, that have been tagged with the requested tag.
 */
export const getTaggedObjectsResponseSchema = z.object({
    data: z.array(z.object({
        data: z.union([
            z.object({
                alerts: z.object({
                    cpu: z.int(),
                    io: z.int(),
                    network_in: z.int(),
                    network_out: z.int(),
                    transfer_quota: z.int()
                }),
                backups: z.object({
                    available: z.boolean().readonly(),
                    enabled: z.boolean().readonly(),
                    last_successful: z.iso.datetime().readonly(),
                    schedule: z.object({
                        day: z.enum([
                            'Scheduling',
                            'Sunday',
                            'Monday',
                            'Tuesday',
                            'Wednesday',
                            'Thursday',
                            'Friday',
                            'Saturday'
                        ]),
                        window: z.enum([
                            'Scheduling',
                            'W0',
                            'W2',
                            'W4',
                            'W6',
                            'W8',
                            'W10',
                            'W12',
                            'W14',
                            'W16',
                            'W18',
                            'W20',
                            'W22'
                        ])
                    })
                }),
                capabilities: z.array(z.string()).readonly(),
                created: z.iso.datetime().readonly(),
                disk_encryption: z.union([
                    z.string().readonly().default('enabled'),
                    z.null()
                ]).readonly().default('enabled'),
                group: z.string(),
                has_user_data: z.boolean().readonly(),
                host_uuid: z.uuid().readonly(),
                hypervisor: z.enum(['kvm']),
                id: z.int().readonly(),
                image: z.union([
                    z.string(),
                    z.null()
                ]),
                interface_generation: z.enum(['legacy_config', 'linode']),
                ipv4: z.array(z.string()).readonly(),
                ipv6: z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly(),
                label: z.string().min(3).max(64).regex(/^[a-zA-Z]((?!--|__|\.\.)[a-zA-Z0-9-_.])+$/),
                lke_cluster_id: z.union([
                    z.int().readonly(),
                    z.null()
                ]).readonly(),
                maintenance_policy: z.enum(['linode/migrate', 'linode/power_off_on']),
                placement_group: z.union([
                    z.object({
                        id: z.int(),
                        label: z.string().min(1),
                        placement_group_policy: z.enum(['strict', 'flexible']),
                        placement_group_type: z.enum(['anti_affinity:local'])
                    }).readonly(),
                    z.null()
                ]).readonly(),
                region: z.string().readonly(),
                specs: z.object({
                    disk: z.int().readonly(),
                    gpus: z.int().readonly(),
                    memory: z.int().readonly(),
                    transfer: z.int().readonly(),
                    vcpus: z.int().readonly()
                }).readonly(),
                status: z.enum([
                    'running',
                    'offline',
                    'booting',
                    'busy',
                    'rebooting',
                    'shutting_down',
                    'provisioning',
                    'deleting',
                    'migrating',
                    'rebuilding',
                    'cloning',
                    'restoring',
                    'stopped',
                    'billing_suspension'
                ]),
                tags: z.array(z.string()),
                type: z.string().readonly(),
                updated: z.iso.datetime().readonly(),
                watchdog_enabled: z.boolean()
            }),
            z.object({
                axfr_ips: z.array(z.string()),
                description: z.union([
                    z.string().min(1).max(253),
                    z.null()
                ]),
                domain: z.string().min(1).max(253).regex(/^(\*\.)?([a-zA-Z0-9-_]{1,63}\.)+([a-zA-Z]{2,3}\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)$/),
                expire_sec: z.int().default(0),
                group: z.union([
                    z.string().min(1).max(50),
                    z.null()
                ]),
                id: z.int().readonly(),
                master_ips: z.array(z.string()),
                refresh_sec: z.int().default(0),
                retry_sec: z.int().default(0),
                soa_email: z.email(),
                status: z.enum(['disabled', 'active']),
                tags: z.array(z.string()),
                ttl_sec: z.int().default(0),
                type: z.enum(['master', 'slave'])
            }),
            z.object({
                created: z.iso.datetime().readonly(),
                encryption: z.enum(['enabled', 'disabled']),
                filesystem_path: z.string().readonly(),
                hardware_type: z.enum(['hdd', 'nvme']),
                id: z.int().readonly(),
                io_ready: z.boolean().readonly(),
                label: z.string().min(1).max(32).regex(/^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$/),
                linode_id: z.union([
                    z.int(),
                    z.null()
                ]),
                linode_label: z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly(),
                region: z.string(),
                size: z.int().lte(10240),
                status: z.enum([
                    'creating',
                    'active',
                    'resizing',
                    'key_rotating'
                ]),
                tags: z.array(z.string()),
                updated: z.iso.datetime().readonly()
            }),
            z.object({
                client_conn_throttle: z.int().gte(0).lte(20),
                created: z.iso.datetime().readonly(),
                hostname: z.string().readonly(),
                id: z.int().readonly(),
                ipv4: z.string().readonly(),
                ipv6: z.union([
                    z.string().readonly(),
                    z.null()
                ]).readonly(),
                label: z.string().min(3).max(32).regex(/[a-zA-Z0-9-_]{3,32}/),
                lke_cluster: z.union([
                    z.object({
                        id: z.string(),
                        label: z.string(),
                        type: z.string().readonly(),
                        url: z.string()
                    }).readonly(),
                    z.null()
                ]).readonly(),
                region: z.string().readonly(),
                tags: z.array(z.string()),
                transfer: z.object({
                    in: z.union([
                        z.number().readonly(),
                        z.null()
                    ]).readonly(),
                    out: z.union([
                        z.number().readonly(),
                        z.null()
                    ]).readonly(),
                    total: z.union([
                        z.number().readonly(),
                        z.null()
                    ]).readonly()
                }).readonly(),
                type: z.enum(['common', 'premium']),
                updated: z.iso.datetime().readonly()
            })
        ]),
        type: z.enum([
            'domain',
            'linode',
            'nodebalancer',
            'volume'
        ])
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const getVolumesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * The Block Storage volumes on your account are returned.
 */
export const getVolumesResponseSchema = z.object({
    data: z.array(z.object({
        created: z.iso.datetime().readonly(),
        encryption: z.enum(['enabled', 'disabled']),
        filesystem_path: z.string().readonly(),
        hardware_type: z.enum(['hdd', 'nvme']),
        id: z.int().readonly(),
        io_ready: z.boolean().readonly(),
        label: z.string().min(1).max(32).regex(/^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$/),
        linode_id: z.union([
            z.int(),
            z.null()
        ]),
        linode_label: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        region: z.string(),
        size: z.int().lte(10240),
        status: z.enum([
            'creating',
            'active',
            'resizing',
            'key_rotating'
        ]),
        tags: z.array(z.string()),
        updated: z.iso.datetime().readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const postVolumeRequestSchema = z.object({
    body: z.object({
        config_id: z.optional(z.int()),
        encryption: z.optional(z.enum(['enabled', 'disabled'])),
        label: z.string().min(1).max(32).regex(/^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$/),
        linode_id: z.optional(z.int()),
        region: z.optional(z.union([
            z.string(),
            z.null()
        ])),
        size: z.optional(z.int()).default(20),
        tags: z.optional(z.array(z.string()))
    }),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * Volume
 *
 * A Block Storage volume on your account.
 */
export const postVolumeResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    encryption: z.enum(['enabled', 'disabled']),
    filesystem_path: z.string().readonly(),
    hardware_type: z.enum(['hdd', 'nvme']),
    id: z.int().readonly(),
    io_ready: z.boolean().readonly(),
    label: z.string().min(1).max(32).regex(/^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$/),
    linode_id: z.union([
        z.int(),
        z.null()
    ]),
    linode_label: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    region: z.string(),
    size: z.int().lte(10240),
    status: z.enum([
        'creating',
        'active',
        'resizing',
        'key_rotating'
    ]),
    tags: z.array(z.string()),
    updated: z.iso.datetime().readonly()
});

export const getVolumeTypesRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * A collection of volume types.
 */
export const getVolumeTypesResponseSchema = z.object({
    data: z.array(z.object({
        id: z.string().readonly(),
        label: z.string().readonly(),
        price: z.object({
            hourly: z.number(),
            monthly: z.number()
        }).readonly(),
        region_prices: z.array(z.object({
            hourly: z.number(),
            id: z.string(),
            monthly: z.number()
        })),
        transfer: z.int().gte(0).readonly()
    })),
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
});

export const deleteVolumeRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        volumeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteVolumeResponseSchema = z.record(z.string(), z.unknown());

export const getVolumeRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        volumeId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * Volume
 *
 * A Block Storage volume on your account.
 */
export const getVolumeResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    encryption: z.enum(['enabled', 'disabled']),
    filesystem_path: z.string().readonly(),
    hardware_type: z.enum(['hdd', 'nvme']),
    id: z.int().readonly(),
    io_ready: z.boolean().readonly(),
    label: z.string().min(1).max(32).regex(/^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$/),
    linode_id: z.union([
        z.int(),
        z.null()
    ]),
    linode_label: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    region: z.string(),
    size: z.int().lte(10240),
    status: z.enum([
        'creating',
        'active',
        'resizing',
        'key_rotating'
    ]),
    tags: z.array(z.string()),
    updated: z.iso.datetime().readonly()
});

export const putVolumeRequestSchema = z.object({
    body: z.object({
        created: z.iso.datetime().readonly(),
        encryption: z.enum(['enabled', 'disabled']),
        filesystem_path: z.string().readonly(),
        hardware_type: z.enum(['hdd', 'nvme']),
        id: z.int().readonly(),
        io_ready: z.boolean().readonly(),
        label: z.string().min(1).max(32).regex(/^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$/),
        linode_id: z.union([
            z.int(),
            z.null()
        ]),
        linode_label: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        region: z.string(),
        size: z.int().lte(10240),
        status: z.enum([
            'creating',
            'active',
            'resizing',
            'key_rotating'
        ]),
        tags: z.array(z.string()),
        updated: z.iso.datetime().readonly()
    }).and(z.object({
        linode_id: z.unknown().readonly(),
        size: z.unknown().readonly()
    })),
    path: z.object({
        volumeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Volume
 *
 * A Block Storage volume on your account.
 */
export const putVolumeResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    encryption: z.enum(['enabled', 'disabled']),
    filesystem_path: z.string().readonly(),
    hardware_type: z.enum(['hdd', 'nvme']),
    id: z.int().readonly(),
    io_ready: z.boolean().readonly(),
    label: z.string().min(1).max(32).regex(/^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$/),
    linode_id: z.union([
        z.int(),
        z.null()
    ]),
    linode_label: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    region: z.string(),
    size: z.int().lte(10240),
    status: z.enum([
        'creating',
        'active',
        'resizing',
        'key_rotating'
    ]),
    tags: z.array(z.string()),
    updated: z.iso.datetime().readonly()
});

export const postAttachVolumeRequestSchema = z.object({
    body: z.object({
        config_id: z.optional(z.int()),
        linode_id: z.int(),
        persist_across_boots: z.optional(z.boolean()).default(true)
    }),
    path: z.object({
        volumeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Volume
 *
 * A Block Storage volume on your account.
 */
export const postAttachVolumeResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    encryption: z.enum(['enabled', 'disabled']),
    filesystem_path: z.string().readonly(),
    hardware_type: z.enum(['hdd', 'nvme']),
    id: z.int().readonly(),
    io_ready: z.boolean().readonly(),
    label: z.string().min(1).max(32).regex(/^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$/),
    linode_id: z.union([
        z.int(),
        z.null()
    ]),
    linode_label: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    region: z.string(),
    size: z.int().lte(10240),
    status: z.enum([
        'creating',
        'active',
        'resizing',
        'key_rotating'
    ]),
    tags: z.array(z.string()),
    updated: z.iso.datetime().readonly()
});

export const postCloneVolumeRequestSchema = z.object({
    body: z.object({
        label: z.string().min(1).max(32).regex(/^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$/)
    }),
    path: z.object({
        volumeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Volume
 *
 * A Block Storage volume on your account.
 */
export const postCloneVolumeResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    encryption: z.enum(['enabled', 'disabled']),
    filesystem_path: z.string().readonly(),
    hardware_type: z.enum(['hdd', 'nvme']),
    id: z.int().readonly(),
    io_ready: z.boolean().readonly(),
    label: z.string().min(1).max(32).regex(/^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$/),
    linode_id: z.union([
        z.int(),
        z.null()
    ]),
    linode_label: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    region: z.string(),
    size: z.int().lte(10240),
    status: z.enum([
        'creating',
        'active',
        'resizing',
        'key_rotating'
    ]),
    tags: z.array(z.string()),
    updated: z.iso.datetime().readonly()
});

export const postDetachVolumeRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        volumeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const postDetachVolumeResponseSchema = z.record(z.string(), z.unknown());

export const postResizeVolumeRequestSchema = z.object({
    body: z.object({
        size: z.int().lte(10240)
    }),
    path: z.object({
        volumeId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * Volume
 *
 * A Block Storage volume on your account.
 */
export const postResizeVolumeResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    encryption: z.enum(['enabled', 'disabled']),
    filesystem_path: z.string().readonly(),
    hardware_type: z.enum(['hdd', 'nvme']),
    id: z.int().readonly(),
    io_ready: z.boolean().readonly(),
    label: z.string().min(1).max(32).regex(/^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+$/),
    linode_id: z.union([
        z.int(),
        z.null()
    ]),
    linode_label: z.union([
        z.string().readonly(),
        z.null()
    ]).readonly(),
    region: z.string(),
    size: z.int().lte(10240),
    status: z.enum([
        'creating',
        'active',
        'resizing',
        'key_rotating'
    ]),
    tags: z.array(z.string()),
    updated: z.iso.datetime().readonly()
});

export const getVpcsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of VPC objects.
 */
export const getVpcsResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.optional(z.array(z.object({
        created: z.iso.datetime().readonly(),
        description: z.string().max(255).default(''),
        id: z.int().readonly(),
        label: z.string().min(1).max(64),
        region: z.string(),
        subnets: z.array(z.object({
            created: z.iso.datetime().readonly(),
            id: z.int().readonly(),
            ipv4: z.string(),
            label: z.string().min(1).max(64),
            linodes: z.array(z.object({
                id: z.int(),
                interfaces: z.array(z.object({
                    active: z.boolean(),
                    config_id: z.union([
                        z.int(),
                        z.null()
                    ]),
                    id: z.int()
                }))
            })).readonly(),
            updated: z.union([
                z.iso.datetime().readonly(),
                z.null()
            ]).readonly()
        })),
        updated: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly()
    })))
}));

export const postVpcRequestSchema = z.object({
    body: z.intersection(z.unknown(), z.object({
        subnets: z.optional(z.unknown())
    }), z.object({
        created: z.iso.datetime().readonly(),
        description: z.string().max(255).default(''),
        id: z.int().readonly(),
        label: z.string().min(1).max(64),
        region: z.string(),
        subnets: z.array(z.object({
            created: z.iso.datetime().readonly(),
            id: z.int().readonly(),
            ipv4: z.string(),
            label: z.string().min(1).max(64),
            linodes: z.array(z.object({
                id: z.int(),
                interfaces: z.array(z.object({
                    active: z.boolean(),
                    config_id: z.union([
                        z.int(),
                        z.null()
                    ]),
                    id: z.int()
                }))
            })).readonly(),
            updated: z.union([
                z.iso.datetime().readonly(),
                z.null()
            ]).readonly()
        })),
        updated: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly()
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never())
});

/**
 * An object describing a VPC belonging to the Account.
 */
export const postVpcResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    description: z.string().max(255).default(''),
    id: z.int().readonly(),
    label: z.string().min(1).max(64),
    region: z.string(),
    subnets: z.array(z.object({
        created: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        ipv4: z.string(),
        label: z.string().min(1).max(64),
        linodes: z.array(z.object({
            id: z.int(),
            interfaces: z.array(z.object({
                active: z.boolean(),
                config_id: z.union([
                    z.int(),
                    z.null()
                ]),
                id: z.int()
            }))
        })).readonly(),
        updated: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly()
    })),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly()
});

export const getVpcsIpsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.optional(z.never()),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of VPC interface IP addresses.
 */
export const getVpcsIpsResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.optional(z.array(z.object({
        active: z.boolean().readonly(),
        address: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        address_range: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        config_id: z.union([
            z.int().readonly(),
            z.null()
        ]).readonly(),
        gateway: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        interface_id: z.int().readonly(),
        linode_id: z.int().readonly(),
        nat_1_1: z.string().readonly(),
        prefix: z.union([
            z.int().readonly(),
            z.null()
        ]).readonly(),
        region: z.string().readonly(),
        subnet_id: z.int(),
        subnet_mask: z.string().readonly(),
        vpc_id: z.int().readonly()
    })))
}));

export const deleteVpcRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        vpcId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteVpcResponseSchema = z.record(z.string(), z.unknown());

export const getVpcRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        vpcId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * An object describing a VPC belonging to the Account.
 */
export const getVpcResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    description: z.string().max(255).default(''),
    id: z.int().readonly(),
    label: z.string().min(1).max(64),
    region: z.string(),
    subnets: z.array(z.object({
        created: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        ipv4: z.string(),
        label: z.string().min(1).max(64),
        linodes: z.array(z.object({
            id: z.int(),
            interfaces: z.array(z.object({
                active: z.boolean(),
                config_id: z.union([
                    z.int(),
                    z.null()
                ]),
                id: z.int()
            }))
        })).readonly(),
        updated: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly()
    })),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly()
});

export const putVpcRequestSchema = z.object({
    body: z.object({
        description: z.string().max(255).default(''),
        label: z.string().min(1).max(64)
    }),
    path: z.object({
        vpcId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * An object describing a VPC belonging to the Account.
 */
export const putVpcResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    description: z.string().max(255).default(''),
    id: z.int().readonly(),
    label: z.string().min(1).max(64),
    region: z.string(),
    subnets: z.array(z.object({
        created: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        ipv4: z.string(),
        label: z.string().min(1).max(64),
        linodes: z.array(z.object({
            id: z.int(),
            interfaces: z.array(z.object({
                active: z.boolean(),
                config_id: z.union([
                    z.int(),
                    z.null()
                ]),
                id: z.int()
            }))
        })).readonly(),
        updated: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly()
    })),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly()
});

export const getVpcIpsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        vpcId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * The IP addresses for the requested VPC.
 */
export const getVpcIpsResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.optional(z.array(z.object({
        active: z.boolean().readonly(),
        address: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        address_range: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        config_id: z.union([
            z.int().readonly(),
            z.null()
        ]).readonly(),
        gateway: z.union([
            z.string().readonly(),
            z.null()
        ]).readonly(),
        interface_id: z.int().readonly(),
        linode_id: z.int().readonly(),
        nat_1_1: z.string().readonly(),
        prefix: z.union([
            z.int().readonly(),
            z.null()
        ]).readonly(),
        region: z.string().readonly(),
        subnet_id: z.int(),
        subnet_mask: z.string().readonly(),
        vpc_id: z.int().readonly()
    })))
}));

export const getVpcSubnetsRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        vpcId: z.int()
    }),
    query: z.optional(z.object({
        page: z.optional(z.int().gte(1)).default(1),
        page_size: z.optional(z.int().gte(25).lte(500)).default(100)
    }))
});

/**
 * A paginated list of VPC Subnet objects.
 */
export const getVpcSubnetsResponseSchema = z.object({
    page: z.int().readonly(),
    pages: z.int().readonly(),
    results: z.int().readonly()
}).and(z.object({
    data: z.optional(z.array(z.object({
        created: z.iso.datetime().readonly(),
        id: z.int().readonly(),
        ipv4: z.string(),
        label: z.string().min(1).max(64),
        linodes: z.array(z.object({
            id: z.int(),
            interfaces: z.array(z.object({
                active: z.boolean(),
                config_id: z.union([
                    z.int(),
                    z.null()
                ]),
                id: z.int()
            }))
        })).readonly(),
        updated: z.union([
            z.iso.datetime().readonly(),
            z.null()
        ]).readonly()
    })))
}));

export const postVpcSubnetRequestSchema = z.object({
    body: z.object({
        ipv4: z.string(),
        label: z.string().min(1).max(64)
    }),
    path: z.object({
        vpcId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * An object describing a VPC Subnet.
 */
export const postVpcSubnetResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    ipv4: z.string(),
    label: z.string().min(1).max(64),
    linodes: z.array(z.object({
        id: z.int(),
        interfaces: z.array(z.object({
            active: z.boolean(),
            config_id: z.union([
                z.int(),
                z.null()
            ]),
            id: z.int()
        }))
    })).readonly(),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly()
});

export const deleteVpcSubnetRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        vpcId: z.int(),
        vpcSubnetId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * The API responds with an empty object.
 */
export const deleteVpcSubnetResponseSchema = z.record(z.string(), z.unknown());

export const getVpcSubnetRequestSchema = z.object({
    body: z.optional(z.never()),
    path: z.object({
        vpcId: z.int(),
        vpcSubnetId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * An object describing a VPC Subnet.
 */
export const getVpcSubnetResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    ipv4: z.string(),
    label: z.string().min(1).max(64),
    linodes: z.array(z.object({
        id: z.int(),
        interfaces: z.array(z.object({
            active: z.boolean(),
            config_id: z.union([
                z.int(),
                z.null()
            ]),
            id: z.int()
        }))
    })).readonly(),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly()
});

export const putVpcSubnetRequestSchema = z.object({
    body: z.object({
        label: z.string().min(1).max(64)
    }),
    path: z.object({
        vpcId: z.int(),
        vpcSubnetId: z.int()
    }),
    query: z.optional(z.never())
});

/**
 * An object describing a VPC Subnet.
 */
export const putVpcSubnetResponseSchema = z.object({
    created: z.iso.datetime().readonly(),
    id: z.int().readonly(),
    ipv4: z.string(),
    label: z.string().min(1).max(64),
    linodes: z.array(z.object({
        id: z.int(),
        interfaces: z.array(z.object({
            active: z.boolean(),
            config_id: z.union([
                z.int(),
                z.null()
            ]),
            id: z.int()
        }))
    })).readonly(),
    updated: z.union([
        z.iso.datetime().readonly(),
        z.null()
    ]).readonly()
});
