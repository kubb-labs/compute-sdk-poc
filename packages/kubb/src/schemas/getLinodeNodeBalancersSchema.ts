/**
* Generated by Kubb (https://kubb.dev/).
* Do not edit manually.
*/

import { z } from "zod/v4";

export const getLinodeNodeBalancersPathParamsSchema = z.object({
    "linodeId": z.coerce.number().int().describe("ID of the Linode to look up.")
    })

/**
 * @description Returns a paginated list of NodeBalancers.
 */
export const getLinodeNodeBalancers200Schema = z.object({
    "data": z.array(z.object({
    "client_conn_throttle": z.int().min(0).max(20).describe("Throttle TCP connections per second for TCP, HTTP, and HTTPS configurations.  Set to `0` (zero) to disable throttling."),
"created": z.string().datetime().describe("__Read-only__ When this NodeBalancer was created."),
"hostname": z.string().describe("__Read-only__ This NodeBalancer's hostname, beginning with its IP address and ending with _.ip.linodeusercontent.com_."),
"id": z.int().describe("__Read-only__ This NodeBalancer's unique ID."),
"ipv4": z.string().describe("__Filterable__, __Read-only__ This NodeBalancer's public IPv4 address."),
"ipv6": z.nullable(z.string().describe("__Read-only__ This NodeBalancer's public IPv6 address.")),
"label": z.string().regex(/[a-zA-Z0-9-_]{3,32}/).describe("__Filterable__ This NodeBalancer's label. These must be unique on your Account."),
"lke_cluster": z.nullable(z.object({
    "id": z.string().describe("The ID of the related LKE cluster."),
"label": z.string().describe("The label of the related LKE cluster."),
"type": z.string().describe("__Read-only__ The type for LKE clusters."),
"url": z.string().describe("The URL where you can access the related LKE cluster.")
    }).describe("__Read-only__ This NodeBalancer's related LKE cluster, if any. The value is `null` if this NodeBalancer isn't related to an LKE cluster.")),
"region": z.string().describe("__Filterable__, __Read-only__ The Region where this NodeBalancer is located. NodeBalancers only support backends in the same Region."),
"tags": z.array(z.string()).describe("__Filterable__ An array of Tags applied to this object.  Tags are for organizational purposes only."),
"transfer": z.object({
    "in": z.nullable(z.number().describe("__Read-only__ The total outbound transfer, in MB, used for this NodeBalancer this month.")),
"out": z.nullable(z.number().describe("__Read-only__ The total inbound transfer, in MB, used for this NodeBalancer this month.")),
"total": z.nullable(z.number().describe("__Read-only__ The total transfer, in MB, used by this NodeBalancer this month."))
    }).describe("__Read-only__ Information about the amount of transfer this NodeBalancer has had so far this month."),
"type": z.enum(["common", "premium"]).describe("__Read-only__ The type of NodeBalancer."),
"updated": z.string().datetime().describe("__Read-only__ When this NodeBalancer was last updated.")
    }).describe("Linode's load balancing solution. Can handle multiple ports, SSL termination, and any number of backends. NodeBalancer ports are configured with NodeBalancer configs, and each config is given one or more NodeBalancer nodes that accepts traffic.  The traffic should be routed to the NodeBalancer's IP address, for the NodeBalancer to handle routing individual requests to backends.")),
"page": z.int().describe("__Read-only__ The current [page](https://techdocs.akamai.com/linode-api/reference/pagination)."),
"pages": z.int().describe("__Read-only__ The total number of [pages](https://techdocs.akamai.com/linode-api/reference/pagination)."),
"results": z.int().describe("__Read-only__ The total number of results.")
    })

export const getLinodeNodeBalancersQueryResponseSchema = z.lazy(() => getLinodeNodeBalancers200Schema)