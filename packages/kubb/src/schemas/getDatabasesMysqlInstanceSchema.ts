/**
* Generated by Kubb (https://kubb.dev/).
* Do not edit manually.
*/

import { z } from "zod/v4";

export const getDatabasesMysqlInstancePathParamsSchema = z.object({
    "apiVersion": z.enum(["v4", "v4beta"]).describe("__Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta."),
"instanceId": z.coerce.number().int().describe("The ID of the Managed PostgreSQL Database.")
    })

/**
 * @description Returns information for a single MySQL Managed Database.
 */
export const getDatabasesMysqlInstance200Schema = z.object({
    "allow_list": z.optional(z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0).describe("Controls access to the Managed Database.\n\n- Individually included IP addresses or CIDR ranges can access the Managed Database while all other sources are blocked.\n\n- A standalone value of `0.0.0.0/0` allows all IP addresses access to the Managed Database.\n\n- An empty array (`[]`) blocks all public and private connections to the Managed Database.")),
"cluster_size": z.optional(z.union([z.literal(1), z.literal(2), z.literal(3)]).default(1).describe("The number of Linode instance nodes deployed to the Managed Database.\n\n - Choose `3` nodes to create a high availability cluster that consists of one primary node and two replica nodes.\n\n- A `2` node cluster is only available with a dedicated plan. It consists of one primary node and one replica node.")),
"created": z.optional(z.string().datetime().describe("__Read-only__ When this Managed Database was created.")),
"encrypted": z.optional(z.boolean().default(true).describe("__Read-only__ Whether the Managed Databases is encrypted. Currently required to be `true`.")),
"engine": z.optional(z.string().describe("__Filterable__, __Read-only__ The Managed Database engine type.")),
"engine_config": z.optional(z.object({
    "binlog_retention_period": z.optional(z.int().min(600).max(86400).describe("The minimum amount of time in seconds to keep `binlog` entries before deletion. This may be extended for services that require `binlog` entries for longer than the default, for example if using the MySQL Debezium Kafka connector.")),
"mysql": z.optional(z.object({
    "connect_timeout": z.optional(z.int().min(2).max(3600).describe("The number of seconds that the `mysqld` server waits for a connect packet before responding with bad handshake.")),
"default_time_zone": z.optional(z.string().regex(/^([-+][\\d:]*|[\\w/]*)$/).describe("Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or `SYSTEM` to use the MySQL server default.")),
"group_concat_max_len": z.optional(z.int().min(4).max(18446744073709552000).describe("The maximum permitted result length in bytes for the `GROUP_CONCAT()` function.")),
"information_schema_stats_expiry": z.optional(z.int().min(900).max(31536000).describe("The time, in seconds, before cached statistics expire.")),
"innodb_change_buffer_max_size": z.optional(z.int().min(0).max(50).default(25).describe("Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool.")),
"innodb_flush_neighbors": z.optional(z.int().min(0).max(2).default(1).describe("Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent: `0` - dirty pages in the same extent are not flushed, `1` - flush contiguous dirty pages in the same extent, `2` - flush dirty pages in the same extent.")),
"innodb_ft_min_token_size": z.optional(z.int().min(0).max(16).describe("Minimum length of words that are stored in an InnoDB `-1FULLTEXT` index. Changing this parameter will lead to a restart of the MySQL service.")),
"innodb_ft_server_stopword_table": z.string().regex(/^.+\/.+$/).describe("This option is used to specify your own InnoDB `FULLTEXT` index `stopword` list for all InnoDB tables. Set to `null` for no value.").nullish(),
"innodb_lock_wait_timeout": z.optional(z.int().min(1).max(3600).default(120).describe("The length of time in seconds an InnoDB transaction waits for a row lock before giving up.")),
"innodb_log_buffer_size": z.optional(z.int().min(1048576).max(4294967295).describe("The size in bytes of the buffer that InnoDB uses to write to the log files on disk.")),
"innodb_online_alter_log_max_size": z.optional(z.int().min(65536).max(1099511627776).describe("The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.")),
"innodb_read_io_threads": z.optional(z.int().min(1).max(64).default(4).describe("The number of I/O threads for read operations in InnoDB. Changing this parameter will lead to a restart of the MySQL service.")),
"innodb_rollback_on_timeout": z.optional(z.boolean().describe("When enabled a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.")),
"innodb_thread_concurrency": z.optional(z.int().min(0).max(1000).default(0).describe("Defines the maximum number of threads permitted inside of InnoDB. The default is `0` which indicates infinite concurrency, or no limit.")),
"innodb_write_io_threads": z.optional(z.int().min(1).max(64).default(4).describe("The number of I/O threads for write operations in InnoDB. Changing this parameter will lead to a restart of the MySQL service.")),
"interactive_timeout": z.optional(z.int().min(30).max(604800).describe("The number of seconds the server waits for activity on an interactive connection before closing it.")),
"internal_tmp_mem_storage_engine": z.optional(z.enum(["TempTable", "MEMORY"]).describe("The storage engine for in-memory internal temporary tables.")),
"max_allowed_packet": z.optional(z.int().min(102400).max(1073741824).default(7108864).describe("Size of the largest message in bytes that can be received by the server.")),
"max_heap_table_size": z.optional(z.int().min(1048576).max(1073741824).default(16777216).describe("Limits the size of internal in-memory tables. Also set `tmp_table_size`.")),
"net_buffer_length": z.optional(z.int().min(1024).max(1048576).default(16384).describe("Start sizes of connection buffer and result buffer. Changing this parameter will lead to a restart of the MySQL service.")),
"net_read_timeout": z.optional(z.int().min(1).max(3600).describe("The number of seconds to wait for more data from a connection before aborting the read.")),
"net_write_timeout": z.optional(z.int().min(1).max(3600).describe("The number of seconds to wait for a block to be written to a connection before aborting the write.")),
"sql_mode": z.optional(z.string().regex(/^[A-Z_]*(,[A-Z_]+)*$/).describe("Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field, Akamai defaults to SQL mode which is strict, SQL standard compliant.")),
"sql_require_primary_key": z.optional(z.boolean().describe("Require primary key to be defined for new tables or old tables modified with `ALTER TABLE` and fail if missing. You should always have primary keys because various functionality may break if any large table is missing them.")),
"tmp_table_size": z.optional(z.int().min(1048576).max(1073741824).default(16777216).describe("Limits the size of internal in-memory tables. This also requires a `max_heap_table_size`.")),
"wait_timeout": z.optional(z.int().min(1).max(2147483).describe("The number of seconds the server waits for activity on a non-interactive connection before closing it."))
    }).describe("MySQL-specific advanced configuration parameters."))
    }).describe("Advanced parameters you can apply to a MySQL Managed Database, via our partner [Aiven's specification](https://aiven.io/docs/products/mysql/reference/advanced-params). Only include the objects for parameters you want to set in your database. Omit objects for parameters you don't want to define or change.\n\n> ðŸ“˜\n>\n> Aiven may offer additional parameters in their specification. Currently, only those listed here are supported for use in a MySQL Managed Database. You can also run the [List MySQL Managed Database advanced parameters](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-config) operation to see an up-to-date list.")),
"fork": z.optional(z.object({
    "restore_time": z.optional(z.string().datetime().describe("The database timestamp from which it was restored. This is _not_ when the fork was created.")),
"source": z.optional(z.int().describe("The instance id of the database that was forked from."))
    }).describe("Details on the database that was the target of the fork. This only exists if the database was restored by creating a fork from another [MySQL](https://techdocs.akamai.com/linode-api/reference/post-databases-mysql-instances) or [PostgreSQL](https://techdocs.akamai.com/linode-api/reference/post-databases-postgre-sql-instances) database.")),
"hosts": z.optional(z.object({
    "primary": z.string().describe("The primary hostname for the Managed Database.\n\n> ðŸ“˜\n>\n> - If you've configured the Managed Database to use a Virtual Private Cloud (VPC) via the `private_network` object ([MySQL](https://techdocs.akamai.com/linode-api/reference/post-databases-mysql-instances) / [PostgreSQL](https://techdocs.akamai.com/linode-api/reference/post-databases-postgre-sql-instances)), this hostname resolves to a private IPv4 address within that VPC subnet's address range. Currently, IPv6 addresses aren't supported in a VPC.\n>\n> - With `public_access` enabled in a `private_network`, a public version of this hostname is also available. Resolving this hostname returns _publicly_ routable IPv4 and IPv6 addresses.").nullish(),
"secondary": z.string().describe("The secondary, read-only hostname for the Managed Database. This can only be used to access a Managed Database cluster from Linodes in the same data center (region). Accessing the cluster through this hostname doesn't incur transfer costs.\n\n> ðŸ“˜\n>\n> - The secondary hostname is publicly visible and accessible.\n>\n> - If you've configured the Managed Database to use a VPC via the `private_network` object ([MySQL](https://techdocs.akamai.com/linode-api/reference/post-databases-mysql-instances) / [PostgreSQL](https://techdocs.akamai.com/linode-api/reference/post-databases-postgre-sql-instances)), this hostname resolves to a private IPv4 address within that VPC subnet's address range. Currently, IPv6 addresses aren't supported in a VPC. You can also use this hostname for requests between clients within the same VPC to access the cluster over the private network, which avoids transfer costs.\n>\n> - With `public_access` enabled in a `private_network`, a public version of this hostname is also available. Resolving this hostname returns publicly routable IPv4 and IPv6 addresses.").nullish()
    }).describe("__Read-only__ The primary hostname and secondary read-only hostname for the Managed Database. The API assigns these hostnames after it successfully creates the Managed Database.")),
"id": z.optional(z.int().describe("__Read-only__ A unique ID that can be used to identify and reference the Managed Database.")),
"label": z.optional(z.string().min(3).max(32).describe("__Filterable__ A unique, user-defined string referring to the Managed Database. This string needs to be unique per Managed Database engine type.")),
"members": z.optional(z.object({
    
    }).describe("__Read-only__ A mapping between IP addresses and strings designating them as `primary` or `failover`.")),
"oldest_restore_time": z.optional(z.string().datetime().describe("__Read-only__ The oldest time to which a database can be restored.")),
"platform": z.optional(z.enum(["rdbms-legacy", "rdbms-default"]).describe("__Filterable__, __Read-only__ The back-end platform for relational databases used by the service.")),
"port": z.optional(z.int().describe("__Read-only__ The access port for this Managed Database.")),
"private_network": z.object({
    "public_access": z.optional(z.boolean().default(false).describe("When set to `true`, clients outside of the VPC can connect to the database. Defaults to `false`, where only nodes within the specified `vpc_id` can access the Managed Database cluster.\n\n> ðŸ“˜\n>\n> If your Managed Database is also configured using an `allow_list`, only IP addresses set in it can access that database, even if this object is set to `true`.")),
"subnet_id": z.optional(z.int().describe("The unique identifier of a specific subnet, in the VPC (`vpc_id`) where the Managed Database can be accessed.")),
"vpc_id": z.optional(z.int().describe("The unique identifier of the VPC where this database exists."))
    }).describe("__Beta__ Restricts access to a MySQL Managed Database using a Virtual Private Cloud (VPC). Displayed as `null` if no VPC is configured.").nullish(),
"region": z.optional(z.string().describe("__Filterable__ The unique identifier for the [region](https://techdocs.akamai.com/linode-api/reference/get-regions) where the Managed Database lives.")),
"ssl_connection": z.optional(z.boolean().default(true).describe("Currently required to be `true`. Whether to require SSL credentials to establish a connection to the Managed Database. Run the [Get managed MySQL database credentials](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance-credentials) operation for access information.")),
"status": z.optional(z.enum(["provisioning", "active", "suspending", "suspended", "resuming", "failed", "degraded", "updating", "resizing"]).describe("__Filterable__, __Read-only__ The operating status of the Managed Database.")),
"total_disk_size_gb": z.optional(z.int().describe("__Read-only__ The total disk size of the database, in GB.")),
"type": z.optional(z.string().describe("__Filterable__ The Linode Instance type used by the Managed Database for its nodes.")),
"updated": z.optional(z.string().datetime().describe("__Read-only__ When this Managed Database was last updated.")),
"updates": z.optional(z.object({
    "day_of_week": z.optional(z.int().min(1).max(7).describe("The numeric reference for the day of the week to perform maintenance. `1` is Monday, `2` is Tuesday, through to `7` which is Sunday.")),
"duration": z.optional(z.int().min(1).max(3).describe("The maximum maintenance window time in hours.")),
"frequency": z.optional(z.enum(["weekly"]).default("weekly").describe("How frequently maintenance occurs. Currently can only be `weekly`.")),
"hour_of_day": z.optional(z.int().min(0).max(23).describe("The hour to begin maintenance based in UTC time.")),
"pending": z.optional(z.array(z.object({
    "deadline": z.string().datetime().describe("The time when a mandatory update needs to be applied.").nullish(),
"description": z.optional(z.string().describe("A description of the update.")),
"planned_for": z.string().datetime().describe("The date and time a maintenance update will be applied.").nullish()
    }).describe("A planned maintenance update.")).min(0).describe("__Read-only__ An array of pending updates."))
    }).describe("Configuration settings for automated patch update maintenance for the Managed Database.")),
"used_disk_size_gb": z.optional(z.int().describe("__Read-only__ The amount of space currently in use in the database, in GB.")),
"version": z.optional(z.string().describe("__Filterable__ The Managed Database engine version."))
    }).describe("Managed MySQL Databases object.")

/**
 * @description See [Errors](https://techdocs.akamai.com/linode-api/reference/errors) for the range of possible error response codes.
 */
export const getDatabasesMysqlInstanceErrorSchema = z.object({
    "errors": z.optional(z.array(z.object({
    "field": z.optional(z.string().describe("The field in the request that caused this error. This may be a path, separated by periods in the case of nested fields. In some cases this may come back as `null` if the error is not specific to any single element of the request.")),
"reason": z.optional(z.string().describe("What happened to cause this error. In most cases, this can be fixed immediately by changing the data you sent in the request, but in some cases you will be instructed to [Open a support ticket](https://techdocs.akamai.com/linode-api/reference/post-ticket) or perform some other action before you can complete the request successfully."))
    }).describe("An object for describing a single error that occurred during the processing of a request.")))
    })

export const getDatabasesMysqlInstanceQueryResponseSchema = z.lazy(() => getDatabasesMysqlInstance200Schema)