/**
* Generated by Kubb (https://kubb.dev/).
* Do not edit manually.
*/

import { z } from "zod/v4";

export const postReadMetricPathParamsSchema = z.object({
    "serviceType": z.string().describe("The Akamai Cloud Computing service being monitored. To see your currently supported services, run the [List supported service types](https://techdocs.akamai.com/linode-api/reference/get-monitor-services) operation and store the appropriate `service_type`."),
"apiVersion": z.enum(["v2beta"]).describe("__Enum__ Call the `v2beta` URL to use the version 2 beta operation.")
    })

/**
 * @description Metrics returned.
 */
export const postReadMetric200Schema = z.object({
    "data": z.object({
    "result": z.optional(z.array(z.object({
    "metric": z.optional(z.object({
    
    }).catchall(z.string()).describe("A mapping of labels where keys and values are strings representing details for the metric.")),
"values": z.optional(z.array(z.array(z.union([z.int(), z.string()]))).min(1).describe("Pairs that consist of an epoch timestamp and a corresponding metric value."))
    })).min(1).describe("Pairs of a specific `metric` and its corresponding `values`.")),
"resultType": z.optional(z.enum(["matrix"]).describe("The type of result, which will always be `matrix` in this context."))
    }).describe("A collection of information for the metric."),
"isPartial": z.boolean().describe("Indicates whether the result is partial. A result of `false` indicates the response is complete, while `true` indicates a partial response."),
"stats": z.object({
    "executionTimeMsec": z.optional(z.int().min(0).describe("The time taken to execute the query, in milliseconds.")),
"seriesFetched": z.optional(z.string().min(1).describe("The number of metric series fetched in the query."))
    }).describe("Statistics for a query against a `metric`."),
"status": z.string().describe("The status of the query execution, such as `success`.")
    })

/**
 * @description See [Errors](https://techdocs.akamai.com/linode-api/reference/errors) for the range of possible error response codes.
 */
export const postReadMetricErrorSchema = z.object({
    "errors": z.optional(z.array(z.object({
    "field": z.optional(z.string().describe("The field in the request that caused this error. This may be a path, separated by periods in the case of nested fields. In some cases this may come back as `null` if the error is not specific to any single element of the request.")),
"reason": z.optional(z.string().describe("What happened to cause this error. In most cases, this can be fixed immediately by changing the data you sent in the request, but in some cases you will be instructed to [Open a support ticket](https://techdocs.akamai.com/linode-api/reference/post-ticket) or perform some other action before you can complete the request successfully."))
    }).describe("An object for describing a single error that occurred during the processing of a request.")))
    })

export const postReadMetricMutationRequestSchema = z.union([z.object({
    "entity_ids": z.array(z.int()).min(1).describe("The `id` for each individual entity from a `service_type`. Get this value by running the list operation for the appropriate entity. For example, if your entity is one of your PostgreSQL databases, run the [List PostgreSQL Managed Databases](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instances) operation and store the `id` for the appropriate database from the response."),
"filters": z.optional(z.array(z.object({
    "dimension_label": z.optional(z.string().describe("The name of the dimension label to filter on.")),
"operator": z.optional(z.enum(["eq", "neq", "startswith", "endswith"]).describe("The operator to apply to the dimension label. Available values are `eq` for equal, `neq` for not equal, `startswith`, and `endswith`.")),
"value": z.optional(z.string().describe("The value to compare the dimension label against."))
    })).describe("Individual objects that define dimension filters for the query.")),
"group_by": z.optional(z.array(z.string()).describe("Categorizes response data based on the specified fields:\n\n* `entity_id`. Include this parameter by name to group the response data using the `entity_id` values included in the request.\n\n* `dimension_label`. This represents the desired dimension from a monitoring metric. To get a `dimension_label`, run the [List metrics for a service type](https://techdocs.akamai.com/linode-api/reference/get-monitor-information) operation, review the available `dimensions`, and store the applicable `dimension_label` values.\n\nYou can group these fields using these combinations:\n\n* Group by `entity_id` values and one or more `dimensions_label` values. For example, `[entity_id, node_type]` groups response data based on values set for the `entity_id` parameter and the `node_type` dimension that's available for a `service_type` of `dbaas`.\n\n* Group by only the `entity_id` values. For example, `[entity_id]` exclusively groups response data based on values set for the `entity_id` parameter.\n\n* Group by one or more `dimension_label` values. For example, `[node_type]` groups response data based on the `node_type` dimension that's available for a `service_type` of `dbaas`.\n\nIf you leave this out of a request, data is aggregated across all series.")),
"metrics": z.array(z.object({
    "aggregate_function": z.optional(z.enum(["min", "max", "avg", "sum"]).describe("The aggregation function applied to the metric. Available values are `min`, `max`, `avg`, and `sum`.")),
"name": z.optional(z.string().describe("The metric to query."))
    })).min(1).describe("A list of metric objects, each specifying a metric name and its corresponding aggregation function."),
"time_granularity": z.optional(z.object({
    "unit": z.optional(z.enum(["sec", "min", "hr", "days"]).describe("The unit of time granularity for the metric data. Available values are `sec`, `min`, `hr`, and `days`.")),
"value": z.optional(z.int().describe("The value that corresponds to the `unit`. Set to `10` with a `unit` of `hr` for 10 hours."))
    }).describe("Allows for an optional time granularity setting for metric data.")),
"relative_time_duration": z.object({
    "unit": z.optional(z.enum(["sec", "min", "hr", "days"]).describe("The unit of time used for the relative duration to query metric data. Available values are `sec`, `min`, `hr`, and `days`.")),
"value": z.optional(z.int().describe("The value that corresponds to the `unit`. Set to `30` with a `unit` of `min` for 30 minutes."))
    }).describe("Specifies a relative time duration for data queries. Queries begin immediately for the specified amount of time. You can specify a `relative_time_duration` or an `absolute_time_duration`, but not both.")
    }), z.object({
    "entity_ids": z.array(z.int()).min(1).describe("The `id` for each individual entity from a `service_type`. Get this value by running the list operation for the appropriate entity. For example, if your entity is one of your PostgreSQL databases, run the [List PostgreSQL Managed Databases](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instances) operation and store the `id` for the appropriate database from the response."),
"filters": z.optional(z.array(z.object({
    "dimension_label": z.optional(z.string().describe("The name of the dimension label to filter on.")),
"operator": z.optional(z.enum(["eq", "neq", "startswith", "endswith"]).describe("The operator to apply to the dimension label. Available values are `eq` for equal, `neq` for not equal, `startswith`, and `endswith`.")),
"value": z.optional(z.string().describe("The value to compare the dimension label against."))
    })).describe("Individual objects that define dimension filters for the query.")),
"group_by": z.optional(z.array(z.string()).describe("Categorizes response data based on the specified fields:\n\n* `entity_id`. Include this parameter by name to group the response data using the `entity_id` values included in the request.\n\n* `dimension_label`. This represents the desired dimension from a monitoring metric. To get a `dimension_label`, run the [List metrics for a service type](https://techdocs.akamai.com/linode-api/reference/get-monitor-information) operation, review the available `dimensions`, and store the applicable `dimension_label` values.\n\nYou can group these fields using these combinations:\n\n* Group by `entity_id` values and one or more `dimensions_label` values. For example, `[entity_id, node_type]` groups response data based on values set for the `entity_id` parameter and the `node_type` dimension that's available for a `service_type` of `dbaas`.\n\n* Group by only the `entity_id` values. For example, `[entity_id]` exclusively groups response data based on values set for the `entity_id` parameter.\n\n* Group by one or more `dimension_label` values. For example, `[node_type]` groups response data based on the `node_type` dimension that's available for a `service_type` of `dbaas`.\n\nIf you leave this out of a request, data is aggregated across all series.")),
"metrics": z.array(z.object({
    "aggregate_function": z.optional(z.enum(["min", "max", "avg", "sum"]).describe("The aggregation function applied to the metric. Available values are `min`, `max`, `avg`, and `sum`.")),
"name": z.optional(z.string().describe("The metric to query."))
    })).min(1).describe("A list of metric objects, each specifying a metric name and its corresponding aggregation function."),
"time_granularity": z.optional(z.object({
    "unit": z.optional(z.enum(["sec", "min", "hr", "days"]).describe("The unit of time granularity for the metric data. Available values are `sec`, `min`, `hr`, and `days`.")),
"value": z.optional(z.int().describe("The value that corresponds to the `unit`. Set to `10` with a `unit` of `hr` for 10 hours."))
    }).describe("Allows for an optional time granularity setting for metric data.")),
"absolute_time_duration": z.object({
    "end": z.optional(z.string().datetime().describe("The end time for querying data, in ISO 8601 format, using the UTC time zone.")),
"start": z.optional(z.string().datetime().describe("The start time for querying data, in ISO 8601 format, using the UTC time zone."))
    }).describe("Specifies an absolute time range for data queries. Queries begin and end at a specific time.\n\n> ðŸ“˜\n>\n> - You can query data for up to 31 days.\n>\n> - You can specify a `relative_time_duration` or an `absolute_time_duration`, but not both.")
    })]).describe("Settings used for data queries.")

export const postReadMetricMutationResponseSchema = z.lazy(() => postReadMetric200Schema)