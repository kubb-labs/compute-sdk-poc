/**
* Generated by Kubb (https://kubb.dev/).
* Do not edit manually.
*/

import { z } from "zod/v4";

export const putDatabasesPostgreSqlInstancePathParamsSchema = z.object({
    "instanceId": z.coerce.number().int().describe("The ID of the Managed PostgreSQL Database.")
    })

/**
 * @description PostgreSQL Managed Database updated successfully.
 */
export const putDatabasesPostgreSqlInstance200Schema = z.object({
    "allow_list": z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0).describe("Controls access to the Managed Database.\n\n- Individually included IP addresses or CIDR ranges can access the Managed Database while all other sources are blocked.\n\n- A standalone value of `0.0.0.0/0` allows all IP addresses access to the Managed Database.\n\n- An empty array (`[]`) blocks all public and private connections to the Managed Database."),
"cluster_size": z.union([z.literal(1), z.literal(2), z.literal(3)]).default(1).describe("The number of Linode instance nodes deployed to the Managed Database.\n\n - Choose `3` nodes to create a high availability cluster that consists of one primary node and two replica nodes.\n\n- A `2` node cluster is only available with a dedicated plan. It consists of one primary node and one replica node."),
"created": z.string().datetime().describe("__Read-only__ When this Managed Database was created."),
"encrypted": z.boolean().default(true).describe("__Read-only__ Whether the Managed Databases is encrypted. Currently required to be `true`."),
"engine": z.string().describe("__Filterable__, __Read-only__ The Managed Database engine type."),
"engine_config": z.object({
    "pg": z.object({
    "autovacuum_analyze_scale_factor": z.number().min(0).max(1).default(0.2).describe("Specifies a fraction of the table size to add to `autovacuum_analyze_threshold` when deciding whether to trigger an `ANALYZE`."),
"autovacuum_analyze_threshold": z.int().min(0).max(2147483647).default(50).describe("Specifies the minimum number of inserted, updated, or deleted tuples needed to trigger an `ANALYZE` in any one table."),
"autovacuum_max_workers": z.int().min(1).max(20).default(3).describe("Specifies the maximum number of `autovacuum` processes, other than the `autovacuum` launcher, that may be running at any one time. This parameter can only be set at server start."),
"autovacuum_naptime": z.int().min(1).max(86400).default(60).describe("Specifies the minimum delay between `autovacuum` runs on any given database. The delay is measured in seconds."),
"autovacuum_vacuum_cost_delay": z.int().min(-1).max(100).default(20).describe("Specifies the cost delay value that will be used in automatic `VACUUM` operations. If `-1` is specified, the regular `vacuum_cost_delay` value will be used."),
"autovacuum_vacuum_cost_limit": z.int().min(-1).max(10000).default(-1).describe("Specifies the cost limit value that will be used in automatic `VACUUM` operations. The default of `-1` applies the regular `vacuum_cost_limit` value."),
"autovacuum_vacuum_scale_factor": z.number().min(0).max(1).default(0.2).describe("Specifies a fraction of the table size to add to `autovacuum_vacuum_threshold` when deciding whether to trigger a `VACUUM`."),
"autovacuum_vacuum_threshold": z.int().min(0).max(2147483647).default(50).describe("Specifies the minimum number of updated or deleted tuples needed to trigger a `VACUUM` in any one table."),
"bgwriter_delay": z.int().min(20).max(10000).default(200).describe("Specifies the delay between activity rounds for the background writer in milliseconds."),
"bgwriter_flush_after": z.int().min(0).max(2048).default(512).describe("Whenever more than `bgwriter_flush_after` bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes. A setting of `0` disables forced writeback."),
"bgwriter_lru_maxpages": z.int().min(0).max(1073741823).default(100).describe("In each round, no more than this many buffers will be written by the background writer. Setting this to `0` disables background writing."),
"bgwriter_lru_multiplier": z.number().min(0).max(10).default(2.5).describe("The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to `bgwriter_lru_maxpages`). `1.0` represents a `\\u201cjust` in `time\\u201d` policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes."),
"deadlock_timeout": z.int().min(500).max(1800000).describe("This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition."),
"default_toast_compression": z.enum(["lz4", "pglz"]).default("lz4").describe("Specifies the default TOAST compression method for values of compressible columns."),
"idle_in_transaction_session_timeout": z.int().min(0).max(604800000).describe("Time out sessions with open transactions after this number of milliseconds."),
"jit": z.boolean().describe("Controls system-wide use of Just-in-Time Compilation (JIT)."),
"max_files_per_process": z.int().min(1000).max(4096).describe("PostgreSQL maximum number of files that can be open per process."),
"max_locks_per_transaction": z.int().min(64).max(6400).describe("PostgreSQL maximum locks per transaction."),
"max_logical_replication_workers": z.int().min(4).max(64).describe("PostgreSQL maximum logical replication workers, taken from the pool of `max_parallel_workers`."),
"max_parallel_workers": z.int().min(0).max(96).describe("Sets the maximum number of workers that the system can support for parallel queries."),
"max_parallel_workers_per_gather": z.int().min(0).max(96).describe("Sets the maximum number of workers that can be started by a single Gather or Gather Merge node."),
"max_pred_locks_per_transaction": z.int().min(64).max(5120).describe("PostgreSQL maximum predicate locks per transaction."),
"max_replication_slots": z.int().min(8).max(64).describe("PostgreSQL maximum replication slots."),
"max_slot_wal_keep_size": z.int().min(-1).max(2147483647).default(-1).describe("PostgreSQL maximum write ahead log (WAL) size in MB, reserved for replication slots. A value of `-1` which indicates unlimited. The `wal_keep_size` minimum write ahead log (WAL) size setting takes precedence over this."),
"max_stack_depth": z.int().min(2097152).max(6291456).describe("Maximum depth of the stack in bytes."),
"max_standby_archive_delay": z.int().min(1).max(43200000).describe("Maximum standby archive delay in milliseconds."),
"max_standby_streaming_delay": z.int().min(1).max(43200000).describe("Maximum standby streaming delay in milliseconds."),
"max_wal_senders": z.int().min(20).max(64).describe("PostgreSQL maximum write ahead log (WAL) senders."),
"max_worker_processes": z.int().min(8).max(96).describe("Maximum number of background processes that the system can support."),
"password_encryption": z.enum(["scram-sh-256", "md5"]).default("md5").describe("Chooses the algorithm for encrypting passwords."),
"pg_partman_bgw.interval": z.int().min(3600).max(604800).describe("Sets the time interval to run `pg_partman` scheduled tasks."),
"pg_partman_bgw.role": z.string().describe("Controls which role to use for `pg_partman` scheduled background tasks."),
"pg_stat_monitor.pgsm_enable_query_plan": z.boolean().describe("Enables query plan monitoring."),
"pg_stat_monitor.pgsm_max_buckets": z.int().min(1).max(10).describe("Sets the maximum number of buckets."),
"pg_stat_statements.track": z.enum(["all", "top", "none"]).default("top").describe("Controls which statements are counted. Specify `top` to track top-level statements that are issued directly by clients, `all` to also track nested statements, such as those invoked within functions, or `none` to disable statement statistics collection."),
"temp_file_limit": z.int().min(-1).max(2147483647).describe("PostgreSQL temporary file limit in KB. Set to `-1` for unlimited."),
"timezone": z.string().regex(/^[\\w/]*$/).describe("PostgreSQL service time zone."),
"track_activity_query_size": z.int().min(1024).max(10240).describe("Specifies the number of bytes reserved to track the currently executing command for each active session."),
"track_commit_timestamp": z.enum(["on", "off"]).describe("Record the commit time of transactions."),
"track_functions": z.enum(["all", "pl", "none"]).default("none").describe("Enables tracking of function call counts and time used. Specify `pl` to track only procedural-language functions, `all` to also track SQL and C language functions, or `none` to disable function statistics tracking."),
"track_io_timing": z.enum(["on", "off"]).default("off").describe("Enables timing of database I/O calls. This parameter is `off` by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms."),
"wal_sender_timeout": z.int().min(0).max(60000).describe("Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to `0` disables the timeout."),
"wal_writer_delay": z.int().min(10).max(200).default(200).describe("Write ahead log (WAL) flush interval in milliseconds. A value lower than 200 milliseconds may negatively impact performance.")
    }).describe("PostgreSQL-specific advanced configuration parameters."),
"pg_stat_monitor_enable": z.boolean().describe("Enable the `pg_stat_monitor` extension. When this extension is enabled, PostgreSQL restarts the cluster it's in. Additionally, `pg_stat_statements` results for utility commands are unreliable."),
"pglookout": z.object({
    "max_failover_replication_time_lag": z.int().min(10).max(999999).describe("Number of seconds of master unavailability before triggering database failover to standby.")
    }).describe("Parameter used to apply PGLookout settings."),
"shared_buffers_percentage": z.number().min(20).max(60).describe("Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the `shared_buffers` configuration value."),
"work_mem": z.int().min(1).max(4).describe("Sets the maximum amount of memory in MB to be used by a query operation, such as a sort or hash table, before writing to temporary disk files. Default is 1MB + 0.075% of total RAM, up to 32 MB.")
    }).describe("Advanced parameters you can apply to a PostgreSQL Managed Database, via our partner [Aiven's specification](https://aiven.io/docs/products/postgresql/reference/advanced-params). Only include the objects for parameters you want to set in your database. Omit objects for parameters you don't want to define or change.\n\n> ðŸ“˜\n>\n> Aiven may offer additional parameters in their specification. Currently, only those listed here are supported for use in a PostgreSQL Managed Database. You can also run the [List PostgreSQL Managed Database advanced parameters](https://techdocs.akamai.com/linode-api/reference/get-databases-postgresql-config) operation to see an up-to-date list."),
"fork": z.object({
    "restore_time": z.string().datetime().describe("The database timestamp from which it was restored. This is _not_ when the fork was created."),
"source": z.int().describe("The instance id of the database that was forked from.")
    }).describe("Details on the database that was the target of the fork. This only exists if the database was restored by creating a fork from another [MySQL](https://techdocs.akamai.com/linode-api/reference/post-databases-mysql-instances) or [PostgreSQL](https://techdocs.akamai.com/linode-api/reference/post-databases-postgre-sql-instances) database."),
"hosts": z.object({
    "primary": z.nullable(z.string().describe("The primary host for the Managed Database.")),
"secondary": z.nullable(z.string().describe("The secondary/private network host for the Managed Database. A private network host and a private IP can only be used to access a database cluster from Linodes in the same data center and will not incur transfer costs.\n\n> ðŸ“˜\n>\n> The secondary hostname is publicly visible and accessible."))
    }).describe("__Read-only__ The primary and secondary hosts for the Managed Database. These are assigned after provisioning is complete."),
"id": z.int().describe("__Read-only__ A unique ID that can be used to identify and reference the Managed Database."),
"label": z.string().min(3).max(32).describe("__Filterable__ A unique, user-defined string referring to the Managed Database. This string needs to be unique per Managed Database engine type."),
"members": z.object({
    
    }).describe("__Read-only__ A mapping between IP addresses and strings designating them as `primary` or `failover`."),
"oldest_restore_time": z.string().datetime().describe("__Read-only__ The oldest time to which a database can be restored."),
"platform": z.enum(["rdbms-legacy", "rdbms-default"]).describe("__Filterable__, __Read-only__ The back-end platform for relational databases used by the service."),
"port": z.int().describe("__Read-only__ The access port for this Managed Database."),
"private_network": z.nullable(z.object({
    "public_access": z.boolean().default(false).describe("When set to `true`, clients outside of the VPC can connect to the database. Defaults to `false`, where only nodes within the specified `vpc_id` can access the Managed Database cluster.\n\n> ðŸ“˜\n>\n> If your Managed Database is also configured using an `allow_list`, only IP addresses set in it can access that database, even if this object is set to `true`."),
"subnet_id": z.int().describe("The specific subnet, in the VPC (`vpc_id`) where the Managed Database cluster can be accessed."),
"vpc_id": z.int().describe("The unique identifier of the VPC where this database exists.")
    }).describe("__Beta__ Restricts access to a PostgreSQL Managed Database using a Virtual Private Cloud (VPC). Displayed as `null` if no VPC is configured.")),
"region": z.string().describe("__Filterable__ The unique identifier for the [region](https://techdocs.akamai.com/linode-api/reference/get-regions) where the Managed Database lives."),
"ssl_connection": z.boolean().default(true).describe("Currently required to be `true`. Whether to require SSL credentials to establish a connection to the Managed Database. Run the [Get managed PostgreSQL database credentials](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-credentials) operation for access information."),
"status": z.enum(["provisioning", "active", "suspending", "suspended", "resuming", "failed", "degraded", "updating", "resizing"]).describe("__Filterable__, __Read-only__ The operating status of the Managed Database."),
"total_disk_size_gb": z.int().describe("__Read-only__ The total disk size of the database, in GB."),
"type": z.string().describe("__Filterable__ The Linode Instance type used by the Managed Database for its nodes."),
"updated": z.string().datetime().describe("__Read-only__ When this Managed Database was last updated."),
"updates": z.object({
    "day_of_week": z.int().min(1).max(7).describe("The numeric reference for the day of the week to perform maintenance. `1` is Monday, `2` is Tuesday, through to `7` which is Sunday."),
"duration": z.int().min(1).max(3).describe("The maximum maintenance window time in hours."),
"frequency": z.enum(["weekly"]).default("weekly").describe("How frequently maintenance occurs. Currently can only be `weekly`."),
"hour_of_day": z.int().min(0).max(23).describe("The hour to begin maintenance based in UTC time."),
"pending": z.array(z.object({
    "deadline": z.nullable(z.string().datetime().describe("The time when a mandatory update needs to be applied.")),
"description": z.string().describe("A description of the update."),
"planned_for": z.nullable(z.string().datetime().describe("The date and time a maintenance update will be applied."))
    }).describe("A planned maintenance update.")).min(0).describe("__Read-only__ An array of pending updates.")
    }).describe("Configuration settings for automated patch update maintenance for the Managed Database."),
"used_disk_size_gb": z.int().describe("__Read-only__ The amount of space currently in use in the database, in GB."),
"version": z.string().describe("__Filterable__ The Managed Database engine version.")
    }).describe("Managed PostgreSQL Databases object.")

/**
 * @description See [Errors](https://techdocs.akamai.com/linode-api/reference/errors) for the range of possible error response codes.
 */
export const putDatabasesPostgreSqlInstanceErrorSchema = z.object({
    "errors": z.array(z.object({
    "field": z.string().describe("The field in the request that caused this error. This may be a path, separated by periods in the case of nested fields. In some cases this may come back as `null` if the error is not specific to any single element of the request."),
"reason": z.string().describe("What happened to cause this error. In most cases, this can be fixed immediately by changing the data you sent in the request, but in some cases you will be instructed to [Open a support ticket](https://techdocs.akamai.com/linode-api/reference/post-ticket) or perform some other action before you can complete the request successfully.")
    }).describe("An object for describing a single error that occurred during the processing of a request."))
    })

export const putDatabasesPostgreSqlInstanceMutationRequestSchema = z.object({
    "allow_list": z.optional(z.array(z.string().regex(/^([0-9]{1,3}\.){3}[0-9]{1,3}(\/([0-9]|[1-2][0-9]|3[0-2]))?$/)).min(0).describe("Controls access to the Managed Database.\n\n- Individually included IP addresses or CIDR ranges can access the Managed Database while all other sources are blocked.\n\n- A standalone value of `0.0.0.0/0` allows all IP addresses access to the Managed Database.\n\n- An empty array (`[]`) blocks all public and private connections to the Managed Database.")),
"engine_config": z.optional(z.object({
    "pg": z.optional(z.object({
    "autovacuum_analyze_scale_factor": z.optional(z.number().min(0).max(1).default(0.2).describe("Specifies a fraction of the table size to add to `autovacuum_analyze_threshold` when deciding whether to trigger an `ANALYZE`.")),
"autovacuum_analyze_threshold": z.optional(z.int().min(0).max(2147483647).default(50).describe("Specifies the minimum number of inserted, updated, or deleted tuples needed to trigger an `ANALYZE` in any one table.")),
"autovacuum_max_workers": z.optional(z.int().min(1).max(20).default(3).describe("Specifies the maximum number of `autovacuum` processes, other than the `autovacuum` launcher, that may be running at any one time. This parameter can only be set at server start.")),
"autovacuum_naptime": z.optional(z.int().min(1).max(86400).default(60).describe("Specifies the minimum delay between `autovacuum` runs on any given database. The delay is measured in seconds.")),
"autovacuum_vacuum_cost_delay": z.optional(z.int().min(-1).max(100).default(20).describe("Specifies the cost delay value that will be used in automatic `VACUUM` operations. If `-1` is specified, the regular `vacuum_cost_delay` value will be used.")),
"autovacuum_vacuum_cost_limit": z.optional(z.int().min(-1).max(10000).default(-1).describe("Specifies the cost limit value that will be used in automatic `VACUUM` operations. The default of `-1` applies the regular `vacuum_cost_limit` value.")),
"autovacuum_vacuum_scale_factor": z.optional(z.number().min(0).max(1).default(0.2).describe("Specifies a fraction of the table size to add to `autovacuum_vacuum_threshold` when deciding whether to trigger a `VACUUM`.")),
"autovacuum_vacuum_threshold": z.optional(z.int().min(0).max(2147483647).default(50).describe("Specifies the minimum number of updated or deleted tuples needed to trigger a `VACUUM` in any one table.")),
"bgwriter_delay": z.optional(z.int().min(20).max(10000).default(200).describe("Specifies the delay between activity rounds for the background writer in milliseconds.")),
"bgwriter_flush_after": z.optional(z.int().min(0).max(2048).default(512).describe("Whenever more than `bgwriter_flush_after` bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes. A setting of `0` disables forced writeback.")),
"bgwriter_lru_maxpages": z.optional(z.int().min(0).max(1073741823).default(100).describe("In each round, no more than this many buffers will be written by the background writer. Setting this to `0` disables background writing.")),
"bgwriter_lru_multiplier": z.optional(z.number().min(0).max(10).default(2.5).describe("The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to `bgwriter_lru_maxpages`). `1.0` represents a `\\u201cjust` in `time\\u201d` policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes.")),
"deadlock_timeout": z.optional(z.int().min(500).max(1800000).describe("This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.")),
"default_toast_compression": z.optional(z.enum(["lz4", "pglz"]).default("lz4").describe("Specifies the default TOAST compression method for values of compressible columns.")),
"idle_in_transaction_session_timeout": z.optional(z.int().min(0).max(604800000).describe("Time out sessions with open transactions after this number of milliseconds.")),
"jit": z.optional(z.boolean().describe("Controls system-wide use of Just-in-Time Compilation (JIT).")),
"max_files_per_process": z.optional(z.int().min(1000).max(4096).describe("PostgreSQL maximum number of files that can be open per process.")),
"max_locks_per_transaction": z.optional(z.int().min(64).max(6400).describe("PostgreSQL maximum locks per transaction.")),
"max_logical_replication_workers": z.optional(z.int().min(4).max(64).describe("PostgreSQL maximum logical replication workers, taken from the pool of `max_parallel_workers`.")),
"max_parallel_workers": z.optional(z.int().min(0).max(96).describe("Sets the maximum number of workers that the system can support for parallel queries.")),
"max_parallel_workers_per_gather": z.optional(z.int().min(0).max(96).describe("Sets the maximum number of workers that can be started by a single Gather or Gather Merge node.")),
"max_pred_locks_per_transaction": z.optional(z.int().min(64).max(5120).describe("PostgreSQL maximum predicate locks per transaction.")),
"max_replication_slots": z.optional(z.int().min(8).max(64).describe("PostgreSQL maximum replication slots.")),
"max_slot_wal_keep_size": z.optional(z.int().min(-1).max(2147483647).default(-1).describe("PostgreSQL maximum write ahead log (WAL) size in MB, reserved for replication slots. A value of `-1` which indicates unlimited. The `wal_keep_size` minimum write ahead log (WAL) size setting takes precedence over this.")),
"max_stack_depth": z.optional(z.int().min(2097152).max(6291456).describe("Maximum depth of the stack in bytes.")),
"max_standby_archive_delay": z.optional(z.int().min(1).max(43200000).describe("Maximum standby archive delay in milliseconds.")),
"max_standby_streaming_delay": z.optional(z.int().min(1).max(43200000).describe("Maximum standby streaming delay in milliseconds.")),
"max_wal_senders": z.optional(z.int().min(20).max(64).describe("PostgreSQL maximum write ahead log (WAL) senders.")),
"max_worker_processes": z.optional(z.int().min(8).max(96).describe("Maximum number of background processes that the system can support.")),
"password_encryption": z.optional(z.enum(["scram-sh-256", "md5"]).default("md5").describe("Chooses the algorithm for encrypting passwords.")),
"pg_partman_bgw.interval": z.optional(z.int().min(3600).max(604800).describe("Sets the time interval to run `pg_partman` scheduled tasks.")),
"pg_partman_bgw.role": z.optional(z.string().describe("Controls which role to use for `pg_partman` scheduled background tasks.")),
"pg_stat_monitor.pgsm_enable_query_plan": z.optional(z.boolean().describe("Enables query plan monitoring.")),
"pg_stat_monitor.pgsm_max_buckets": z.optional(z.int().min(1).max(10).describe("Sets the maximum number of buckets.")),
"pg_stat_statements.track": z.optional(z.enum(["all", "top", "none"]).default("top").describe("Controls which statements are counted. Specify `top` to track top-level statements that are issued directly by clients, `all` to also track nested statements, such as those invoked within functions, or `none` to disable statement statistics collection.")),
"temp_file_limit": z.optional(z.int().min(-1).max(2147483647).describe("PostgreSQL temporary file limit in KB. Set to `-1` for unlimited.")),
"timezone": z.optional(z.string().regex(/^[\\w/]*$/).describe("PostgreSQL service time zone.")),
"track_activity_query_size": z.optional(z.int().min(1024).max(10240).describe("Specifies the number of bytes reserved to track the currently executing command for each active session.")),
"track_commit_timestamp": z.optional(z.enum(["on", "off"]).describe("Record the commit time of transactions.")),
"track_functions": z.optional(z.enum(["all", "pl", "none"]).default("none").describe("Enables tracking of function call counts and time used. Specify `pl` to track only procedural-language functions, `all` to also track SQL and C language functions, or `none` to disable function statistics tracking.")),
"track_io_timing": z.optional(z.enum(["on", "off"]).default("off").describe("Enables timing of database I/O calls. This parameter is `off` by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.")),
"wal_sender_timeout": z.optional(z.int().min(0).max(60000).describe("Terminate replication connections that are inactive for longer than this amount of time, in milliseconds. Setting this value to `0` disables the timeout.")),
"wal_writer_delay": z.optional(z.int().min(10).max(200).default(200).describe("Write ahead log (WAL) flush interval in milliseconds. A value lower than 200 milliseconds may negatively impact performance."))
    }).describe("PostgreSQL-specific advanced configuration parameters.")),
"pg_stat_monitor_enable": z.optional(z.boolean().describe("Enable the `pg_stat_monitor` extension. When this extension is enabled, PostgreSQL restarts the cluster it's in. Additionally, `pg_stat_statements` results for utility commands are unreliable.")),
"pglookout": z.optional(z.object({
    "max_failover_replication_time_lag": z.optional(z.int().min(10).max(999999).describe("Number of seconds of master unavailability before triggering database failover to standby."))
    }).describe("Parameter used to apply PGLookout settings.")),
"shared_buffers_percentage": z.optional(z.number().min(20).max(60).describe("Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the `shared_buffers` configuration value.")),
"work_mem": z.optional(z.int().min(1).max(4).describe("Sets the maximum amount of memory in MB to be used by a query operation, such as a sort or hash table, before writing to temporary disk files. Default is 1MB + 0.075% of total RAM, up to 32 MB."))
    }).describe("Advanced parameters you can apply to a PostgreSQL Managed Database, via our partner [Aiven's specification](https://aiven.io/docs/products/postgresql/reference/advanced-params). Only include the objects for parameters you want to set in your database. Omit objects for parameters you don't want to define or change.\n\n> ðŸ“˜\n>\n> Aiven may offer additional parameters in their specification. Currently, only those listed here are supported for use in a PostgreSQL Managed Database. You can also run the [List PostgreSQL Managed Database advanced parameters](https://techdocs.akamai.com/linode-api/reference/get-databases-postgresql-config) operation to see an up-to-date list.")),
"label": z.optional(z.string().min(3).max(32).describe("__Filterable__ A unique, user-defined string referring to the Managed Database. This string needs to be unique per Managed Database engine type.")),
"private_network": z.object({
    "public_access": z.optional(z.boolean().default(false).describe("Set to `true` to allow clients outside of the VPC to connect to the database using a public IP address. Defaults to `false`, where only nodes within the specified `vpc_id` can access the Managed Database cluster.\n\n> ðŸ“˜\n>\n> If your Managed Database is also configured using an `allow_list`, only IP addresses set in it can access that database, even if this object is set to `true`.")),
"subnet_id": z.optional(z.int().describe("If the `vpc_id` includes subnets, you can include the one you want to limit access to the database. From the [List VPCs](https://techdocs.akamai.com/linode-api/reference/get-vpcs) operation, store the `id` for the applicable `subnets` object.")),
"vpc_id": z.optional(z.int().describe("The unique identifier of the VPC you want to use to enable private access to the Managed Database. Run the [List VPCs](https://techdocs.akamai.com/linode-api/reference/get-vpcs) operation and store the `id` for the applicable VPC."))
    }).describe("__Beta__ Restricts access on a PostgreSQL Managed Database to a specific Virtual Private Cloud (VPC) configured for the cluster.").nullish(),
"type": z.optional(z.string().describe("Request re-sizing of your cluster to a Linode Type with more disk space. For example, you could request a Linode Type that uses a higher plan.\n\n- Needs to be a Linode Type with more disk space than your current Linode.\n\n- Resizing to a larger Linode Type can accrue additional cost. Review the `price` output from the [List types](https://techdocs.akamai.com/linode-api/reference/get-linode-types) operation for more information.\n\n- You can't update the `allow_list` and set a new `type` in the same request.\n\n- Any active updates to your cluster need to complete before you can request a resize. The reverse is also true: An active resizing needs to complete before you can perform any other update.")),
"updates": z.optional(z.object({
    "day_of_week": z.optional(z.int().min(1).max(7).describe("The numeric reference for the day of the week to perform maintenance. `1` is Monday, `2` is Tuesday, through to `7` which is Sunday.")),
"duration": z.optional(z.int().min(1).max(3).describe("The maximum maintenance window time in hours.")),
"frequency": z.optional(z.enum(["weekly"]).default("weekly").describe("How frequently maintenance occurs. Currently can only be `weekly`.")),
"hour_of_day": z.optional(z.int().min(0).max(23).describe("The hour to begin maintenance based in UTC time.")),
"pending": z.optional(z.array(z.object({
    "deadline": z.string().datetime().describe("The time when a mandatory update needs to be applied.").nullish(),
"description": z.optional(z.string().describe("A description of the update.")),
"planned_for": z.string().datetime().describe("The date and time a maintenance update will be applied.").nullish()
    }).describe("A planned maintenance update.")).min(0).describe("__Read-only__ An array of pending updates."))
    }).describe("Configuration settings for automated patch update maintenance for the Managed Database.")),
"version": z.optional(z.string().describe("__Filterable__ The Managed Database engine version."))
    }).describe("Updated information for the Managed PostgreSQL Database.")

export const putDatabasesPostgreSqlInstanceMutationResponseSchema = z.lazy(() => putDatabasesPostgreSqlInstance200Schema)