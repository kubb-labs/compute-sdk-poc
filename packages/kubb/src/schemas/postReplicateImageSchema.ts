/**
* Generated by Kubb (https://kubb.dev/).
* Do not edit manually.
*/

import { z } from "zod/v4";

export const postReplicateImagePathParamsSchema = z.object({
    "imageId": z.string().describe("The unique identifier assigned to the image after creation.")
    })

/**
 * @description Replication details for the image.
 */
export const postReplicateImage200Schema = z.object({
    "capabilities": z.array(z.string()).describe("__Read-only__ A list of the possible capabilities of this image.\n\n- `cloud-init`. The image supports the cloud-init multi-distribution method with our [Metadata service](https://www.linode.com/docs/products/compute/compute-instances/guides/metadata/#troubleshoot-metadata-and-cloud-init). This only applies to public images.\n\n- `distributed-sites`. Whether the image can be used in distributed compute regions. Compared to a core compute region, distributed compute regions offer limited functionality, but they're globally distributed. Your image can be geographically closer to you, potentially letting you deploy it quicker. See [Regions and images](https://techdocs.akamai.com/cloud-computing/docs/images#regions-and-images) for complete details."),
"created": z.string().datetime().describe("__Read-only__ When this image was created."),
"created_by": z.string().describe("__Read-only__ The name of the user who created this image, or `linode` for public images."),
"deprecated": z.boolean().describe("__Filterable__, __Read-only__ A `true` value indicates a deprecated image. Only public images can be deprecated."),
"description": z.nullable(z.string().min(1).max(65000).describe("A detailed description of this image.")),
"eol": z.nullable(z.string().datetime().describe("__Read-only__ The time of the public image's planned removal from service. This is `null` for private images.")),
"expiry": z.nullable(z.string().datetime().describe("__Read-only__ Only images created automatically from a deleted compute instance (type=automatic) expire. This is `null` for private images.")),
"id": z.string().describe("__Read-only__ The unique identifier for each image."),
"image_sharing": z.union([z.object({
    "shared_by": z.nullable(z.object({
    
    }).describe("This field is `null` in this case, meaning the image is not shared by any group. See the `shared_with` field for details on the image's share group.")),
"shared_with": z.object({
    "sharegroup_count": z.int().describe("The number of share groups the image is shared with."),
"sharegroup_list_url": z.string().describe("A URL to view the list of share groups the image is shared with.")
    }).describe("Specifies the group that the image is shared with, including the number of share groups and a URL to view the share groups' list.")
    }), z.object({
    "shared_by": z.object({
    "sharegroup_id": z.int().describe("The share group's identifier."),
"sharegroup_label": z.string().describe("The share group's descriptive name."),
"sharegroup_uuid": z.uuid().describe("The share group's unique identifier."),
"source_image_id": z.nullable(z.string().describe("The source image's slug identifier. `null` if no specific source image is referenced."))
    }).describe("Specifies the details of the share group that is sharing the image."),
"shared_with": z.nullable(z.object({
    
    }).describe("This field is `null` in this case, meaning the image is not shared with anyone. See the `shared_by` fields for additional details about this shared image."))
    })]).describe("Details about image sharing."),
"is_public": z.boolean().describe("__Filterable__, __Read-only__ A `true` value if the image is a public distribution image. A `false` value indicates private, account-specific images."),
"is_shared": z.enum(["true", "false", "none"]).describe("__Filterable__, __Read-only__ A `true` value for shared private images. `none` for images shared within a group."),
"label": z.string().describe("__Filterable__ A short description of the image."),
"regions": z.array(z.object({
    "region": z.string().describe("The unique identifier for the core compute region where this image is stored."),
"status": z.enum(["available", "creating", "pending", "pending deletion", "pending replication", "replicating"]).describe("The status of the image in this `region`. Possible values are `available`, `creating`, `pending`, `pending deletion`, `pending replication`, or `replicating`.")
    })).describe("__Read-only__ Details on the regions where this image is stored. See [Regions and images](https://techdocs.akamai.com/cloud-computing/docs/images#regions-and-images) for full details on support for `regions`."),
"size": z.int().describe("__Filterable__, __Read-only__ The minimum size in MB this image needs to deploy."),
"status": z.enum(["creating", "pending_upload", "available"]).describe("__Filterable__, __Read-only__ The current status of the image. Possible values are `available`, `creating`, and `pending_upload`.\n\n> ðŸ“˜\n>\n> The `+order_by` and `+order` operators are not available when [filtering](https://techdocs.akamai.com/linode-api/reference/filtering-and-sorting) on this key."),
"tags": z.array(z.string().min(3).max(100)).min(0).max(500).describe("__Filterable__ Tags used for organizational purposes. A tag can be from 3 to 100 characters long, and an image can have a maximum of 500 total tags."),
"total_size": z.int().describe("__Read-only__ The total size in bytes of all instances of this image, in all `regions`.\n\n> ðŸ“˜\n>\n> This object is empty for existing images. It's intended for use with future functionality."),
"type": z.enum(["manual", "automatic", "shared"]).describe("__Filterable__, __Read-only__ How the image was created. Create a `manual` image at any time. An `automatic` image is created automatically from a deleted compute instance. Other users within share groups can access a `shared` image."),
"updated": z.string().datetime().describe("__Read-only__ When this image was last updated."),
"vendor": z.nullable(z.string().describe("__Filterable__, __Read-only__ The upstream distribution vendor. This is `null` for private images."))
    }).describe("Image object.")

/**
 * @description See [Errors](https://techdocs.akamai.com/linode-api/reference/errors) for the range of possible error response codes.
 */
export const postReplicateImageErrorSchema = z.object({
    "errors": z.array(z.object({
    "field": z.string().describe("The field in the request that caused this error. This may be a path, separated by periods in the case of nested fields. In some cases this may come back as `null` if the error is not specific to any single element of the request."),
"reason": z.string().describe("What happened to cause this error. In most cases, this can be fixed immediately by changing the data you sent in the request, but in some cases you will be instructed to [Open a support ticket](https://techdocs.akamai.com/linode-api/reference/post-ticket) or perform some other action before you can complete the request successfully.")
    }).describe("An object for describing a single error that occurred during the processing of a request."))
    })

export const postReplicateImageMutationRequestSchema = z.object({
    "regions": z.optional(z.array(z.string()).describe("The unique identifier for each compute `region`. See [Regions and images](https://techdocs.akamai.com/cloud-computing/docs/images#regions-and-images) for full details on support for `regions`."))
    }).describe("List of regions where the image should be replicated to.")

export const postReplicateImageMutationResponseSchema = z.lazy(() => postReplicateImage200Schema)