/**
* Generated by Kubb (https://kubb.dev/).
* Do not edit manually.
*/

import { z } from "zod/v4";

export const getSharegroupImagesPathParamsSchema = z.object({
    "sharegroupId": z.coerce.number().int().describe("The share group's unique identifier assigned after creating it. Not to be confused with the group's `uuid`.")
    })

/**
 * @description Returns a paginated list of shared images within a given group.
 */
export const getSharegroupImages200Schema = z.object({
    "data": z.array(z.object({
    "capabilities": z.array(z.string()).describe("__Read-only__ A list of the possible capabilities of this image."),
"created": z.string().datetime().describe("__Read-only__ When this image share was created."),
"created_by": z.nullable(z.string().describe("__Read-only__ The shared image creator's username.")),
"deprecated": z.boolean().describe("__Read-only__ A `true` value indicates a deprecated image. Only public images can be deprecated."),
"description": z.string().describe("The shared image's detailed description."),
"eol": z.nullable(z.string().datetime().describe("__Read-only__ The time of the public image's planned removal from service. `null` for private images.")),
"expiry": z.nullable(z.string().datetime().describe("__Read-only__ Only images created automatically from a deleted compute instance (`type=automatic`) expire, `null` for private images.")),
"id": z.string().describe("__Read-only__ The shared image's unique idenfifier."),
"image_sharing": z.object({
    "shared_by": z.object({
    "sharegroup_id": z.int().describe("__Read-only__ The share group's numeric identifier, used primarily as path parameters in URLs."),
"sharegroup_label": z.string().describe("The share group's descriptive name."),
"sharegroup_uuid": z.uuid().describe("__Read-only__ The share group's unique identifier used for membership token management."),
"source_image_id": z.string().describe("__Read-only__ The source image's slug identifier.")
    }),
"shared_with": z.nullable(z.object({
    
    }).describe("Details about who this image was shared with."))
    }).describe("__Read-only__ Sharing information for the image, including who it was shared by and with."),
"is_public": z.boolean().describe("__Read-only__ A `true` value if the image is a public distribution image. A `false` value indicates private, account-specific images."),
"is_shared": z.nullable(z.enum(["true", "false", "none"]).describe("__Read-only__ A `true` value for shared private images. `none` for images shared within a group.")),
"label": z.string().describe("__Filterable__ The shared image's name."),
"regions": z.array(z.object({
    "region": z.string().describe("The unique identifier for the core compute region where this image is stored."),
"status": z.enum(["available", "creating", "pending", "pending deletion", "pending replication", "replicating"]).describe("The status of the image in this `region`. Possible values are `available`, `creating`, `pending`, `pending deletion`, `pending replication`, or `replicating`.")
    })).describe("__Filterable__, __Read-only__ Details on the regions where this image is stored. See [Regions and images](https://techdocs.akamai.com/cloud-computing/docs/images#regions-and-images) for full details on support for `regions`."),
"size": z.int().describe("__Read-only__ The minimum size in MB this image needs to deploy."),
"status": z.enum(["creating", "pending_upload", "available"]).describe("__Read-only__ The current status of the image. Possible values are `available`, `creating`, and `pending_upload`."),
"tags": z.array(z.string().min(3).max(100)).min(0).max(500).describe("__Filterable__, __Read-only__ The shared image's organizational tags. A tag can be from 3 to 100 characters long, and each image can include up to 500 tags."),
"total_size": z.int().describe("__Read-only__ The total size in bytes of all instances of this image, in all `regions`."),
"type": z.enum(["manual", "automatic", "shared"]).describe("__Filterable__, __Read-only__ Indicates how the image was created. It's always `shared` for images in a shared group. An `automatic` image is created automatically from a deleted compute instance. Other users within share groups can access a `shared` image."),
"updated": z.nullable(z.string().datetime().describe("__Read-only__ When this image share was last updated.")),
"vendor": z.nullable(z.string().describe("__Read-only__ The upstream distribution vendor, `null` for private and shared images."))
    }).describe("The shared image's details.")),
"page": z.int().describe("__Read-only__ The current [page](https://techdocs.akamai.com/linode-api/reference/pagination)."),
"pages": z.int().describe("__Read-only__ The total number of [pages](https://techdocs.akamai.com/linode-api/reference/pagination)."),
"results": z.int().describe("__Read-only__ The total number of results.")
    })

/**
 * @description See [Errors](https://techdocs.akamai.com/linode-api/reference/errors) for the range of possible error response codes.
 */
export const getSharegroupImagesErrorSchema = z.object({
    "errors": z.array(z.object({
    "field": z.string().describe("The field in the request that caused this error. This may be a path, separated by periods in the case of nested fields. In some cases this may come back as `null` if the error is not specific to any single element of the request."),
"reason": z.string().describe("What happened to cause this error. In most cases, this can be fixed immediately by changing the data you sent in the request, but in some cases you will be instructed to [Open a support ticket](https://techdocs.akamai.com/linode-api/reference/post-ticket) or perform some other action before you can complete the request successfully.")
    }).describe("An object for describing a single error that occurred during the processing of a request."))
    })

export const getSharegroupImagesQueryResponseSchema = z.lazy(() => getSharegroupImages200Schema)