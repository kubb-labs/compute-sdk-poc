/**
* Generated by Kubb (https://kubb.dev/).
* Do not edit manually.
*/

import { z } from "zod/v4";

export const postNodeBalancerNodePathParamsSchema = z.object({
    "apiVersion": z.enum(["v4", "v4beta"]).describe("__Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta."),
"nodeBalancerId": z.coerce.number().int().describe("The ID of the NodeBalancer."),
"configId": z.coerce.number().int().describe("The ID of the NodeBalancer config to access.")
    })

/**
 * @description Node created successfully.
 */
export const postNodeBalancerNode200Schema = z.union([z.object({
    "address": z.optional(z.string().describe("The address and port where this backend can be reached: either the Linode’s private IPv4, public IPv6, or the VPC's IPv4 address.")),
"config_id": z.optional(z.int().describe("__Read-only__ The NodeBalancer Config ID that this Node belongs to.")),
"id": z.optional(z.int().describe("__Read-only__ This node's unique ID.")),
"label": z.optional(z.string().regex(/[a-zA-Z0-9-_.]{3,32}/).describe("The label for this node.  This is for display purposes only.")),
"mode": z.optional(z.enum(["accept", "reject", "drain", "backup"]).describe("The mode this NodeBalancer should use when sending traffic to this backend.\n\n- If set to `accept` this backend is accepting traffic.\n- If set to `reject` this backend will not receive traffic.\n- If set to `drain` this backend will not receive _new_ traffic, but connections already pinned to it will continue to be routed to it.\n- If set to `backup`, this backend will only receive traffic if all `accept` nodes are down.")),
"nodebalancer_id": z.optional(z.int().describe("__Read-only__ The NodeBalancer ID that this Node belongs to.")),
"status": z.optional(z.enum(["Unknown", "UP", "DOWN"]).describe("__Read-only__ The current status of this node, based on the configured checks of its NodeBalancer Config.")),
"vpc_config_id": z.int().describe("__Read-only__ For VPC backends, you can use the `vpc_config_id` to [get VPC IDs and VPC subnet IDs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-vpc-config). Returns a `null` value if the backend is not a VPC node. Included only in `{apiVersion}` `v4beta`.").nullish(),
"weight": z.optional(z.int().min(1).max(255).describe("Used when picking a backend to serve a request and is not pinned to a single backend yet. Nodes with a higher weight will receive more traffic."))
    }), z.object({
    "address": z.optional(z.string().describe("The address and port where this backend can be reached: either the Linode’s private IPv4, public IPv6, or the VPC's IPv4 address.")),
"config_id": z.optional(z.int().describe("__Read-only__ The NodeBalancer Config ID that this Node belongs to.")),
"id": z.optional(z.int().describe("__Read-only__ This node's unique ID.")),
"label": z.optional(z.string().regex(/[a-zA-Z0-9-_.]{3,32}/).describe("The label for this node.  This is for display purposes only.")),
"mode": z.optional(z.enum(["none"]).describe("__Read-only__ The mode this NodeBalancer should use when sending traffic to this backend. For backend nodes with a UDP config, the `mode` doesn't apply, so the value is `none`.")),
"nodebalancer_id": z.optional(z.int().describe("__Read-only__ The NodeBalancer ID that this Node belongs to.")),
"status": z.optional(z.enum(["Unknown", "UP", "DOWN"]).describe("__Read-only__ The current status of this node, based on the configured checks of its NodeBalancer config.")),
"vpc_config_id": z.int().describe("__Read-only__ For VPC backends, the `vpc_config_id` can be used to [get VPC IDs and VPC subnet IDs](https://techdocs.akamai.com/linode-api/reference/get-node-balancer-vpc-config). Returns a `null` value if the backend is not a VPC node. Included only when the `apiVersion` is `v4beta`.").nullish(),
"weight": z.optional(z.int().min(1).max(255).describe("Used when picking a backend to serve a request and is not pinned to a single backend yet. Nodes with a higher weight will receive more traffic."))
    })]).describe("A NodeBalancer node represents a single backend serving requests for a single port on a NodeBalancer. Nodes are tied to NodeBalancer configurations, and serve traffic over their private IPv4 address, IPv6 address, or VPC IPv4 address. If the same Linode is serving traffic for more than one port on the same NodeBalancer, one NodeBalancer node is required for each config (port) it should serve requests on.  For example, if you have four backends, and each should respond to both HTTP and HTTPS requests, you will need two NodeBalancer configs (port 80 and port 443) and four backends each, one for each of the Linodes serving requests for that port.")

/**
 * @description See [Errors](https://techdocs.akamai.com/linode-api/reference/errors) for the range of possible error response codes.
 */
export const postNodeBalancerNodeErrorSchema = z.object({
    "errors": z.optional(z.array(z.object({
    "field": z.optional(z.string().describe("The field in the request that caused this error. This may be a path, separated by periods in the case of nested fields. In some cases this may come back as `null` if the error is not specific to any single element of the request.")),
"reason": z.optional(z.string().describe("What happened to cause this error. In most cases, this can be fixed immediately by changing the data you sent in the request, but in some cases you will be instructed to [Open a support ticket](https://techdocs.akamai.com/linode-api/reference/post-ticket) or perform some other action before you can complete the request successfully."))
    }).describe("An object for describing a single error that occurred during the processing of a request.")))
    })

/**
 * @description Information about the node the NodeBalancer configuration will direct traffic to. The fields available for the backend node depend on the configuration\'s protocol, and if the backend node is in a VPC.
 */
export const postNodeBalancerNodeMutationRequestSchema = z.union([z.object({
    "address": z.optional(z.string().describe("Backend nodes can be Linodes and Linodes within a VPC. The following IP types are supported:\n  - For non-VPC backend nodes, the private IPv4 address and port where this backend can be reached.\n  - For non-VPC backend nodes, the public IPv6 address and port where this backend can be reached.\n  - For backend nodes within a VPC, the IPv4 address and port where this backend can be reached.")),
"config_id": z.optional(z.int().describe("__Read-only__ The NodeBalancer Config ID that this Node belongs to.")),
"id": z.optional(z.int().describe("__Read-only__ This node's unique ID.")),
"label": z.optional(z.string().regex(/[a-zA-Z0-9-_.]{3,32}/).describe("The label for this node.  This is for display purposes only.")),
"mode": z.optional(z.enum(["none"]).describe("__Read-only__ The mode this NodeBalancer should use when sending traffic to this backend. For backend nodes with a UDP config, the `mode` doesn't apply, so the value is `none`.")),
"nodebalancer_id": z.optional(z.int().describe("__Read-only__ The NodeBalancer ID that this Node belongs to.")),
"status": z.optional(z.enum(["unknown", "UP", "DOWN"]).describe("__Read-only__ The current status of this node, based on the configured checks of its NodeBalancer config.")),
"subnet_id": z.optional(z.int().describe("Required for VPC backend nodes only. The VPC's subnet. To display information about your VPCs and their subnets, run the [List VPCs](https://techdocs.akamai.com/linode-api/reference/get-vpcs) operation.")),
"weight": z.optional(z.int().min(1).max(255).describe("Used when picking a backend to serve a request and is not pinned to a single backend yet. Nodes with a higher weight will receive more traffic."))
    }), z.object({
    "address": z.optional(z.string().describe("Backend nodes can be Linodes and Linodes within a VPC. The following IP types are supported:\n  - For non-VPC backend nodes, the private IPv4 address and port where this backend can be reached.\n  - For non-VPC backend nodes, the public IPv6 address and port where this backend can be reached.\n  - For backend nodes within a VPC, the IPv4 address and port where this backend can be reached.")),
"config_id": z.optional(z.int().describe("__Read-only__ The NodeBalancer Config ID that this Node belongs to.")),
"id": z.optional(z.int().describe("__Read-only__ This node's unique ID.")),
"label": z.optional(z.string().regex(/[a-zA-Z0-9-_.]{3,32}/).describe("The label for this node.  This is for display purposes only.")),
"mode": z.optional(z.enum(["accept", "reject", "drain", "backup"]).describe("The mode this NodeBalancer should use when sending traffic to this backend.\n\n- If set to `accept` this backend is accepting traffic.\n- If set to `reject` this backend will not receive traffic.\n- If set to `drain` this backend will not receive _new_ traffic, but connections already pinned to it will continue to be routed to it.\n- If set to `backup`, this backend will only receive traffic if all `accept` nodes are down.")),
"nodebalancer_id": z.optional(z.int().describe("__Read-only__ The NodeBalancer ID that this Node belongs to.")),
"status": z.optional(z.enum(["unknown", "UP", "DOWN"]).describe("__Read-only__ The current status of this node, based on the configured checks of its NodeBalancer Config.")),
"subnet_id": z.optional(z.int().describe("Required for VPC backend nodes only. The VPC's subnet. To display information about your VPCs and their subnets, run the [List VPCs](https://techdocs.akamai.com/linode-api/reference/get-vpcs) operation.")),
"weight": z.optional(z.int().min(1).max(255).describe("Used when picking a backend to serve a request and is not pinned to a single backend yet. Nodes with a higher weight will receive more traffic."))
    })])

export const postNodeBalancerNodeMutationResponseSchema = z.lazy(() => postNodeBalancerNode200Schema)